<!DOCTYPE html>
<html lang="">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="骑麦兜看落日">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="骑麦兜看落日">
    
    <meta name="keywords" content="骑麦兜看落日,骑麦兜看落日">
    
    <meta name="description" content>
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>[Code]Python学习手册_第三部分_语句和语法 · 骑麦兜看落日&#39;s Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
        <!-- algolia -->
        <script>
            
            var hits = JSON.parse('{"per_page":10}')
            var labels = JSON.parse('{"input_placeholder":"Search for Posts","hits_empty":"We did not find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}')

            var algolia = {
                applicationID: '5D5KDIMZEQ',
                apiKey: 'b4ec67c101aa9269e65e640e2e469343',
                indexName: 'my_index',
                hits: hits,
                labels: labels
            }
        </script>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >骑麦兜看落日</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">[Code]Python学习手册_第三部分_语句和语法</a>
            </div>
    </div>
    
    <a class="home-link" href=/>骑麦兜看落日</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:30vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            [Code]Python学习手册_第三部分_语句和语法
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "Note">Note</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "Code">Code</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "Python">Python</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">27.2k</span>阅读时长: <span class="post-count reading-time">119 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2018/07/30</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="第十章-Python语句简介"><a href="#第十章-Python语句简介" class="headerlink" title="第十章 Python语句简介"></a>第十章 Python语句简介</h1><blockquote>
<p>本章介绍了语句和代码块代码编写的通用规则</p>
<ul>
<li>一般情况下每行编写一条语句</li>
<li>嵌套代码块中的所有语句都缩进相同的量</li>
<li>一些例外情况有连续行以及单行测试和循环</li>
</ul>
</blockquote>
<hr>
<h2 id="重访Python程序结构"><a href="#重访Python程序结构" class="headerlink" title="重访Python程序结构"></a>重访Python程序结构</h2><p>Python的语法实质是<strong>语句</strong>和<strong>表达式</strong>组成的</p>
<blockquote>
<ul>
<li>程序由模块构成</li>
<li>模块包含语句</li>
<li>语句包含表达式</li>
<li>表达式建立并处理对象</li>
</ul>
</blockquote>
<p>模块包含语句,语句则管理模块</p>
<p>语句使用并引导表达式处理对象</p>
<p>语句可以生成对象</p>
<h3 id="Python的语句"><a href="#Python的语句" class="headerlink" title="Python的语句"></a>Python的语句</h3><table>
<thead>
<tr>
<th>语句</th>
<th>用途</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>赋值</td>
<td>创建引用值</td>
<td>a, b, c = ‘good’, ‘bad’, ‘ugly’</td>
</tr>
<tr>
<td>调用</td>
<td>执行函数</td>
<td>log.write(“spam, ham”)</td>
</tr>
<tr>
<td>打印调用</td>
<td>打印对象</td>
<td>print(‘The Killer’, joke)</td>
</tr>
<tr>
<td>if/elif/else</td>
<td>选择动作</td>
<td>if “python” in text: print(text)</td>
</tr>
<tr>
<td>for/else</td>
<td>序列迭代</td>
<td>for x in mylist: print(x)</td>
</tr>
<tr>
<td>while/else</td>
<td>一般循环</td>
<td>while X &gt; Y: print(‘hello’)</td>
</tr>
<tr>
<td>pass</td>
<td>空占位符</td>
<td>while True: pass</td>
</tr>
<tr>
<td>break</td>
<td>循环退出</td>
<td>while True: if exittest(): berak</td>
</tr>
<tr>
<td>continue</td>
<td>循环继续</td>
<td>while True: if skiptest(): continue</td>
</tr>
<tr>
<td>def</td>
<td>函数和方法</td>
<td>def f(a, b, c=1, *d): print(a+b+c+d[0])</td>
</tr>
<tr>
<td>return</td>
<td>函数结果</td>
<td>def f(a, b, c=1, *d): return a+b+c+d[0]</td>
</tr>
<tr>
<td>yield</td>
<td>生成器函数</td>
<td>def gen(n): for i in n: yield i*2</td>
</tr>
<tr>
<td>global</td>
<td>命名空间</td>
<td>x = ‘old’; def function(): global x,y;  x = ‘new’</td>
</tr>
<tr>
<td>nonlocal</td>
<td>命名空间</td>
<td>def outer(): x = ‘old’;def function(): nonlocal x;x = ‘new’</td>
</tr>
<tr>
<td>import</td>
<td>模块访问</td>
<td>import sys</td>
</tr>
<tr>
<td>from</td>
<td>属性访问</td>
<td>from sys import stdin</td>
</tr>
<tr>
<td>class</td>
<td>创建对象</td>
<td>class Subclass(Surperclass): staticData = [];def method(self): pass</td>
</tr>
<tr>
<td>try/except/finally</td>
<td>捕捉异常</td>
<td>try: action();except: print(‘action error’)</td>
</tr>
<tr>
<td>raise</td>
<td>触发异常</td>
<td>raise EndSearch(location)</td>
</tr>
<tr>
<td>assert</td>
<td>调试检查</td>
<td>assert X&gt;Y, ‘X too small’</td>
</tr>
<tr>
<td>with/as</td>
<td>环境管理器</td>
<td>with open(‘data’) as myfile: process(myfile)</td>
</tr>
<tr>
<td>del</td>
<td>删除引用</td>
<td>del data[k];del data[i:j];del obj.attr;del variable</td>
</tr>
</tbody></table>
<ul>
<li>赋值语句以不同的语法形式呈现:基本的、序列的、拓展的</li>
<li><code>print</code>不是一个保留字,也不是一套语句,而是一个内置的含糊调用</li>
<li><code>yield</code>是一个表达式而不是一条语句</li>
</ul>
<hr>
<h2 id="两个if的故事"><a href="#两个if的故事" class="headerlink" title="两个if的故事"></a>两个if的故事</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &gt; y)&#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可能是C、C++、Java、JavaScript或Perl的语句</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; y:</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    y = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>Python语法成分比较少</p>
<h3 id="Python增加了什么"><a href="#Python增加了什么" class="headerlink" title="Python增加了什么"></a>Python增加了什么</h3><p>Python中的语法成分<code>:</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">header line:</span><br><span class="line">	Nested statement block</span><br></pre></td></tr></table></figure>

<p>Python的所有<strong>复合语句</strong>都有相同的一般形式:首行以<code>:</code>结尾,首行下一行嵌套的代码按缩进的格式书写</p>
<h3 id="Python删除了什么"><a href="#Python删除了什么" class="headerlink" title="Python删除了什么"></a>Python删除了什么</h3><p>与类C语言程序比较</p>
<h4 id="括号是可选的"><a href="#括号是可选的" class="headerlink" title="括号是可选的"></a>括号是可选的</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; y</span><br></pre></td></tr></table></figure>

<p>Python可以省略括号</p>
<h4 id="终止行就是终止语句"><a href="#终止行就是终止语句" class="headerlink" title="终止行就是终止语句"></a>终止行就是终止语句</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Python中一行的结束会自动终止该行的语句</p>
<p>Python允许在每个语句末使用分号</p>
<h4 id="缩进的结束就是代码块的结束"><a href="#缩进的结束就是代码块的结束" class="headerlink" title="缩进的结束就是代码块的结束"></a>缩进的结束就是代码块的结束</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; y:</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    y = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>Python中把嵌套块里所有的语句向右缩进相同的距离,确定代码块的开头和结尾</p>
<p><code>缩进</code>指嵌套语句至左侧的所有空白</p>
<p>Python不在乎怎么缩进(空格或制表符)或者缩进多少(任意多个空格或是制表符),并且两个嵌套代码块的缩进可以完全不同</p>
<h3 id="为什么使用缩进语法"><a href="#为什么使用缩进语法" class="headerlink" title="为什么使用缩进语法"></a>为什么使用缩进语法</h3><p>使用缩进语法可以根据程序的逻辑结构,以垂直对齐的方式来组织程序代码,让程序更一致并具有可读性,从而具备重用性和可维护性</p>
<p>索引没有绝对的标准,常见的是每层四个空格或一个制表符</p>
<p>不可以在同一段Python代码中混合使用制表符和空格</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">    <span class="keyword">if</span> y:</span><br><span class="line">        statement1</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement2</span><br></pre></td></tr></table></figure>

<h3 id="几个特殊实例"><a href="#几个特殊实例" class="headerlink" title="几个特殊实例"></a>几个特殊实例</h3><p>Python的语法模型</p>
<blockquote>
<ul>
<li>一行的结束就是终止该行语句(没有分号)</li>
<li>嵌套语句是代码块并且与实际的缩进相关(没有大括号)</li>
</ul>
</blockquote>
<h4 id="语句规则的特殊情况"><a href="#语句规则的特殊情况" class="headerlink" title="语句规则的特殊情况"></a>语句规则的特殊情况</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>; b = <span class="number">2</span>; print(a + b)	<span class="comment"># Three statements on one line</span></span><br></pre></td></tr></table></figure>

<p>可以将多个简单语句写入一行,由语句限定符<code>;</code>隔开</p>
<p>复合语句不可以与其他语句写入一行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mlist = [<span class="number">111</span>,</span><br><span class="line">        <span class="number">222</span>,</span><br><span class="line">        <span class="number">333</span>]</span><br><span class="line">X = (A + B +</span><br><span class="line">    C + D)</span><br><span class="line"><span class="keyword">if</span>  (A == <span class="number">1</span> <span class="keyword">and</span></span><br><span class="line">    B == <span class="number">2</span> <span class="keyword">and</span></span><br><span class="line">    C == <span class="number">3</span>):</span><br><span class="line">    	print(<span class="string">'spam'</span> * <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>括在<code>()</code>、<code>[]</code>、<code>{}</code>中的语句可以让语句的范围横跨多行直到遇见闭合的括号</p>
<p>括号中的复合语句同样可以跨越多行</p>
<p>尽管连续行可以不缩进,为了程序的可读性也应该对齐</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = A + B + \	<span class="comment"># An error-prone alternative</span></span><br><span class="line">	C + D</span><br></pre></td></tr></table></figure>

<p>当上一行以反斜线结束时,可以在下一行继续</p>
<p>但是这种方法不再提倡,因为关注并维护反斜线比较困难,而且这种操作相当脆弱</p>
<h4 id="代码块规则特殊实例"><a href="#代码块规则特殊实例" class="headerlink" title="代码块规则特殊实例"></a>代码块规则特殊实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; y: print(x)</span><br></pre></td></tr></table></figure>

<p>复合语句的主体可以出现在Python的首行<code>:</code>之后</p>
<blockquote>
<ul>
<li>复合语句不可以跟在<code>:</code>之后</li>
<li>较复杂的语句不可以跟在<code>:</code>之后</li>
<li>复合语句的附带部分,例如<code>if</code>的<code>else</code>部分不可以跟在<code>:</code>之后</li>
</ul>
</blockquote>
<p>语句体可以由几个简单语句组成并用<code>;</code>隔开</p>
<hr>
<h2 id="简短实例-交互循环"><a href="#简短实例-交互循环" class="headerlink" title="简短实例:交互循环"></a>简短实例:交互循环</h2><h3 id="一个简单的交互式循环"><a href="#一个简单的交互式循环" class="headerlink" title="一个简单的交互式循环"></a>一个简单的交互式循环</h3><p>读取用户键盘输入数据的循环并打印每次读取的结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	reply = input(<span class="string">'Enter text:'</span>)</span><br><span class="line">	<span class="keyword">if</span> reply == <span class="string">'stop'</span>: <span class="keyword">break</span></span><br><span class="line">	print(reply.upper())</span><br></pre></td></tr></table></figure>

<p>从用户那里读取一行并用大写字母打印,直到输入<code>stop</code></p>
<blockquote>
<ul>
<li><p>这个程序利用了Python的while循环,它是Python最通用的循环语句</p>
<p>它的组成为: <code>while</code>关键字之后跟一个结果为<code>True</code>或<code>False</code>的表达式,再接一个当顶端测试为真时不停地迭代的嵌套代码块</p>
</li>
<li><p><code>input</code>内置函数用于通用控制台输出,它打印可选的参数字符串作为提示,并返回用户输入的回复字符</p>
</li>
<li><p>利用嵌套代码块特殊规则的单行if语句也在这里出现: <code>if</code><strong>语句体</strong>出现在<code>:</code>之后的首行,而并不是在首行的下一行缩进</p>
</li>
<li><p>Python的<code>break</code>语句用于立即退出循环,也就是完全跳出循环语句而程序会继续循环之后的部分</p>
</li>
</ul>
</blockquote>
<p>源文件的结束或是一个缩进较少的语句能够终止这个循环体块</p>
<h3 id="对用户输入数据做数学运算"><a href="#对用户输入数据做数学运算" class="headerlink" title="对用户输入数据做数学运算"></a>对用户输入数据做数学运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	reply = input(<span class="string">'Enter text:'</span>)</span><br><span class="line">	<span class="keyword">if</span> reply == <span class="string">'stop'</span>: <span class="keyword">break</span></span><br><span class="line">	print(int(reply) ** <span class="number">2</span>)</span><br><span class="line">print(<span class="string">'Bye'</span>)</span><br></pre></td></tr></table></figure>

<p>除非表达式里的对象类型都是数字,否则Python不会在表达式中转换对象类型</p>
<p>用户的输入返回到脚本一定是一个字符串,只有手动转换为数字类型对象才能求幂</p>
<h3 id="用测试输入数据来处理错误"><a href="#用测试输入数据来处理错误" class="headerlink" title="用测试输入数据来处理错误"></a>用测试输入数据来处理错误</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	reply = input(<span class="string">'Enter text:'</span>)</span><br><span class="line">	<span class="keyword">if</span> reply == <span class="string">'stop'</span>: <span class="keyword">break</span></span><br><span class="line">	<span class="keyword">elif</span> <span class="keyword">not</span> reply.isdigit():</span><br><span class="line">		print(<span class="string">'Bad!'</span> * <span class="number">8</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		print(int(reply) ** <span class="number">2</span>)</span><br><span class="line">print(<span class="string">'Bye'</span>)</span><br></pre></td></tr></table></figure>

<p>当输入无效时内置<code>int</code>函数会返回<code>ValueError</code></p>
<p><code>isdigit</code>方法可以检查字符串的内容是否为数字</p>
<p><code>if</code>语句完整结构为:<code>if</code>关键字后接测试以及匹配的代码块,一个或多个可选的<code>elif</code>测试以及代码块,以及一个可选的<code>else</code>和匹配的代码块</p>
<p><code>if</code>、<code>elif</code>以及<code>else</code>属于<code>if</code>语句的一部分,因为它们垂直对齐</p>
<p>Python执行首次测试为真所匹配的代码块,当所有的测试都为假则执行<code>else</code>部分</p>
<h3 id="用try语句处理错误"><a href="#用try语句处理错误" class="headerlink" title="用try语句处理错误"></a>用try语句处理错误</h3><p><code>try</code>语句用来捕捉并处理错误</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	reply = input(<span class="string">'Enter text:'</span>)</span><br><span class="line">	<span class="keyword">if</span> reply == <span class="string">'stop'</span>: <span class="keyword">break</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		num = int(reply)</span><br><span class="line">	<span class="keyword">except</span>:</span><br><span class="line">		print(<span class="string">'Bad!'</span> * <span class="number">8</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		print(int(reply) ** <span class="number">2</span>)</span><br><span class="line">print(<span class="string">'Bye'</span>)</span><br></pre></td></tr></table></figure>

<p><code>try</code>语句组成:<code>try</code>关键字后接尝试运行的代码,<code>except</code>部分以及异常处理代码,<code>else</code>部分以及没有引发异常的处理代码</p>
<p><code>try</code>、<code>except</code>以及<code>else</code>属于<code>try</code>语句的一部分,因为它们全都缩进在同一层次</p>
<h3 id="嵌套代码三层"><a href="#嵌套代码三层" class="headerlink" title="嵌套代码三层"></a>嵌套代码三层</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	reply = input(<span class="string">'Enter text:'</span>)</span><br><span class="line">	<span class="keyword">if</span> reply == <span class="string">'stop'</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">elif</span> <span class="keyword">not</span> reply.isdigit():</span><br><span class="line">		print(<span class="string">'Bad!'</span> * <span class="number">8</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		num = int(reply)</span><br><span class="line">		<span class="keyword">if</span> num &lt; <span class="number">20</span>:</span><br><span class="line">			print(<span class="string">'low'</span>)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			print(num ** <span class="number">2</span>)</span><br><span class="line">print(<span class="string">'Bye'</span>)</span><br></pre></td></tr></table></figure>

<p>多层嵌套需要再往右缩进</p>
<hr>
<h2 id="本章习题"><a href="#本章习题" class="headerlink" title="本章习题"></a>本章习题</h2><ol>
<li><p>类C语言中需要哪三项在Python中省略了的语法成分</p>
<blockquote>
<p>类C语言需要在一些语句中的测试两侧使用圆括号,需要在每个语句末尾有分号,以及嵌套代码块周围有大括号</p>
</blockquote>
</li>
<li><p>Python中的语句一般是怎样终止的</p>
<blockquote>
<p>一行的结尾就是该行语句的终止</p>
<p>如果一个以上的语句出现在同行上,可以使用分号终止</p>
<p>如果一个语句跨过数行,可以用语法上的闭合括号终止这一行</p>
</blockquote>
</li>
<li><p>在Python中,嵌套代码块内的语句一般是如何关联在一起的</p>
<blockquote>
<p>嵌套代码块中的语句都得缩进相同数目的制表符或空格</p>
</blockquote>
</li>
<li><p>你怎么让一条语句跨过多行</p>
<blockquote>
<p>语句可以横跨多行,只要将其封闭在圆括号内、方括号内或大括号内即可</p>
<p>当Python遇到一行含有一对括号中的闭合括号,语句就会结束</p>
</blockquote>
</li>
<li><p>你怎么在单个行上编写复合语句</p>
<blockquote>
<p>复合语句的主体可以移到开头行的冒号后面,但前提是主体只由非复合语句构成</p>
</blockquote>
</li>
<li><p>有什么理由要在Python语句末尾输入分号呢</p>
<blockquote>
<p>只有当你需要把一列以上的语句挤进一行代码时</p>
<p>即使是这种情况下,也只有当所有语句都是非复合时,才行得通,此外因为这样会让程序代码难以阅读,所以不建议这么做</p>
</blockquote>
</li>
<li><p>try语句是用来做什么的</p>
<blockquote>
<p>try语句是用于在Python脚本中捕捉和恢复异常(错误)的</p>
<p>这通常是程序中自行检查错误的方法之一</p>
</blockquote>
</li>
<li><p>Python初学者最常犯的编写代码错误是什么</p>
<blockquote>
<p>忘记在复合语句开头行末尾输入冒号,是初学者最常犯的错误</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="第十一章-赋值、表达式和打印"><a href="#第十一章-赋值、表达式和打印" class="headerlink" title="第十一章 赋值、表达式和打印"></a>第十一章 赋值、表达式和打印</h1><blockquote>
<ul>
<li>这一章开始探索赋值语句、表达式预计打印,从而深入研究Python语句</li>
<li>学习这些语句一些可选的替代形式</li>
<li>研究变量名的语法、重定向技术以及各种要避免的常见错误</li>
</ul>
</blockquote>
<hr>
<h2 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h2><p>基本形式:<code>赋值目标 = 赋值对象</code>,赋值目标可以是变量或对象元素,赋值对象可以是任何可以计算得到的对象的表达式</p>
<p>赋值语句特性</p>
<blockquote>
<ul>
<li><p>赋值语句建立对象引用值</p>
<p>赋值语句会把对象引用值存储在变量名或数据结构的元素内</p>
</li>
<li><p>变量名在首次赋值时会被创建</p>
<p>Python会在首次将值赋值给变量时创建变量名</p>
<p>有些(并非全部)数据结构元素也会在赋值时创建(例如,字典中的元素,一些对象属性)</p>
<p>赋值后变量名出现在表达式时,会被其所引用的值取代</p>
</li>
<li><p>变量名在引用前必须先赋值</p>
<p>使用尚未进行赋值的变量名是一种错误,Python会引发异常,而不是返回某种模糊的默认值</p>
</li>
<li><p>执行隐式赋值的一些操作</p>
<p>在Python中，赋值语句会在许多情况下使用</p>
<p>除了<code>=</code>显式赋值语句,模块导人、函数和类的定义、for循环变量以及函数参数全都是隐式赋值运算,赋值语句的工作原理都相同,都是在运行时把变量名和对象的引用值绑定起来</p>
</li>
</ul>
</blockquote>
<h3 id="赋值语句的形式"><a href="#赋值语句的形式" class="headerlink" title="赋值语句的形式"></a>赋值语句的形式</h3><table>
<thead>
<tr>
<th>运算</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>spam = ‘Spam’</td>
<td>基本形式</td>
</tr>
<tr>
<td>spam, ham = ‘yum’, ‘YUM’</td>
<td>元组赋值运算(位置性)</td>
</tr>
<tr>
<td>[spam, ham] = [‘yum’, ‘YUM’]</td>
<td>列表赋值运算(位置性)</td>
</tr>
<tr>
<td>a, b, c, d = ‘spam’</td>
<td>序列赋值运算,通用性</td>
</tr>
<tr>
<td>a, *b = ‘spam’</td>
<td>拓展的序列解包</td>
</tr>
<tr>
<td>spam = ham = ‘lunch’</td>
<td>多目标赋值运算</td>
</tr>
<tr>
<td>spams += 42</td>
<td>增强赋值运算</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li><p>基本形式</p>
<p>把一个变量名(或数据结构元素)绑定到单个对象上</p>
</li>
<li><p>元组及列表分解赋值</p>
<p>当在<code>=</code>左边编写元组或列表时,Python会按照位置把右边的对象和左边的目标从左至右相配对</p>
<p>从内部实现上来看,Python会先在右边制作元素的元组,所以这通常被称为元组分解赋值语句</p>
<ul>
<li><p>序列赋值语句</p>
<p>元组和列表赋值语句统一为序列赋值语句的实例</p>
<p>任何变量名的<strong>序列</strong>都可赋值为任何值的<strong>序列,</strong>Python会按位置一次赋值一个元素</p>
</li>
</ul>
</li>
<li><p>拓展的序列解包</p>
<p><code>*</code>可以匹配序列的剩下部分</p>
</li>
<li><p>多重目标赋值</p>
<p>Python将最右边的对象的引用值赋值给左边所有目标</p>
</li>
<li><p>增强赋值语句</p>
<p>以简洁的方式结合表达式和赋值语句的简写形式</p>
<p>每个二元表达式运算符都有增强赋值语句</p>
</li>
</ul>
</blockquote>
<h3 id="序列赋值"><a href="#序列赋值" class="headerlink" title="序列赋值"></a>序列赋值</h3><p>语句执行时,Python会建立临时的元组来存储右侧变量原始的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nudge = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wink = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A, B = nudge,wink		<span class="comment"># Tuple assignment</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A, B					<span class="comment"># Like A = nudge;B = wink</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[C, D] = [nudge, wink]	<span class="comment"># List assignment</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C, D</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>Python把赋值运算符右侧元组内的值和左侧元组内的变量互相匹配,然后每一次赋一个值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nugge = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wink = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nudge, wink = wink, nudge	<span class="comment"># Tuples:swaps values</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nudge, wink					<span class="comment"># Like T = nudge;nudge = wink;wink = T</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>分解赋值语句不用自行创建临时变量就可以交换两变量的值,右侧的元组会自动记住先前的变量的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[a, b, c] = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)	<span class="comment"># Assign tuple of values to list of names</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(a, b, c) = <span class="string">"ABC"</span>		<span class="comment"># Assign string of characters to tuple</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, c</span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'C'</span>)</span><br></pre></td></tr></table></figure>

<p>Python中原始的元组和列表赋值语句已被通用化,只要长度相等,右侧可以接受任何<strong>可迭代对象</strong></p>
<p>通非常情况下Python会按位置由左至右把右侧序列中的元素赋值给左侧序列中的变量</p>
<h4 id="高级序列赋值语句模式"><a href="#高级序列赋值语句模式" class="headerlink" title="高级序列赋值语句模式"></a>高级序列赋值语句模式</h4><p>序列赋值语句<code>=</code>可以两侧混合相匹配的序列类型,但是右侧元素的数目需要和左侧变量的数目相同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = <span class="string">'SPAM'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c, d = string							<span class="comment"># Same number on both sides</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, d</span><br><span class="line">(<span class="string">'S'</span>, <span class="string">'M'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = string							<span class="comment"># Error if not</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: too many values to unpack (expected <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = string[<span class="number">0</span>], string[<span class="number">1</span>], string[<span class="number">2</span>:]	<span class="comment"># Index and slice</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="string">'S'</span>, <span class="string">'P'</span>, <span class="string">'AM'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = list(string[:<span class="number">2</span>]) + [string[:<span class="number">2</span>]]	<span class="comment"># Slice and concatenate</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="string">'S'</span>, <span class="string">'P'</span>, <span class="string">'SP'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = string[:<span class="number">2</span>]							<span class="comment"># Same,but simpler</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = string[<span class="number">2</span>:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="string">'S'</span>, <span class="string">'P'</span>, <span class="string">'AM'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(a, b), c = string[:<span class="number">2</span>], string[<span class="number">2</span>:]			<span class="comment"># Nested sequence</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="string">'S'</span>, <span class="string">'P'</span>, <span class="string">'AM'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>((a, b), c) = (<span class="string">'SP'</span>, <span class="string">'AM'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c										<span class="comment"># Paired by shape and position</span></span><br><span class="line">(<span class="string">'S'</span>, <span class="string">'P'</span>, <span class="string">'AM'</span>)</span><br></pre></td></tr></table></figure>

<p>赋值目标中的项数和主体的数目必须一致</p>
<p>可以使用分片使序列赋值语句更通用</p>
<p>赋值嵌套序列时,左侧对象的序列嵌套的形状必须符合右边对象的性质,Python为每一层嵌套赋值</p>
<blockquote>
<ul>
<li>赋值嵌套序列在<code>for</code>循环中将循环项赋值给循环头部给定的目标</li>
<li>赋值嵌套序列在Python 2.6中用于函数参数列表</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">red, green, blue = range(<span class="number">3</span>)</span><br><span class="line">red, blue</span><br><span class="line">(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>range(<span class="number">3</span>)		<span class="comment"># Use list(range(3)) in Python 3.0</span></span><br><span class="line">range(<span class="number">0</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>序列解包赋值语句赋值一系列整数给一组变量</p>
<p><code>range</code>函数产生连续整数列表</p>
<p>元组赋值语句在循环中将序列分割为开头和剩余两部分</p>
<h3 id="Python-3-0中的拓展序列解包"><a href="#Python-3-0中的拓展序列解包" class="headerlink" title="Python 3.0中的拓展序列解包"></a>Python 3.0中的拓展序列解包</h3><p><code>*</code>在赋值目标中使用来引用一个包含所有没有赋值给其他名称的项的序列</p>
<h4 id="扩展的解包的实际应用"><a href="#扩展的解包的实际应用" class="headerlink" title="扩展的解包的实际应用"></a>扩展的解包的实际应用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c, d = seq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a, b, c, d)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = seq</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: too many values to unpack (expected <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *b = seq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*a, b = seq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *b, c = seq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *c = seq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>序列赋值要求左边的目标名称数目有右边的主体中的项数完全一致,否则得到一个错误</p>
<p>当使用一个<code>*</code>的时候,左边的目标中的项数不需要与主体序列的长度匹配</p>
<p><code>*</code>可以出现在目标中的任何地方</p>
<blockquote>
<ul>
<li>出现在最前面时,匹配其他目标名称所匹配项的前边的项</li>
<li>出现在最后面时,匹配最后没有匹配的项</li>
<li>出现在中间时,收集其他目标名称所匹配项之间的所有向</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *b = <span class="string">'spam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">(<span class="string">'s'</span>, [<span class="string">'p'</span>, <span class="string">'a'</span>, <span class="string">'m'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *b, c = <span class="string">'spam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="string">'s'</span>, [<span class="string">'p'</span>, <span class="string">'a'</span>], <span class="string">'m'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>S = <span class="string">'spam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>S[<span class="number">0</span>], S[<span class="number">1</span>:]		<span class="comment"># Slices are type-specific,* assignment always returns a list</span></span><br><span class="line">(<span class="string">'s'</span>, <span class="string">'pam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>S[<span class="number">0</span>], S[<span class="number">1</span>:<span class="number">3</span>], S[<span class="number">3</span>]</span><br><span class="line">(<span class="string">'s'</span>, <span class="string">'pa'</span>, <span class="string">'m'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> L:</span><br><span class="line"><span class="meta">... </span>    front, *L = L</span><br><span class="line"><span class="meta">... </span>    print(front, L)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">1</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="number">2</span> [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="number">3</span> [<span class="number">4</span>]</span><br><span class="line"><span class="number">4</span> []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> L:</span><br><span class="line"><span class="meta">... </span>    front, L = L[<span class="number">0</span>], L[<span class="number">1</span>:]</span><br><span class="line"><span class="meta">... </span>    print(front, L)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">1</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="number">2</span> [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="number">3</span> [<span class="number">4</span>]</span><br><span class="line"><span class="number">4</span> []</span><br></pre></td></tr></table></figure>

<p>拓展的序列解包语法对于任何序列类型都有效</p>
<p>一个序列解包赋值总是返回多个匹配项的<strong>列表</strong>,分片把相同类型的一个序列作为分片的对象返回</p>
<h4 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c, *d = seq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a, b, c, d)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> [<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c, d, *e = seq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a, b, c, d, e)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *c, d, e = seq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a, b, c, d, e)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> [] <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><code>*</code>即使只匹配当项也会返回一个列表</p>
<p><code>*</code>如果没有剩下的内容可以匹配则返回一个空的列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *b, c, *d = seq</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">SyntaxError: two starred expressions <span class="keyword">in</span> assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = seq</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: too many values to unpack (expected <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*a = seq</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">SyntaxError: starred assignment target must be <span class="keyword">in</span> a list <span class="keyword">or</span> tuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*a, = seq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>引发错误情况</p>
<blockquote>
<ul>
<li>有多个<code>*</code></li>
<li>值少了而没有<code>*</code></li>
<li><code>*</code>自身没有编写到一个列表中</li>
</ul>
</blockquote>
<h4 id="一个有用的便利形式"><a href="#一个有用的便利形式" class="headerlink" title="一个有用的便利形式"></a>一个有用的便利形式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *b = seq					<span class="comment"># First,rest</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">(<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = seq[<span class="number">0</span>], seq[<span class="number">1</span>:]		<span class="comment"># First,rest:traditional</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">(<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*a, b = seq					<span class="comment"># Rest,last</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = seq[:<span class="number">-1</span>], seq[<span class="number">-1</span>]	<span class="comment"># Rest,last:traditional</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>拓展的解包相比较索引和分片更容易编写</p>
<h4 id="应用于for循环"><a href="#应用于for循环" class="headerlink" title="应用于for循环"></a>应用于for循环</h4><p>拓展的序列赋值对于<code>for</code>循环语句中的循环变量有效</p>
<p>每次迭代中,Python直接把下一个值的元组分配给目标名称的元组</p>
<h3 id="多目标赋值语句"><a href="#多目标赋值语句" class="headerlink" title="多目标赋值语句"></a>多目标赋值语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = b = c = <span class="string">'spam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="string">'spam'</span>, <span class="string">'spam'</span>, <span class="string">'spam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="string">'spam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = c</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = b</span><br></pre></td></tr></table></figure>

<p>多目标赋值语句就是把所有提供的变量名都赋值为最右侧的对象的引用</p>
<h4 id="多目标赋值以及共享引用"><a href="#多目标赋值以及共享引用" class="headerlink" title="多目标赋值以及共享引用"></a>多目标赋值以及共享引用</h4><p>多目标赋值的多个变量共享一个被赋值对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = b = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = b + <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = b = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.append(<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">([<span class="number">42</span>], [<span class="number">42</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.append(<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">([], [<span class="number">42</span>])</span><br></pre></td></tr></table></figure>

<p>对于不可变类型,共享引用不会出现问题,由于不支持原处修改.对于其中一个变量的修改只会改变当前变量的引用</p>
<p>对于可变类型,当在原处修改其中一个变量时也会修改其他引用的变量</p>
<p>为避免共享引用的问题应避免使用多目标赋值语句</p>
<h3 id="增强赋值语句"><a href="#增强赋值语句" class="headerlink" title="增强赋值语句"></a>增强赋值语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = x + <span class="number">1</span>		<span class="comment"># Traditional</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x += <span class="number">1</span>			<span class="comment"># Augmented</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>S = <span class="string">"spam"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>S += <span class="string">"SPAM"</span>		<span class="comment"># Implied concatenation</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>S</span><br><span class="line"><span class="string">'spamSPAM'</span></span><br></pre></td></tr></table></figure>

<p>增强赋值语句适用于任何支持隐式二元表达式的类型</p>
<table>
<thead>
<tr>
<th>增强赋值语句</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>X += Y</td>
<td>X &amp;= Y</td>
<td>X -= Y</td>
<td>X |= Y</td>
</tr>
<tr>
<td>X *= Y</td>
<td>X ^= Y</td>
<td>X /= Y</td>
<td>X &gt;&gt;= Y</td>
</tr>
<tr>
<td>X %= Y</td>
<td>X &lt;&lt;= Y</td>
<td>X **= Y</td>
<td>X //= Y</td>
</tr>
</tbody></table>
<p>增强赋值语句优点</p>
<blockquote>
<ul>
<li><p>程序员输入减少</p>
</li>
<li><p>左侧只需计算一次</p>
<p>在<code>X+=Y</code>中,X可以是复杂的对象表达式,在增强形式中,则只需计算一次,在完整形式<code>X = X + Y</code>中,X出现两次,必须执行两次,因此,增强赋值语句通常执行得更快。</p>
</li>
<li><p>优化技术会自动选择</p>
<p>对于支持原处修改的对象而言,增强形式会自动执行原处的修改运算,而不是相比来说速度更慢的复制</p>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = L + [<span class="number">3</span>]			<span class="comment"># COncatenate:slower</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L.append(<span class="number">4</span>)			<span class="comment"># Faster,but in-place</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = L + [<span class="number">5</span>, <span class="number">6</span>]		<span class="comment"># Concatenate:slower</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L.extend([<span class="number">7</span>, <span class="number">8</span>])	<span class="comment"># Faster,but in-place</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L += [<span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p>在两种情况下,合并对共享对象引用产生的副作用可能会更小,但是,通常会比对等的原处形式运行得更慢</p>
<blockquote>
<ul>
<li>合并操作必须创建一个新的对象,把左侧的复制到列表中,然后再把右侧的复制到列表中</li>
<li>原处方法调用直接在一个内存块末尾添加项</li>
</ul>
</blockquote>
<p>使用增强赋值语句拓展列表时,Python会自动调用较快的<code>extend</code>方法而不是<code>+</code>运算</p>
<h4 id="增强赋值以及共享引用"><a href="#增强赋值以及共享引用" class="headerlink" title="增强赋值以及共享引用"></a>增强赋值以及共享引用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M = L				<span class="comment"># L and M reference the same object</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = L + [<span class="number">3</span>, <span class="number">4</span>]		<span class="comment"># ConcatenatIon makes a new object</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L, M				<span class="comment"># Changes L but not M</span></span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M = L</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L += [<span class="number">3</span>, <span class="number">4</span>]			<span class="comment"># But += really means extend</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L, M				<span class="comment"># M sees the in-place change too!</span></span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<p>对于支持原处修改的对象而言,<code>+=</code>增强形式会自动执行原处的修改运算,而不像 <code>+</code>生成新的对象</p>
<h3 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h3><h4 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h4><blockquote>
<ul>
<li><p>语法:(下划线或字母) + (任意数目的字母、数字或下划线)</p>
</li>
<li><p>区分大小写</p>
</li>
<li><p>禁止使用保留字</p>
<p>定义的变量名不能和Python语言中有特殊意义的名称相同</p>
</li>
</ul>
</blockquote>
<h4 id="Python-3-0中的保留字"><a href="#Python-3-0中的保留字" class="headerlink" title="Python 3.0中的保留字"></a>Python 3.0中的保留字</h4><table>
<thead>
<tr>
<th>保留字</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>False</td>
<td>class</td>
<td>finally</td>
<td>is</td>
<td>return</td>
</tr>
<tr>
<td>None</td>
<td>continue</td>
<td>for</td>
<td>lambda</td>
<td>try</td>
</tr>
<tr>
<td>True</td>
<td>def</td>
<td>from</td>
<td>nonlocal</td>
<td>while</td>
</tr>
<tr>
<td>and</td>
<td>del</td>
<td>global</td>
<td>not</td>
<td>with</td>
</tr>
<tr>
<td>as</td>
<td>elif</td>
<td>if</td>
<td>or</td>
<td>yield</td>
</tr>
<tr>
<td>assert</td>
<td>else</td>
<td>import</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>break</td>
<td>except</td>
<td>in</td>
<td>raise</td>
<td></td>
</tr>
</tbody></table>
<p>Python保留字大多数小写,无法对其进行赋值运算</p>
<p><code>True</code>、<code>Flase</code>和<code>None</code>是大小写混合,除了作为保留字,还可以作为分配给对象的值</p>
<p><code>import</code>语句无法导入模块名为保留字的模块</p>
<h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><p>解释器的命名惯例并非必要的规则,但一般在实际中都会遵守</p>
<blockquote>
<ul>
<li>以单一下划线开头的变量名<code>_X</code>不会被<code>from module import *</code>语句导入</li>
<li>前后有下划线的变量名<code>_X_</code>是系统定义的变量名,对解释器有特殊意义</li>
<li>以两下划线开头、但结尾没有两个下划线的变量名<code>__X</code>是类的本地(“压缩”)变量</li>
<li>通过交互模式运行时,只有单个下划线的变量名(_)会保存最后表达式的结果</li>
</ul>
</blockquote>
<p>程序员遵循的其他管理</p>
<blockquote>
<ul>
<li>类变量名以一个大写字母开头</li>
<li>模块变量名以小写字母开头</li>
<li><code>self</code>在类中一般有特殊的角色</li>
</ul>
</blockquote>
<h4 id="变量名没有类型-但对象有"><a href="#变量名没有类型-但对象有" class="headerlink" title="变量名没有类型,但对象有"></a>变量名没有类型,但对象有</h4><ul>
<li>对象有类型(例如,整数或列表),并且可能是可变的活不可变的</li>
<li>变量名只是对象的引用值,没有不可变的概念,也没有相关联的类型信息</li>
</ul>
<h3 id="Python的废弃协议"><a href="#Python的废弃协议" class="headerlink" title="Python的废弃协议"></a>Python的废弃协议</h3><p>保留字在一种语言的各个阶段是变化的,当一种新的功能可能会影响到已有的代码的时候,Python通常会使其成为可选的,并且将其发布为<code>废弃的,</code>以便在正式使用该功能之前的一个或多个发布中提出警告</p>
<hr>
<h2 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h2><p>Python中可以使用表达式作为语句(本身占一行),但是无法保存</p>
<p>只有当表达式工作并作为附加的效果表达式语句才有意义</p>
<blockquote>
<ul>
<li><p>调用函数和方法</p>
<p>有些函数和方法会做很多工作,而不会有返回值因,所以可以用表达式语句调用这些函数</p>
</li>
<li><p>在交互模式提示符下打印值</p>
<p>Python会在交互模式命令行中响应输人的表达式的结果,作为输入print语句的简写方法</p>
</li>
</ul>
</blockquote>
<p>常见Python表达式语句</p>
<table>
<thead>
<tr>
<th>运算</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>spam(eggs, ham)</td>
<td>函数调用</td>
</tr>
<tr>
<td>spam.pam(eggs)</td>
<td>方法调用</td>
</tr>
<tr>
<td>spam</td>
<td>在交互模式下解释器内打印变量</td>
</tr>
<tr>
<td>print(a, b, c, sep=’’)</td>
<td>Python 3.0中的打印操作</td>
</tr>
<tr>
<td>yield x ** 2</td>
<td>产生表达式的语句</td>
</tr>
</tbody></table>
<p>函数和方法的调用卸载函数/方法变量名后的括号内,具有零或多个参数的对象(计算对象的表达式)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = print(<span class="string">'spam'</span>)	<span class="comment"># print is a function call expression in 3.0</span></span><br><span class="line">spam</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(x)			<span class="comment"># But it is coded as an expression statement</span></span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>没有返回值的函数默认返回<code>None</code></p>
<p>Python中表达式可作为语句出现,但语句不能用作表达式,例如,赋值语句<code>=</code>不允许嵌入到表达式所以不会出现将<code>==</code>达成<code>=</code>而意外修改变量的值</p>
<h3 id="表达式语句和在原处的修改"><a href="#表达式语句和在原处的修改" class="headerlink" title="表达式语句和在原处的修改"></a>表达式语句和在原处的修改</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L.append(<span class="number">3</span>)			<span class="comment"># Append is an in-place change</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = L.append(<span class="number">4</span>)		<span class="comment"># BuT append returns None,not L </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(L)			<span class="comment"># So we lose our list</span></span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>当把可于原处修改的对象的方法重新赋值时会返回<code>None</code></p>
<hr>
<h2 id="打印操作"><a href="#打印操作" class="headerlink" title="打印操作"></a>打印操作</h2><p><code>print</code>语句可以实现把一个或多个对象转换为其文本表达形式,打印到标准输出流或另一个类似文件的流</p>
<blockquote>
<ul>
<li><p>文件对象方法</p>
<p>文件写入方法是把字符串写入到任意的文件</p>
<p><code>print</code>默认地把对象打印到<code>stdout</code>流,添加了一些自动的格式化</p>
<p>和文件方法不同,在使用打印操作的时候,不需要把对象转换为字符串</p>
</li>
<li><p>标准输出流</p>
<p>标准输出流(<code>stdout</code>)是发送一个程序的文本输出的默认的地方,加上标准输入流和错误流,它是脚本启动时所创建的3种数据连接中的一种</p>
<p>标准输出流通常映射到启动Python程序的窗口,除非它已经在操作系统的shell中重定向到一个文件或管道</p>
</li>
<li><p>由于标谁输出流在Python中可以作为内置的<code>sys</code>模块中的stdout文件对象使用(例如,<code>sys .stdout</code>),用文件的写入方法调用来模拟<code>print</code>成为可能,然而,print很容易使用,这使得很容易就能把文本打印到其他文件或流</p>
</li>
</ul>
</blockquote>
<p>Python 3.0和Python 2.6的差异</p>
<blockquote>
<ul>
<li>在Python 3.X中,打印是一个内置函数,用关键字参数来表示特定模式</li>
<li>在Python 2.X中,打印是语句,拥有自己的特定语法</li>
</ul>
</blockquote>
<h3 id="Python-3-0的print函数"><a href="#Python-3-0的print函数" class="headerlink" title="Python 3.0的print函数"></a>Python 3.0的print函数</h3><p><code>print</code>函数属于表达式语句</p>
<p><code>print</code>函数使用标准的函数调用语法,返回<code>None</code></p>
<h4 id="调用格式"><a href="#调用格式" class="headerlink" title="调用格式"></a>调用格式</h4><p><code>print(\[object,...]\[, sep=&#39; &#39;]\[, end=&#39;\n&#39;][, file=sys.stdout])</code></p>
<p>方括号中的项是可选的,<code>=</code>后面的值为参数默认值,必须使用<code>name=value</code>语法来根据名称而不是位置传递参数</p>
<p>参数</p>
<blockquote>
<ul>
<li><p>要打印的每个对象的文本表示,通过把该对象传递给<code>str</code>函数调用获得</p>
</li>
<li><p><code>sep</code>是在每个对象的文本之间插入的一个字符串,它默认是一个单个的空格</p>
<p>传递一个空字符串将会抑制分隔符</p>
</li>
<li><p><code>end</code>是添加在打印文本末尾的一个字符串,它默认是一个<code>\n</code></p>
<p>传递一个空字符串将会避免在打印的文本的末尾移动到下一个输入行</p>
</li>
<li><p><code>file</code>指定了文本将要发送到的文件、标谁流或者其他类似文件的对象,它默认的是sys.stdout</p>
<p>带有类似文件的<code>write(string)</code>方法的任何对象都可以传递,真正的文件应该已经打开</p>
</li>
</ul>
</blockquote>
<h4 id="Python-3-0的print函数的应用"><a href="#Python-3-0的print函数的应用" class="headerlink" title="Python 3.0的print函数的应用"></a>Python 3.0的print函数的应用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print()													<span class="comment"># Display a blank line</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">'spam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">99</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = [<span class="string">'eggs'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(x, y, z)											<span class="comment"># Print 3 objects per defaults</span></span><br><span class="line">spam <span class="number">99</span> [<span class="string">'eggs'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(x, y, z, sep=<span class="string">''</span>)									<span class="comment"># Suppress separator</span></span><br><span class="line">spam99[<span class="string">'eggs'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(x, y, z, sep=<span class="string">', '</span>)								<span class="comment"># Custon separator</span></span><br><span class="line">spam, <span class="number">99</span>, [<span class="string">'eggs'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(x, y, z, end=<span class="string">''</span>)									<span class="comment"># Suppress line break</span></span><br><span class="line">spam <span class="number">99</span> [<span class="string">'eggs'</span>]&gt;&gt;&gt; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(x, y, z, end=<span class="string">''</span>); print(x, y, z)					<span class="comment"># Two prints,same output line</span></span><br><span class="line">spam <span class="number">99</span> [<span class="string">'eggs'</span>]spam <span class="number">99</span> [<span class="string">'eggs'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(x, y, z, end=<span class="string">'...\n'</span>)								<span class="comment"># Custom line end</span></span><br><span class="line">spam <span class="number">99</span> [<span class="string">'eggs'</span>]...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(x, y, z, sep=<span class="string">'...'</span>, file=open(<span class="string">'data.txt'</span>, <span class="string">'w'</span>))	<span class="comment"># Point to a file</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(x, y, z)											<span class="comment"># Back to stdout</span></span><br><span class="line">spam <span class="number">99</span> [<span class="string">'eggs'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(open(<span class="string">'data.txt'</span>).read())							<span class="comment"># Display file text</span></span><br><span class="line">spam..<span class="number">.99</span>...[<span class="string">'eggs'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(x, y, z, sep=<span class="string">'...'</span>, end=<span class="string">'!\n'</span>)					<span class="comment"># Multiple keywords</span></span><br><span class="line">spam..<span class="number">.99</span>...[<span class="string">'eggs'</span>]!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(x, y, z, end=<span class="string">'!\n'</span>, sep=<span class="string">'...'</span>)					<span class="comment"># Order doesn't matter</span></span><br><span class="line">spam..<span class="number">.99</span>...[<span class="string">'eggs'</span>]!</span><br></pre></td></tr></table></figure>

<p><code>print</code>函数不需要把待打印对象转换为字符串</p>
<p>默认情况下,<code>print</code>调用在打印的对象之间添加一个空格,要取消这个空格,给<code>sep</code>关键字参数传入一个空字符串,或者传入一个自己所选择的替代分隔符</p>
<p>默认情况下,<code>print</code>添加一个行末字符来结束输出行,可以通过向<code>end</code>关键字参数传入一个空字符串来抑制这一点并避免换行,或者可以传入一个自己的不同的终止符(包含一个\n符号来手动地换行)</p>
<p><code>file</code>直接把文本打印到一个输出文件或者其他的可兼容对象</p>
<p>可以组合关键字参数来指定分隔符和行末字符串,它们可以以任何顺序出现, 但是必须出现在所有要打印的对象的后面</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">'%s: %-.4f, %05d'</span> % (<span class="string">'Result'</span>, <span class="number">3.14159</span>, <span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(text)</span><br><span class="line">Result: <span class="number">3.1416</span>, <span class="number">00042</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%s: %-.4f, %05d'</span> % (<span class="string">'Result'</span>, <span class="number">3.14159</span>, <span class="number">42</span>))</span><br><span class="line">Result: <span class="number">3.1416</span>, <span class="number">00042</span></span><br></pre></td></tr></table></figure>

<p>可以提前构造格式化字符串或在<code>print()</code>函数中使用字符串工具打印格式化字符串</p>
<h3 id="Python-2-6print语句"><a href="#Python-2-6print语句" class="headerlink" title="Python 2.6print语句"></a>Python 2.6print语句</h3><p>Python 2.6中的打印使用具有独特和具体的语法的一条语句</p>
<h4 id="语句形式"><a href="#语句形式" class="headerlink" title="语句形式"></a>语句形式</h4><table>
<thead>
<tr>
<th>Python 2.6语句</th>
<th>Python 3.0对等形式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>print x, y</td>
<td>print(x ,y)</td>
<td>把对象的文本形式打印到<code>sys.stdout</code>,并且在各项之间添加一个空格,在末尾添加一个换行</td>
</tr>
<tr>
<td>pirnt x, y,</td>
<td>print(x, y, end=’’)</td>
<td>不会在文本末尾添加换行</td>
</tr>
<tr>
<td>print &gt;&gt; afile, x, y</td>
<td>print(x, y, file=afile)</td>
<td>把文本发送到<code>myfile.write</code>而不是<code>sys.stdout.write</code></td>
</tr>
</tbody></table>
<h4 id="Python-2-6-print语句应用"><a href="#Python-2-6-print语句应用" class="headerlink" title="Python 2.6 print语句应用"></a>Python 2.6 print语句应用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="string">'b'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> x, y</span><br><span class="line">a </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> x, y,;<span class="keyword">print</span> x, y</span><br><span class="line">a b a b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> x + y</span><br><span class="line">ab</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">'%s...%s'</span> % (x, y)</span><br><span class="line">a...b</span><br></pre></td></tr></table></figure>

<p>默认情况下,Python 2.6 <code>print</code>语句在逗号分隔的项之间添加空格,并且在当前输出行的末尾添加一个换行</p>
<p>省略换行字符需要在<code>print</code>语句后添加一个<code>,</code></p>
<p>取消各项之间的空格使用字符串合并工具</p>
<p>可以使用字符串格式化工具构建一个输出字符串</p>
<h3 id="打印流重定向"><a href="#打印流重定向" class="headerlink" title="打印流重定向"></a>打印流重定向</h3><p>打印默认发送到标准输出流</p>
<p>可以在脚本中重定向一个脚本的<strong>流</strong></p>
<h4 id="Python的”Hello-World”程序"><a href="#Python的”Hello-World”程序" class="headerlink" title="Python的”Hello World”程序"></a>Python的”Hello World”程序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'hello world'</span>)	<span class="comment"># Print a string object in 3.0 </span></span><br><span class="line">hello world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">'hello world'</span>		<span class="comment"># Print a string object in 2.6</span></span><br><span class="line">hello world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'hello world'</span>			<span class="comment"># Interactive echoes</span></span><br><span class="line"><span class="string">'hello world'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span>	sys				<span class="comment"># Printint the hard way</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.write(<span class="string">'hello world\n'</span>)</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p><code>print</code>语句提供了<code>sys.stdout</code>对象的简单接口,并加入了默认的格式设置</p>
<h4 id="重定向输出流"><a href="#重定向输出流" class="headerlink" title="重定向输出流"></a>重定向输出流</h4><p>重设<code>sys.stdout</code>到目标文件可以使基于print的程序重定向</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(X, Y)		<span class="comment"># Or,in 2.6:print X, Y</span></span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.stdout.write(str(X) + <span class="string">' '</span> + str(Y) + <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>

<p><code>sys.stdout</code>通过<code>str</code>执行字符串转换,通过<code>+</code>增加一个分隔符和一个换行,调用<code>write</code>方法输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout = open(<span class="string">'log.txt'</span>, <span class="string">'a'</span>)	<span class="comment"># Redirects prints to a file</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(x, y, x)						<span class="comment"># Shows up in log.txt</span></span><br></pre></td></tr></table></figure>

<p><code>print</code>函数可以把<code>sys.stdout</code>重新赋值给标准输出流以外的东西</p>
<p>把<code>sys.stdout</code>重设成已打开的文件对象( 采用附加模式<code>a</code>)后,程序中任何地方的<code>print</code>语句都会将文字写至重定向文件的末尾,而不是原始的输出流</p>
<blockquote>
<ul>
<li><code>print</code>语句将会持续地调用<code>sys.stdout</code>的<code>write</code>方法,无论<code>sys.stdout</code>当时引用的是什么</li>
<li>可以将<code>sys.stdout</code>重设为费文件的对象,只要该对象有预期的协议(<code>write</code>方法)</li>
</ul>
</blockquote>
<h4 id="自动化流重定向"><a href="#自动化流重定向" class="headerlink" title="自动化流重定向"></a>自动化流重定向</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp = sys.stdout					<span class="comment"># Save for restoring later</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout = open(<span class="string">'log.txt'</span>, <span class="string">'a'</span>)	<span class="comment"># Redirect prints to a file</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'spam'</span>)						<span class="comment"># Prints go to file,not here</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.close()					<span class="comment"># Flush output to disk</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout = temp					<span class="comment"># Restore original stream</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'back here'</span>)					<span class="comment"># Prints show up here again</span></span><br><span class="line">back here</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(open(<span class="string">'log.txt'</span>).read())		<span class="comment"># Result of earlier prints</span></span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>)</span><br><span class="line">spam</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><code>sys.stdout</code>是普通的文件对象,可以存储它,需要时恢复它</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>log = open(<span class="string">'log.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, file=log)		<span class="comment"># 2.6:print&gt;&gt;log,1,2,3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, file=log)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>log.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)					<span class="comment"># 2.6:print 7,8,9</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(open(<span class="string">'log.txt'</span>).read())</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><code>file</code>关键字允许一个单个的<code>print</code>调用将其文本发送给一个文件的<code>write</code>方法,而不是重设<code>sys.stdout</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stderr.write((<span class="string">'Bad!'</span> * <span class="number">8</span>) + <span class="string">'\n'</span>)</span><br><span class="line">Bad!Bad!Bad!Bad!Bad!Bad!Bad!Bad!</span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'Bad!'</span> * <span class="number">8</span>, file=sys.stderr)</span><br><span class="line">Bad!Bad!Bad!Bad!Bad!Bad!Bad!Bad!</span><br></pre></td></tr></table></figure>

<p><code>file</code>关键字可以用于把错误消息打印到标准错误流</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = <span class="number">1</span>; Y = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(X, Y)												<span class="comment"># Print:the easy way</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys												<span class="comment"># Print:the hard way</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.write(str(X) + <span class="string">' '</span> + str(Y) + <span class="string">'\n'</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(X, Y, file=open(<span class="string">'temp1'</span>, <span class="string">'w'</span>))					<span class="comment"># Redirect text to file</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>open(<span class="string">'temp2'</span>, <span class="string">'w'</span>).write(str(X) + <span class="string">' '</span> + str(Y) + <span class="string">'\n'</span>)	<span class="comment"># Send to file manually</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(open(<span class="string">'temp1'</span>, <span class="string">'rb'</span>).read())						<span class="comment"># Binary mode for bytes</span></span><br><span class="line"><span class="string">b'1 2\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(open(<span class="string">'temp2'</span>, <span class="string">'rb'</span>).read())</span><br><span class="line"><span class="string">b'1 2\n'</span></span><br></pre></td></tr></table></figure>

<p><code>print</code>操作通常是显示文本的最佳选择</p>
<h3 id="版本独立的打印"><a href="#版本独立的打印" class="headerlink" title="版本独立的打印"></a>版本独立的打印</h3><p>可以使用Python 3.0的2to3转换脚本自动将Python 2.6的<code>print</code>语句转换为Python 3.0函数调用</p>
<p>可以在Python 2.6代码中添加<code>from __future__ import print_function</code>支持<code>print</code>函数调用的变体</p>
<p>可以在Python 2.6中添加外围括号作为Python 3.0的<code>print</code>函数,但是打印多个值会产生一个元组对象</p>
<p>可以使用格式化表达式或方法调用返回一个字符串对象</p>
<h3 id="为什么要注意print和stdout"><a href="#为什么要注意print和stdout" class="headerlink" title="为什么要注意print和stdout"></a>为什么要注意print和stdout</h3><p><code>print</code>语句和<code>sys.stdout</code>之同的等效使得可以把<code>sys.stdout</code>重新赋值为用户定义的对象(提供和文件相同的方法,就像write),因为<code>print</code>语句只是传送文本给<code>sys.stdout.write</code>方法,可以把<code>sys.stdout</code>赋值为一个对象,而由该对象的<code>write</code>方法可以任意处理方式,可以通过这个对象捕捉程序中打印的文本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileFaker</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, string)</span>:</span></span><br><span class="line">		<span class="comment"># Do something with printed text in string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.stdout = FileFaker()</span><br><span class="line">print(someObjects) 	<span class="comment"># Sends to class weite method</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="本章习题-1"><a href="#本章习题-1" class="headerlink" title="本章习题"></a>本章习题</h2><ol>
<li><p>举出三种可以把三个变量赋值成相同值的方式</p>
<blockquote>
<p>你可以使用多重目标赋值语句<code>A=B=C=0</code>、序列赋值语句<code>A,B,C=0,0,0</code>或者单独行上的多重赋值语句<code>A=0,B=0,C=0</code></p>
<p>就后者的技术而言,就像第10章介绍过的,你也可以把三个单独的语句用分号合并在同一行上<code>A=0;B=0;C=0</code></p>
</blockquote>
</li>
<li><p>将三个变量赋值给可变对象时,可能需要注意什么</p>
<blockquote>
<p>如果你用这种方式赋值:</p>
<p><code>A=B=C=[]</code><br>这三个变量名都会引用相同对象,所以对其中一个变量名进行在原处的修改也会影响其他变量名</p>
<p>只有对列表或字典这类可变对象进行在原处的修改时,才会如此</p>
<p>对不可变对象而言,诸如数字和字符串,则不涉及此问题</p>
</blockquote>
</li>
<li><p>L = L.sort()有什么错误</p>
<blockquote>
<p>列表sort方法就像append方法,也是对主体列表进行在原处的修改:返回<code>None</code>,而不是其修改的列表</p>
<p>赋值给L,会把L设为None,而不是排序后的列表</p>
<p>内建函数<code>sorted</code>会排序任何序列,并传回具有排序结果的新列表因为这并不是在原处的修改,可以将其结果赋值给变量名</p>
</blockquote>
</li>
<li><p>怎么使用print语句来向外部文件发送文本</p>
<blockquote>
<p>要把一个单个的打印操作打印到一个文件,可以使用Python 3.0的<code>print(X,file=F)</code>调用形式</p>
<p>或者在打印前把sys.stdout指定为手动打开的文件并在之后恢复最初的值</p>
<p>你也可以用系统shell的特殊语法,把程序所有的打印文字重定向到一个文件,但这是在Python的范围之外的内容</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="第十二章-if测试和语法规则"><a href="#第十二章-if测试和语法规则" class="headerlink" title="第十二章 if测试和语法规则"></a>第十二章 if测试和语法规则</h1><blockquote>
<ul>
<li>本章介绍Python的if语句,也就是根据测试结果,从一些备选的操作中进行选择的主要语句</li>
<li>复习Python的一般语法规则</li>
<li>深人地探索真值测试运算</li>
<li>还会学习如何在Python中编写多路分支以及<code>if/else</code>表达式</li>
</ul>
</blockquote>
<hr>
<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p><code>if</code>语句是选取要执行的操作的语句</p>
<p><code>if</code>语句是复合语句,可以包含其他语句,包括其他<code>if</code>语句在内</p>
<h3 id="通用格式"><a href="#通用格式" class="headerlink" title="通用格式"></a>通用格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;test1&gt;:			<span class="comment"># if test</span></span><br><span class="line">    &lt;statements1&gt;	<span class="comment"># Associated block</span></span><br><span class="line"><span class="keyword">elif</span> &lt;test2&gt;:		<span class="comment"># Optional elifs</span></span><br><span class="line">    &lt;statements2&gt;</span><br><span class="line"><span class="keyword">else</span>:				<span class="comment"># Optional else</span></span><br><span class="line">    &lt;statement3&gt;</span><br></pre></td></tr></table></figure>

<p>形式为<code>if</code>测试,后面跟着一个或多个<strong>可选的</strong><code>elif</code>测试,以及一个最终<strong>可选的</strong><code>else</code>块</p>
<p>所有测试部分和<code>else</code>部分都有一个相关的嵌套语句块,缩进在首行下面</p>
<p><code>if</code>语句执行时,Python会测试第一个计算结果为真的代码块,所有测试都为假时执行<code>else</code>块</p>
<h3 id="基本例子"><a href="#基本例子" class="headerlink" title="基本例子"></a>基本例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'true'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">true</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="keyword">not</span> <span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'true'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'false'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p><code>if</code>语句除了<code>if</code>测试及其相关联的语句外,其他部分都是可选的</p>
<p><code>1</code>是布尔真值,测试会永远成功,处理假值结果则可用<code>not</code></p>
<h3 id="多路分支"><a href="#多路分支" class="headerlink" title="多路分支"></a>多路分支</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">'killer rabbit'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> x ==<span class="string">'roger'</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"how's jessica?"</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">elif</span> x == <span class="string">'bugs'</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"what's up doc&gt;"</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Run away!Run away!'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Run away!Run away!</span><br></pre></td></tr></table></figure>

<p>Python会执行第一次测试为真的语句下面的嵌套语句,如果所有测试都为假时,就执行<code>else</code>部分</p>
<p>每一个代码段中都可以嵌套一个以上的语句</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>choice = <span class="string">'ham'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(&#123;<span class="string">'spam'</span>: <span class="number">1.25</span>,		<span class="comment"># A dictionary-based 'switch'</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">'ham'</span>: <span class="number">1.99</span>,			<span class="comment"># Use has_key or get for default</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">'eggs'</span>: <span class="number">0.99</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="string">'bacon'</span>: <span class="number">1.10</span>&#125;[choice])</span><br><span class="line"><span class="number">1.99</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> choice == <span class="string">'spam'</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="number">1.25</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">elif</span> choice == <span class="string">'ham'</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="number">1.99</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">elif</span> choice == <span class="string">'eggs'</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="number">0.99</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">elif</span> choice == <span class="string">'bacon'</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="number">1.10</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Bad choice'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">1.99</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>branch = &#123;<span class="string">'spam'</span>: <span class="number">1.25</span>,</span><br><span class="line"><span class="meta">... </span>            <span class="string">'ham'</span>: <span class="number">1.99</span>,</span><br><span class="line"><span class="meta">... </span>            <span class="string">'eggs'</span>: <span class="number">0.99</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(branch.get(<span class="string">'spam'</span>, <span class="string">'Bad choice'</span>))</span><br><span class="line"><span class="number">1.25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(branch.get(<span class="string">'bacon'</span>, <span class="string">'Bad choice'</span>))</span><br><span class="line">Bad choice</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>choice = <span class="string">'bacon'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> choice <span class="keyword">in</span> branch:</span><br><span class="line"><span class="meta">... </span>    print(branch[choice])</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Bad choice'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Bad choice</span><br></pre></td></tr></table></figure>

<p>Python中没有<code>switch</code>和<code>case</code>语句,可以写成一系列<code>if/elif</code>测试或者对字典进行索引运算或搜索列表</p>
<p><code>if</code>语句的<code>else</code>分句按默认情况处理,字典默认值可以用<code>get</code>方法或<code>异常捕捉</code>,还可以用<code>if</code>语句的<code>in</code>成员测试</p>
<p>字典中可以包含函数来编写更复杂动作</p>
<p>字典和列表可在运行时创建,比硬编码的if语句更有灵活性</p>
<hr>
<h2 id="Python语法规则"><a href="#Python语法规则" class="headerlink" title="Python语法规则"></a>Python语法规则</h2><p>Python语法的特性</p>
<blockquote>
<ul>
<li><p>语句是逐个运行的,除非不这样编写</p>
<p>Python一般按照次序从头到尾执行文件中嵌套块中的语句</p>
<p><code>if</code>等语句会是的解释器在程序内跳跃,称为<code>控制流程语句</code></p>
</li>
<li><p>块和语句的边界会自动检测</p>
<p>Python使用首行下的语句缩进把嵌套块内的语句组合起来</p>
<p>Python语句一般不以分号终止,一行的末尾通常就是该行缩写语句的结尾</p>
</li>
<li><p>复合语句=首行 + <code>:</code> + 缩进语句</p>
<p>复合语句首行以冒号终止,再接一个或多个嵌套语句,且在首行下缩进</p>
<p>缩进语句叫做块</p>
</li>
<li><p>空白行、空格以及注释通常都会忽略</p>
<p>文件中空白行将忽略,但在交互模式提示符下不会</p>
<p>语句和表达式中的空格几乎都忽略(除了字符串常量中以及用在缩进时)</p>
<p>注释总是忽略,以<code>#</code>开头.延伸至该行的末尾</p>
</li>
<li><p>文档字符串会忽略,但会保存并由工具显示</p>
<p>文档字符串是一种注释,和<code>#</code>不同的是会在运行时保留下来</p>
<p>文档字符串是出现在程序文件和一些语句顶端的字符串,在运行时会自动附加在对象上,并能由文档工具显示</p>
</li>
</ul>
</blockquote>
<h3 id="代码块分隔符"><a href="#代码块分隔符" class="headerlink" title="代码块分隔符"></a>代码块分隔符</h3><p>Python自动以行缩进检测块的边界,缩进至右侧相同距离的所有语句属于同一块的代码</p>
<p>缩进是语法模型的一部分,而不是编程风格</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">	y = <span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> y:</span><br><span class="line">		print(<span class="string">'block2'</span>)</span><br><span class="line">	print(<span class="string">'block1'</span>)</span><br><span class="line">print(<span class="string">'block0'</span>)</span><br></pre></td></tr></table></figure>

<p>一个嵌套块以再往右缩进的语句开始,碰到缩进量较少的语句或文件末尾结束</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	x = <span class="string">'SPAM'</span>						<span class="comment"># Error:first line indented</span></span><br><span class="line">	<span class="keyword">if</span> <span class="string">'rubbery'</span> <span class="keyword">in</span> <span class="string">'shrubbery'</span>:</span><br><span class="line">		print(x * <span class="number">8</span>)</span><br><span class="line">			x += <span class="string">'NI'</span>				<span class="comment"># Error:unexpected indentation</span></span><br><span class="line">			<span class="keyword">if</span> x.endwith(<span class="string">'Ni'</span>):</span><br><span class="line">					x *=<span class="number">2</span></span><br><span class="line">				print(x)			<span class="comment"># Error:inconsistent indentation</span></span><br><span class="line">x = <span class="string">'SPAM'</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">'rubbery'</span> <span class="keyword">in</span> <span class="string">'shrubbery'</span>:</span><br><span class="line">	print(x * <span class="number">8</span>)</span><br><span class="line">	x += <span class="string">'NI'</span></span><br><span class="line">	<span class="keyword">if</span> x.endswith(<span class="string">'Ni'</span>):</span><br><span class="line">		x *=<span class="number">2</span></span><br><span class="line">		print(x)</span><br></pre></td></tr></table></figure>

<p>通常顶层代码必须于第一栏开始,嵌套块可以从任何栏开始</p>
<p>Python不在乎怎么缩进(空格或制表符)或者缩进多少(任意多个空格或是制表符),并且两个嵌套代码块的缩进可以完全不同,惯例使用4个空格或者一个制表符</p>
<p>Python只在乎缩进是否一致(数量一致,空格或制表符一致)</p>
<h4 id="避免混合使用制表符和空格-Python-3-0中心的错误检查"><a href="#避免混合使用制表符和空格-Python-3-0中心的错误检查" class="headerlink" title="避免混合使用制表符和空格:Python 3.0中心的错误检查"></a>避免混合使用制表符和空格:Python 3.0中心的错误检查</h4><p>一段代码块中可以使用空格或制表符来缩进,但是不能混合使用</p>
<h3 id="语句的分隔符"><a href="#语句的分隔符" class="headerlink" title="语句的分隔符"></a>语句的分隔符</h3><p>Python语句一般在其所在行的末尾结束</p>
<h4 id="一些特殊情况"><a href="#一些特殊情况" class="headerlink" title="一些特殊情况"></a>一些特殊情况</h4><p>当语句太长、难以单放在一行时,有些特殊规则可使其位于多行</p>
<blockquote>
<ul>
<li><p>如果使用语法括号对,语句就可以横跨数行</p>
<p>在封闭的<code>()</code>、<code>{}</code>或<code>[]</code>配对中写代码,可以在多行继续输入语句直到到括号</p>
<p>多行的语句可在任何缩进层次开始</p>
</li>
<li><p>如果语句以反斜线结束,就可横跨数行</p>
<p>在前一行的末尾加上<code>\</code>可以在下一行继续输入</p>
<p>可能会导致忘掉<code>\</code>产生语法错误,或下一行被看做新语句产生不可预期的结果</p>
</li>
<li><p>字符串常量有特殊规则</p>
<p>三重引号字符串块可以横跨数行</p>
<p>相邻的字符串常量是隐式地连接起来的,使用括号对可以横跨多行</p>
</li>
<li><p>其他规则</p>
<p>可以用分号终止语句把一个以上的简单语句挤进单个行中</p>
<p>注释和空白行也能出现在文件的任意处</p>
<p><code>#</code>注释可以出现在行的末尾</p>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">"Good"</span>,</span><br><span class="line">	<span class="string">"Bad"</span>,</span><br><span class="line">	<span class="string">"Ugly"</span>]		<span class="comment"># Open pairs may span lines</span></span><br></pre></td></tr></table></figure>

<p>可以把受界限限制的内容放在任意数目的行中</p>
<p>括号可以存放表达式、函数参数、函数的首行、元组和生成器表达式以及可以放到花括号中的任何内容(字典、集合常量、集合和字典解析)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a == b <span class="keyword">and</span> c == d <span class="keyword">and</span> \</span><br><span class="line">	d == e <span class="keyword">and</span> f == g:</span><br><span class="line">	print(<span class="string">'olde'</span>)	<span class="comment"># Backslashes allow continuations</span></span><br><span class="line"><span class="keyword">if</span> (a == b <span class="keyword">and</span> c == d <span class="keyword">and</span></span><br><span class="line">	d == e <span class="keyword">and</span> f == g):</span><br><span class="line">	print(<span class="string">'olde'</span>)	<span class="comment"># But parentheses usually do too</span></span><br><span class="line">x = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> \		<span class="comment"># Omitting the \ makes this very different</span></span><br><span class="line">	+ <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><code>\</code>可以在下一行继续,但是可以改为把语句包含在圆括号中</p>
<p>漏掉<code>\</code>可能会产生错误或不可预期的结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>; y = <span class="number">2</span>; print(x)</span><br></pre></td></tr></table></figure>

<p>Python允许使用<code>;</code>在相同行上编写一个以上的非复合语句,但可读性会下降</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="string">"""</span></span><br><span class="line"><span class="string">aaaa</span></span><br><span class="line"><span class="string">bbbb</span></span><br><span class="line"><span class="string">cccc"""</span></span><br><span class="line"></span><br><span class="line">S = (<span class="string">'aaaa'</span></span><br><span class="line">	<span class="string">'bbbb'</span>		<span class="comment"># Comments here are ignored</span></span><br><span class="line">	<span class="string">'cccc'</span>)</span><br></pre></td></tr></table></figure>

<p>三重引号字符串可以跨多行,和开放对规则一起使用时,相邻的字符串常量也可以横跨多行</p>
<p>在三重引号中添加注释不会被忽略,在相邻的字符串常量之间添加注释会忽略</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">1</span>: print(<span class="string">'hello'</span>)	<span class="comment"># Simple statement</span></span><br></pre></td></tr></table></figure>

<p>可以把复合语句主体上移到首行,只要该主体是简单语句</p>
<hr>
<h2 id="真值测试"><a href="#真值测试" class="headerlink" title="真值测试"></a>真值测试</h2><p>布尔运算符特性</p>
<blockquote>
<ul>
<li>任何非零数字或非空对象都为真</li>
<li>数字零、空对象以及特殊对象None都被认作是假</li>
<li>比较和相等测试会递归地应用在数据结构中</li>
<li>比较和相等测试会返回<code>True</code>或<code>False</code></li>
<li>布尔<code>and</code>和<code>or</code>运算符会返回真或假的操作对象</li>
</ul>
</blockquote>
<p>布尔表达式运算符</p>
<blockquote>
<ul>
<li><p><code>X and Y</code></p>
<p>如果X和Y都为真,就是真</p>
</li>
<li><p><code>X Or Y</code></p>
<p>如果X或Y为真,就是真</p>
</li>
<li><p><code>not X</code></p>
<p>如果X为假,就是真</p>
</li>
</ul>
</blockquote>
<p>X和Y为任何真值或者返回真值的表达式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> &lt; <span class="number">3</span>, <span class="number">3</span> &lt; <span class="number">2</span>	<span class="comment"># Less-than:return True or False</span></span><br><span class="line">(<span class="literal">True</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>比较会返回<code>True</code>或<code>False</code>作为结果`</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> <span class="keyword">or</span> <span class="number">3</span>, <span class="number">3</span> <span class="keyword">or</span> <span class="number">2</span>	<span class="comment"># Return left operand if true</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)				<span class="comment"># Else,return right operand(true or false)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[] <span class="keyword">or</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[] <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> <span class="keyword">and</span> <span class="number">3</span>, <span class="number">3</span> <span class="keyword">and</span> <span class="number">2</span>	<span class="comment"># Return left operand if flase</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>)					<span class="comment"># Else,return right operand(true or false)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[] <span class="keyword">and</span> &#123;&#125;</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">and</span> []</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<p><code>and</code>测试与<code>or</code>测试返回运算符两侧的对象而不是简单的<code>True</code>或`False</p>
<p><code>or</code>测试与<code>and</code>测试执行短路计算,即求出结果后就会使表达式其余部分短路(终止)</p>
<p><code>or</code>测试由左至右求算操作对象,在找到第一个真值操作对象的地方终止并返回操作对象,否则返回右侧操作对象</p>
<p><code>and</code>测试由左至右求算操作对象,在找到第一个假值操作对象的地方终止并返回操作对象,否则返回右侧操作对象</p>
<hr>
<h2 id="if-else三元表达式"><a href="#if-else三元表达式" class="headerlink" title="if/else三元表达式"></a>if/else三元表达式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> X:</span><br><span class="line">	A = Y</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	A = Z</span><br><span class="line">A = Y <span class="keyword">if</span> X <span class="keyword">else</span> Z</span><br><span class="line">A = ((X <span class="keyword">and</span> Y) <span class="keyword">or</span> Z)</span><br><span class="line">A = [Z, Y][bool(X)]</span><br></pre></td></tr></table></figure>

<p><code>A = Y if X else Z</code>三元表达式执行短路运算.只有当X为真,Python才会执行表达式Y,而只有当X为假,才会执行表达式Z</p>
<p><code>((X and Y) or Z)</code>实现同样效果,但要求Y为真</p>
<p><code>bool</code>函数会把X转换为对应的整数<code>1</code>或<code>0</code>,实现同样效果,但不执行短路运算</p>
<h2 id="为什么要在意布尔值"><a href="#为什么要在意布尔值" class="headerlink" title="为什么要在意布尔值"></a>为什么要在意布尔值</h2><p><code>X = A or B or C or None</code></p>
<p>从一个固定大小的集合中选择非空的对象</p>
<p><code>X = A or default</code></p>
<p>用来指定一个默认值</p>
<p><code>if f1() or f2():...</code></p>
<p>由于短路规则,可能会导致没有调用<code>f2()</code>执行工作</p>
<hr>
<h2 id="本章习题-2"><a href="#本章习题-2" class="headerlink" title="本章习题"></a>本章习题</h2><ol>
<li><p>在Python中怎样编写多路分支</p>
<blockquote>
<p><code>if</code>语句加多个<code>elif</code>分句通常是编写多路分支的最直接的方式</p>
<p>字典索引运算通常也能实现相同的结果,尤其是字典包含<code>def</code>语句或<code>lambda</code>表达式所写成的可调用函数</p>
</blockquote>
</li>
<li><p>在Python中怎样把<code>if/else</code>语句写成表达式</p>
<blockquote>
<p>表达式<code>Y if X else Z</code>在X为真时会返回Y,否则,返回Z</p>
<p><code>and/or</code>组合<code>((X and Y) or Z)</code>也以相同方式工作,但更难懂,而且要求Y为真</p>
</blockquote>
</li>
<li><p>怎样使单个语句横跨多行</p>
<blockquote>
<p>把语句包裹在语法括号<code>()</code>、<code>[]</code>或<code>{}</code>可以按照需要横跨多行,当Python看见闭合括号时,语句就会结束</p>
<p>该语句之外的第2行可以以任意缩进层级开始</p>
</blockquote>
</li>
<li><p><code>True</code>和<code>False</code>这两个字代表了什么意义</p>
<blockquote>
<p><code>True</code>和<code>False</code>是整数<code>1</code>和<code>0</code>的特殊版本,代表Python中的布尔真假值</p>
<p>它们可以用来进行真测试、变量初始化以及在交互提示模式中打印表达式结果</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="第十三章-while和for循环"><a href="#第十三章-while和for循环" class="headerlink" title="第十三章 while和for循环"></a>第十三章 while和for循环</h1><blockquote>
<ul>
<li>本章将会遇到两个Python主要循环结构<ul>
<li>while语句提供编写通用循环的一种方法</li>
<li>for语句遍历序列对象内的元素,并对每个元素运行一个代码块</li>
</ul>
</li>
<li>研究一下在循环中不太常用的语句(例如,break和continue)</li>
<li>介绍循环中常用的一些内置函数(例如,range、zip、map和enumerate)</li>
</ul>
</blockquote>
<hr>
<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>while语句是Python语言中最通用的迭代结构</p>
<p>只要顶端测试一直计算到真值,就会重复执行一个语句块,当测试变为假时控制其会传给while块后的语句</p>
<h3 id="一般格式"><a href="#一般格式" class="headerlink" title="一般格式"></a>一般格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;test&gt;:		<span class="comment"># Loop test</span></span><br><span class="line">	&lt;statements1&gt;	<span class="comment"># Loop body</span></span><br><span class="line"><span class="keyword">else</span>:				<span class="comment"># Optional else</span></span><br><span class="line">	&lt;statements2&gt;	<span class="comment"># Run if didn't exit loop with break</span></span><br></pre></td></tr></table></figure>

<p>首行以及测试表达式、有一列或多列缩进语句的主体以及一个可选的<code>else</code>部分</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	print(<span class="string">'Type Ctrl-C to stop me'</span>)</span><br></pre></td></tr></table></figure>

<p><code>True</code>总是指向布尔真值,所以Python会一直执行主体,这种行为通常称为无限循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">'spam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> x:				<span class="comment"># While x is not empty</span></span><br><span class="line"><span class="meta">... </span>    print(x, end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span>    x = x[<span class="number">1</span>:]			<span class="comment"># Strip first character off x</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">spam pam am m</span><br></pre></td></tr></table></figure>

<p>直接测试字符串直到字符串为空返回假时为止</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	...loop body...</span><br><span class="line">	<span class="keyword">if</span> exitTest(): <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>在循环主体底部以一个测试和break来实现类似其他语言<code>do until</code>功能</p>
<h3 id="break、continue、pass和循环else"><a href="#break、continue、pass和循环else" class="headerlink" title="break、continue、pass和循环else"></a>break、continue、pass和循环else</h3><blockquote>
<ul>
<li><p><code>break</code></p>
<p>跳出所在的最近的循环</p>
</li>
<li><p>continue</p>
<p>跳至最近所在循环的开头处</p>
</li>
<li><p>pass</p>
<p>什么也不做,空占位语句</p>
</li>
<li><p>循环<code>else</code>块</p>
<p>只有当循环正常离开时才会执行(没有碰到<code>break</code>语句)</p>
</li>
</ul>
</blockquote>
<h4 id="一般循环格式"><a href="#一般循环格式" class="headerlink" title="一般循环格式"></a>一般循环格式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;test1&gt;:</span><br><span class="line">	&lt;statements1&gt;</span><br><span class="line">	<span class="keyword">if</span> &lt;test2&gt;: <span class="keyword">break</span>		<span class="comment"># Exit loop now,skip else</span></span><br><span class="line">	<span class="keyword">if</span> &lt;test3&gt;: <span class="keyword">continue</span>	<span class="comment"># Go to top of loop now,to test1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	&lt;statements2&gt;			<span class="comment"># Run if we didn't hit a 'break'</span></span><br></pre></td></tr></table></figure>

<p><code>break</code>和<code>continue</code>可以出现在<code>while</code>(或<code>for</code>)循环主体的任何地方,但通常会进一步嵌套在<code>if</code>语句中</p>
<h4 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h4><p><code>pass</code>语句是无运算的占位语句,当语法需要语句而且还没有任何实用的语句可写时,就可以使用它</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: <span class="keyword">pass</span>		<span class="comment"># Type Ctrl-C to stop me!</span></span><br></pre></td></tr></table></figure>

<p><code>pass</code>像对象中的<code>None</code>一样,表示什么也没有</p>
<p><code>pass</code>可以忽略<code>try</code>语句所捕获的异常,以及定义带属性的空类对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">pass</span>		<span class="comment"># Add real code here later</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    ...			<span class="comment"># Alternative to pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    ...			<span class="comment"># Does nothing if called</span></span><br></pre></td></tr></table></figure>

<p>函数体为空会产生语法错误,因为需要使用<code>pass</code>替代</p>
<p><code>...</code>可以作为<code>pass</code>替代方案,还可以为变量赋值</p>
<h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p><code>continue</code>语句会立即跳到循环的顶端,其后的循环代码都不会执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">while</span> x:</span><br><span class="line">	x = x<span class="number">-1</span>						<span class="comment"># Or,x -= 1</span></span><br><span class="line">	<span class="keyword">if</span> x %<span class="number">2</span> != <span class="number">0</span> :<span class="keyword">continue</span>		<span class="comment"># Odd?--skip print</span></span><br><span class="line">	print(x, end=<span class="string">' '</span>)</span><br><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">while</span> x:</span><br><span class="line">	x = x<span class="number">-1</span></span><br><span class="line">	<span class="keyword">if</span> x %<span class="number">2</span> == <span class="number">0</span>:				<span class="comment"># Even?--print</span></span><br><span class="line">		print(x, end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure>

<p>因为<code>continue</code>让程序执行时实现跳跃,可读性和可维护性会很差</p>
<h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p><code>break</code>语句会立刻离开循环,其后的循环代码都不会执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    name = input(<span class="string">'Enter name:'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> name == <span class="string">'stop'</span>: <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    age = input(<span class="string">'Enter age: '</span>)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello'</span>, name, <span class="string">'=&gt;'</span>, int(age) ** <span class="number">2</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Enter name:mel</span><br><span class="line">Enter age: <span class="number">40</span></span><br><span class="line">Hello mel =&gt; 1600</span><br><span class="line">Enter name:bob</span><br><span class="line">Enter age: <span class="number">30</span></span><br><span class="line">Hello bob =&gt; 900</span><br><span class="line">Enter name:stop</span><br></pre></td></tr></table></figure>

<p>引入break可以避免嵌套化</p>
<h4 id="循环else"><a href="#循环else" class="headerlink" title="循环else"></a>循环else</h4><p>和循环<code>else</code>子句结合时,<code>break</code>语句通常可以忽略其他语言中所需要的搜索状态标志位</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = y // <span class="number">2</span>				<span class="comment"># For some y &gt; 1</span></span><br><span class="line"><span class="keyword">while</span> x &gt; <span class="number">1</span>:</span><br><span class="line">	<span class="keyword">if</span> y % x == <span class="number">0</span>:		<span class="comment"># Remainder</span></span><br><span class="line">		print(y, <span class="string">'has factor'</span>, x)</span><br><span class="line">		<span class="keyword">break</span>			<span class="comment"># Skip else</span></span><br><span class="line">	x -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:					<span class="comment"># Normal exit</span></span><br><span class="line">	print(y, <span class="string">'is primer'</span>)</span><br></pre></td></tr></table></figure>

<p>插入<code>break</code>后,<code>else</code>分句可以视为循环测试恒为假时执行</p>
<h5 id="关于循环else分句的更多内容"><a href="#关于循环else分句的更多内容" class="headerlink" title="关于循环else分句的更多内容"></a>关于循环else分句的更多内容</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">found = <span class="literal">False</span></span><br><span class="line"><span class="keyword">while</span> x <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">	<span class="keyword">if</span> match(x[<span class="number">0</span>]):			<span class="comment"># Value at front?</span></span><br><span class="line">		print(<span class="string">'Ni'</span>)</span><br><span class="line">		found = <span class="literal">True</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		x = x[<span class="number">1</span>:]			<span class="comment"># Slice off front and repeat</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> found:</span><br><span class="line">	print(<span class="string">'not found'</span>)</span><br><span class="line"><span class="keyword">while</span> x:					<span class="comment"># Exit when x empty</span></span><br><span class="line">	<span class="keyword">if</span> match(x[<span class="number">0</span>]):</span><br><span class="line">		print(<span class="string">'Ni'</span>)</span><br><span class="line">		<span class="keyword">break</span>				<span class="comment"># Exit,go around else</span></span><br><span class="line">	x = x[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">'Not found'</span>)		<span class="comment"># Only here if exhausted x</span></span><br></pre></td></tr></table></figure>

<p><code>else</code>可以替代设定和检查标志位或条件</p>
<h3 id="为什么要在意”模拟C语言的while循环”"><a href="#为什么要在意”模拟C语言的while循环”" class="headerlink" title="为什么要在意”模拟C语言的while循环”"></a>为什么要在意”模拟C语言的while循环”</h3><p>C语言编码样式<code>while((x = next()) != NULL) {...process x...}</code></p>
<p>Python中不允许赋值语句出现在表达式的位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	x = next()</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> x: <span class="keyword">break</span></span><br><span class="line">	...process x...</span><br><span class="line"></span><br><span class="line">x = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> x:</span><br><span class="line">	x = next()</span><br><span class="line">	<span class="keyword">if</span> x:</span><br><span class="line">		...process x...</span><br><span class="line"></span><br><span class="line">x = next()</span><br><span class="line"><span class="keyword">while</span> x:</span><br><span class="line">	...process x...</span><br><span class="line">	x = next()</span><br></pre></td></tr></table></figure>

<p>Python中等效的替代方法</p>
<hr>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p><code>for</code>循环在Python中是一个通用的序列迭代器</p>
<p><code>for</code>循环可以遍历任何有序的序列对象内的元素,可用于字符串、列表、元组、其他内置可迭代对象以及通过类所<br>创建的新对象</p>
<h3 id="一般格式-1"><a href="#一般格式-1" class="headerlink" title="一般格式"></a>一般格式</h3><p><code>for</code>循环首行定义一个赋值目标,以及想遍历的对象,首行后面是需要重复的语句块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;target&gt; <span class="keyword">in</span> &lt;object&gt;:	<span class="comment"># Assign object items to target</span></span><br><span class="line">	&lt;statements&gt;			<span class="comment"># Repeated loop body:use target</span></span><br><span class="line">    <span class="keyword">if</span> &lt;test&gt;: <span class="keyword">break</span>		<span class="comment"># Exit loop now,skip else</span></span><br><span class="line">    <span class="keyword">if</span> &lt;test&gt;: <span class="keyword">continue</span>		<span class="comment"># Go to top of loop now</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	&lt;statements&gt;			<span class="comment"># If we didn't hit a 'break'</span></span><br></pre></td></tr></table></figure>

<p>当Python运行for循环时,会逐个将序列对象中的元素赋值给<code>target</code>,然后为每个元素执行循环主体</p>
<p><code>for</code>首行中用作赋值目标的变量名通常是for语句所在作用域中的变量,可以在循环主体中修改,但是当控制权再次回到循环<br>顶端时,就会自动被设成序列中的下一个元素,退出循环后,赋值目标的变量为引用的最后一个对象</p>
<p><code>for</code>支持<code>else</code>块,如果循环离开时没有碰到<code>break</code>语句时就会执行<code>else</code>块</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><h4 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">"spam"</span>, <span class="string">"eggs"</span>, <span class="string">"ham"</span>]:</span><br><span class="line"><span class="meta">... </span>    print(x, end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">spam eggs ham</span><br></pre></td></tr></table></figure>

<p><code>for</code>循环可以遍历任何一种序列对象,把目标变量依次赋值为序列中的每个元素</p>
<h4 id="其他数据类型"><a href="#其他数据类型" class="headerlink" title="其他数据类型"></a>其他数据类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>S = <span class="string">"lumberjack"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>T = (<span class="string">"and"</span>, <span class="string">"I'm"</span>, <span class="string">"okay"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> S: print(x, end=<span class="string">' '</span>)		<span class="comment"># Iterate over a string</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">l u m b e r j a c k</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> T: print(x, end=<span class="string">' '</span>)		<span class="comment"># Iterate over a tuple</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="keyword">and</span> I<span class="string">'m okay</span></span><br></pre></td></tr></table></figure>

<p><code>for</code>循环可用于任何序列,甚至不是序列的对象上</p>
<h4 id="在for循环中的元组赋值"><a href="#在for循环中的元组赋值" class="headerlink" title="在for循环中的元组赋值"></a>在for循环中的元组赋值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>T = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> (a, b) <span class="keyword">in</span> T:			<span class="comment"># Tuple assignment at work</span></span><br><span class="line"><span class="meta">... </span>    print(a, b)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> both <span class="keyword">in</span> T:</span><br><span class="line"><span class="meta">... </span>    a, b = both				<span class="comment"># Manual assignment equivalent</span></span><br><span class="line"><span class="meta">... </span>    print(a, b)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>((a, b), c) = ((<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>)	<span class="comment"># Nested sequences work too</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> ((a, b), c) <span class="keyword">in</span> [((<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>), ((<span class="number">4</span>, <span class="number">5</span>), <span class="number">6</span>)]: print(a, b, c)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>迭代元组序列时,循环目标变量本身可以是一个元组或者是一个嵌套的结构,任何赋值目标变量在语法上都能用在<code>for</code>关键字后</p>
<p><code>for</code>循环可以自动解包,直接将目标变量进行赋值操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>D = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> D:</span><br><span class="line"><span class="meta">... </span>    print(key, <span class="string">'=&gt;'</span>, D[key])	<span class="comment"># Use dict keys iterator and index</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">a =&gt; 1</span><br><span class="line">b =&gt; 2</span><br><span class="line">c =&gt; 3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(D.items())</span><br><span class="line">[(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> (key, value) <span class="keyword">in</span> D.items():</span><br><span class="line"><span class="meta">... </span>    print(key, <span class="string">'=&gt;'</span>, value)		<span class="comment"># Iterate over both keys and values</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">a =&gt; 1</span><br><span class="line">b =&gt; 2</span><br><span class="line">c =&gt; 3</span><br></pre></td></tr></table></figure>

<p><code>for</code>循环中的元组变量使得用<code>items</code>方法遍历字典中的键和值变得很方便</p>
<h4 id="Python-3-0在for循环中拓展的序列赋值"><a href="#Python-3-0在for循环中拓展的序列赋值" class="headerlink" title="Python 3.0在for循环中拓展的序列赋值"></a>Python 3.0在for循环中拓展的序列赋值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *b, c = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)		<span class="comment"># Extended seq assignment</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> (a, *b, c) <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]:</span><br><span class="line"><span class="meta">... </span>    print(a, b, c)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">1</span> [<span class="number">2</span>, <span class="number">3</span>] <span class="number">4</span></span><br><span class="line"><span class="number">5</span> [<span class="number">6</span>, <span class="number">7</span>] <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p><code>for</code>循环可以使用Python 3.0的拓展序列解包赋值语法来提取序列中的序列的元素和部分</p>
<h4 id="嵌套for循环"><a href="#嵌套for循环" class="headerlink" title="嵌套for循环"></a>嵌套for循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = [<span class="string">"aaa"</span>, <span class="number">11</span>, (<span class="number">4</span>, <span class="number">5</span>), <span class="number">2.01</span>]	<span class="comment"># A set of objects</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tests = [(<span class="number">4</span>, <span class="number">5</span>), <span class="number">3.14</span>]				<span class="comment"># Keys to search for</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> tests:					<span class="comment"># For all keys</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> item <span class="keyword">in</span> items:				<span class="comment"># For all items</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> item == key:			<span class="comment"># Check for match</span></span><br><span class="line"><span class="meta">... </span>                    print(key, <span class="string">"was found"</span>)</span><br><span class="line"><span class="meta">... </span>                    <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>            print(key, <span class="string">"not found!"</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>) was found</span><br><span class="line"><span class="number">3.14</span> <span class="keyword">not</span> found!</span><br></pre></td></tr></table></figure>

<p><code>break</code>语句跳出最近的循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> tests:			<span class="comment"># For all keys</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> key <span class="keyword">in</span> items:		<span class="comment"># Let Python check for a match</span></span><br><span class="line"><span class="meta">... </span>            print(key, <span class="string">"was found"</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>            print(key, <span class="string">"not found!"</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>) was found</span><br><span class="line"><span class="number">3.14</span> <span class="keyword">not</span> found!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq1 = <span class="string">"spam"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq2 = <span class="string">"scam"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> seq1:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> x <span class="keyword">in</span> seq2:</span><br><span class="line"><span class="meta">... </span>            res.append(x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">[<span class="string">'s'</span>, <span class="string">'a'</span>, <span class="string">'m'</span>]</span><br></pre></td></tr></table></figure>

<p><code>in</code>运算符测试成员关系可以隐性地扫描列表来找到匹配</p>
<h3 id="为什么要在意”文件扫描”"><a href="#为什么要在意”文件扫描”" class="headerlink" title="为什么要在意”文件扫描”"></a>为什么要在意”文件扫描”</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file = open(<span class="string">'test.txt'</span>, <span class="string">'r'</span>)		<span class="comment"># Read contents into a string</span></span><br><span class="line">print(file.read())</span><br></pre></td></tr></table></figure>

<p>调用<code>read</code>可以把文件内容一次加载至字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">file = open(<span class="string">'test.txt'</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	char = file.read(<span class="number">1</span>)			<span class="comment"># Read by character</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> char: <span class="keyword">break</span></span><br><span class="line">	print(char)</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> open(<span class="string">'test.txt'</span>).read:</span><br><span class="line">	print(char)</span><br><span class="line">file = open(<span class="string">'test.txt'</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	line = file.readline()		<span class="comment"># Read line by line</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> line: <span class="keyword">break</span></span><br><span class="line">	print(line, end=<span class="string">''</span>)			<span class="comment"># Line already has a \n</span></span><br><span class="line">file = open(<span class="string">'test.txt'</span>, <span class="string">'rb'</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	chunk = file.read(<span class="number">10</span>)		<span class="comment"># Read byte chunks:up to 10 bytes</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> chunk: <span class="keyword">break</span></span><br><span class="line">	<span class="keyword">print</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'test.txt'</span>).readlines():</span><br><span class="line">	print(line, end=<span class="string">''</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'test.txt'</span>):	<span class="comment"># Use iterators:best next input mode</span></span><br><span class="line">	print(line, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<p>分块加载文件可以写一个<code>while</code>循环结尾使用<code>break</code>,</p>
<p>使用<code>for</code>循环分块加载文件会一次把文加载至内存</p>
<p><code>readlines</code>方法会一次把文件载入到一个行字符串的列表</p>
<hr>
<h2 id="编写循环的技巧"><a href="#编写循环的技巧" class="headerlink" title="编写循环的技巧"></a>编写循环的技巧</h2><p>一般<code>for</code>比<code>while</code>容易写,执行时也比较快</p>
<blockquote>
<ul>
<li>内置<code>range</code>函数返回一系列连续增加的整数,可作为<code>for</code>中的索引</li>
<li>内置<code>zip</code>函数返回并行元素的元组的列表,可用于在<code>for</code>中遍历数个序列</li>
</ul>
</blockquote>
<h3 id="循环计数器-while和range"><a href="#循环计数器-while和range" class="headerlink" title="循环计数器:while和range"></a>循环计数器:while和range</h3><p><code>range</code>函数可用在任何需要整数列表的地方</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">5</span>)), list((range(<span class="number">2</span>, <span class="number">5</span>))), list(range(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line">([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>一个参数时,<code>range</code>会产生从零算起的整数列表,但其中不包括该参数的值</li>
<li>两个参数时,第一个将视为下边界</li>
<li>第三个选用参数可以提供步进值,Python会对每个连续整数加上步进值从而得到结果(步进值默认为1)</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">-5</span>, <span class="number">5</span>))</span><br><span class="line">[<span class="number">-5</span>, <span class="number">-4</span>, <span class="number">-3</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">5</span>, <span class="number">-5</span>, <span class="number">-1</span>))</span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-4</span>]</span><br></pre></td></tr></table></figure>

<p><code>range</code>可以是非整数或非递增的整数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>    print(i, <span class="string">'Pythons'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span> Pythons</span><br><span class="line"><span class="number">1</span> Pythons</span><br><span class="line"><span class="number">2</span> Pythons</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = <span class="string">'spam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(X)											<span class="comment"># Length of string</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(len(X)))								<span class="comment"># All legal offsets into X</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(len(X)): print(X[i], end=<span class="string">' '</span>)	<span class="comment"># Manual for indexing</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">s p a m</span><br></pre></td></tr></table></figure>

<p><code>range</code>函数常用在<code>for</code>循环中,提供了重复特定次数的方法</p>
<p><code>range</code>函数可以使用<code>for</code>循环进行手动索引列表</p>
<h3 id="非完备遍历-range和分片"><a href="#非完备遍历-range和分片" class="headerlink" title="非完备遍历:range和分片"></a>非完备遍历:range和分片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>S = <span class="string">'abcdefghijk'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">0</span>, len(S), <span class="number">2</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(S), <span class="number">2</span>): print(S[i], end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">a c e g i k</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> S[::<span class="number">2</span>]: print(c, end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">a c e g i k</span><br></pre></td></tr></table></figure>

<p><code>range</code>函数可以做更特殊的遍历种类,例如,遍历过程中跳过一些元素</p>
<p>跳过序列中的元素可以使用限制值形式的分片表达式</p>
<p>使用<code>range</code>不会复制字符串,节省内存</p>
<h3 id="修改列表-range"><a href="#修改列表-range" class="headerlink" title="修改列表:range"></a>修改列表:range</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> L:</span><br><span class="line"><span class="meta">... </span>    x += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> i &lt; len(L):</span><br><span class="line"><span class="meta">... </span>    L[i] += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    i += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(len(L)):		<span class="comment"># Add one to each item in l</span></span><br><span class="line"><span class="meta">... </span>    L[i] += <span class="number">1</span>				<span class="comment"># Or L[i] = L[i] + 1</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<p>无法通过修改遍历列表的循环变量来修改列表,因为修改循环变量引用下一个元素时并不会更新列表</p>
<p><code>while</code>循环需要多做些工作,且可能运行很慢</p>
<p>可以使用<code>range</code>和<code>for</code>的组合在遍历列表时对其进行修改,通过<code>range/len</code>组合产生的索引在遍历时将每个位置赋一个值来更新列表</p>
<p>还可以使用列表解析表达式做类似工作,并且不会在原处进行修改</p>
<h3 id="并行遍历-zip和map"><a href="#并行遍历-zip和map" class="headerlink" title="并行遍历:zip和map"></a>并行遍历:zip和map</h3><p>内置的<code>zip</code>函数允许使用<code>for</code>循环来并行使用多个序列</p>
<p>在基本运算中,<code>zip</code>会取得一个或多个序列为参数,返回元组的列表,将这些序列中的并排的元素配成对</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L2 = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zip(L1, L2)</span><br><span class="line">&lt;zip object at <span class="number">0x10420dec8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(L1, L2))			<span class="comment"># list() required in 3.0</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">6</span>), (<span class="number">3</span>, <span class="number">7</span>), (<span class="number">4</span>, <span class="number">8</span>)]</span><br></pre></td></tr></table></figure>

<p><code>zip</code>和<code>range</code>一样是一个可迭代对象,需要包含在一个<code>list</code>调用中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> (x, y) <span class="keyword">in</span> zip(L1, L2):</span><br><span class="line"><span class="meta">... </span>    print(x, y, <span class="string">'--'</span>, x+y)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> -- <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> -- <span class="number">8</span></span><br><span class="line"><span class="number">3</span> <span class="number">7</span> -- <span class="number">10</span></span><br><span class="line"><span class="number">4</span> <span class="number">8</span> -- <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p><code>for</code>循环使用元组赋值运算解包<code>zip</code>结果中的元组实现并行迭代</p>
<p><code>while</code>循环实现类似的效果需要多做些工作,且可能运行很慢</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>T1, T2, T3 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>T3</span><br><span class="line">(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(T1, T2, T3))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>S1 = <span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>S2 = <span class="string">'xyz123'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(S1, S2))</span><br><span class="line">[(<span class="string">'a'</span>, <span class="string">'x'</span>), (<span class="string">'b'</span>, <span class="string">'y'</span>), (<span class="string">'c'</span>, <span class="string">'z'</span>)]</span><br></pre></td></tr></table></figure>

<p><code>zip</code>函数可以接受任何可迭代的对象,并且可以有两个以上的参数</p>
<p>当参数长度不同时,<code>zip</code>会以最短序列的长度为准来截断所得到的元组</p>
<h4 id="Python-2-6中的map的等价形式"><a href="#Python-2-6中的map的等价形式" class="headerlink" title="Python 2.6中的map的等价形式"></a>Python 2.6中的map的等价形式</h4><p>Python 2.X中内置<code>map</code>函数可以用类似方法把序列的元素配对起来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>S1 = <span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>S2 = <span class="string">'xyz123'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="literal">None</span>, S1, S2)	<span class="comment"># 2.X only</span></span><br><span class="line">[(<span class="string">'a'</span>, <span class="string">'x'</span>), (<span class="string">'b'</span>, <span class="string">'y'</span>), (<span class="string">'c'</span>, <span class="string">'z'</span>), (<span class="literal">None</span>, <span class="string">'1'</span>), (<span class="literal">None</span>, <span class="string">'2'</span>), (<span class="literal">None</span>, <span class="string">'3'</span>)]</span><br></pre></td></tr></table></figure>

<p>如果参数长度不同,会为较短的序列用<code>None</code>补齐</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(ord, <span class="string">'spam'</span>))</span><br><span class="line">[<span class="number">115</span>, <span class="number">112</span>, <span class="number">97</span>, <span class="number">109</span>]</span><br></pre></td></tr></table></figure>

<p>一般来讲,<code>map</code>会将一个函数以及一个或多个的序列作为参数,从序列中取出并行元素并传给调用函数,将返回结果收集起来</p>
<h4 id="使用zip构造字典"><a href="#使用zip构造字典" class="headerlink" title="使用zip构造字典"></a>使用zip构造字典</h4><p>当键和值的集合必须在运行时计算时,可以用<code>zip</code>函数产生字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>keys = [<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'toast'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vals = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D1 = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D1[<span class="string">'spam'</span>] = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D1[<span class="string">'eggs'</span>] = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D1[<span class="string">'toast'</span>] = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(keys, vals))</span><br><span class="line">[(<span class="string">'spam'</span>, <span class="number">1</span>), (<span class="string">'eggs'</span>, <span class="number">3</span>), (<span class="string">'toast'</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D2 = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> (k, v) <span class="keyword">in</span> zip(keys, vals): D2[k] = v</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D2</span><br><span class="line">&#123;<span class="string">'spam'</span>: <span class="number">1</span>, <span class="string">'eggs'</span>: <span class="number">3</span>, <span class="string">'toast'</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D3 = dict(zip(keys, vals))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D3</span><br><span class="line">&#123;<span class="string">'spam'</span>: <span class="number">1</span>, <span class="string">'eggs'</span>: <span class="number">3</span>, <span class="string">'toast'</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>可以编写字典常量或者对键进行赋值来创建字典</p>
<p>使用<code>zip</code>函数与<code>for</code>循环可以在运行时获得字典</p>
<p>可以把<code>zip</code>函数返回的<code>key/value</code>列表传给内置的<code>dict</code>函数获得字典</p>
<h3 id="产生偏移和元素-enumerate"><a href="#产生偏移和元素-enumerate" class="headerlink" title="产生偏移和元素:enumerate"></a>产生偏移和元素:enumerate</h3><p><code>enumerate</code>函数可以获得元素以及这个元素的偏移值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>S = <span class="string">'spam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> (offset, item) <span class="keyword">in</span> enumerate(S):</span><br><span class="line"><span class="meta">... </span>    print(item, <span class="string">'appears at offset'</span>, offset)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">s appears at offset <span class="number">0</span></span><br><span class="line">p appears at offset <span class="number">1</span></span><br><span class="line">a appears at offset <span class="number">2</span></span><br><span class="line">m appears at offset <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>E = enumerate(S)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>E</span><br><span class="line">&lt;enumerate object at <span class="number">0x10420fa68</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(E)</span><br><span class="line">(<span class="number">0</span>, <span class="string">'s'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(E)</span><br><span class="line">(<span class="number">1</span>, <span class="string">'p'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(E)</span><br><span class="line">(<span class="number">2</span>, <span class="string">'a'</span>)</span><br></pre></td></tr></table></figure>

<p><code>enumerate</code>函数返回一个生成器对象,这个对象有一个<code>__next__</code>方法,由下一个内置函数调用它,并且每次迭代时返回一个(index,value)元组</p>
<hr>
<h2 id="本章习题-3"><a href="#本章习题-3" class="headerlink" title="本章习题"></a>本章习题</h2><ol>
<li><p><code>While</code>和<code>for</code>之间的主要功能区别是什么</p>
<blockquote>
<p><code>while</code>循环是一条通用的循环语句</p>
<p><code>for</code>循环设计用来在一个序列中遍历各项(序列需要是真正可迭代的)</p>
<p>尽管while可以用计数器循环来模拟for循环,但它需要更多的代码并且可能运行起来更慢些</p>
</blockquote>
</li>
<li><p><code>break</code>和<code>continue</code>之间有何区别</p>
<blockquote>
<p><code>break</code>语句立即退出一个循环(省略了下面的整个<code>while</code>或<code>for</code>循环语句)<br><code>continue</code>跳回到循环的顶部(跳转到<code>while</code>中测试之前的部分或<code>for</code>中的下一次元素获取)</p>
</blockquote>
</li>
<li><p>一个循环的<code>else</code>分句何时执行</p>
<blockquote>
<p><code>while</code>或<code>for</code>循环中的<code>else</code>分句会在循环离开时执行一次,但前提是循环是正常离开(没有运行<code>break</code>语句),如果有的话,<code>break</code>会立刻离开循环,跳过<code>else</code>部分</p>
</blockquote>
</li>
<li><p>在Python中怎样编写一个基于计数器的循环</p>
<blockquote>
<p>计数器循环可以使用<code>while</code>语句编写,并手动记录索引值</p>
<p>以<code>for</code>循环使用range内置函数来产生连续的整数偏移值</p>
<p>如果只需要遍历序列中所有元素,任何一种都不是Python中的推荐的做法,只要可能就改用简单的<code>for</code>循环,不用<code>range</code>或计数器,这样做不仅更容易编写,而且通常运行得更快</p>
</blockquote>
</li>
<li><p>怎样使range用于for循环中</p>
<blockquote>
<p><code>range</code>内置函数可以用在一个for循环中来实现固定次数的重复,以按照偏移值而不是偏移值处的元素来扫描,从而在循环过程中省略连续的元素,并且在遍历一个列表的时候修改它</p>
<p>这样的用法并非都需要range,大多数有其他的替代方法,例如,扫描实际的元素、三重限制分片以及列表解析往往是较好的解决方案</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="第十四章-迭代器和解析-第一部分"><a href="#第十四章-迭代器和解析-第一部分" class="headerlink" title="第十四章 迭代器和解析,第一部分"></a>第十四章 迭代器和解析,第一部分</h1><blockquote>
<ul>
<li>介绍Python的迭代协议:非序列对象参与迭代循环以及列表解析的方式</li>
<li>介绍列表解析的细节</li>
<li>介绍其他内置迭代工具的使用</li>
</ul>
</blockquote>
<hr>
<h2 id="迭代器-初探"><a href="#迭代器-初探" class="headerlink" title="迭代器:初探"></a>迭代器:初探</h2><p>迭代协议:有<code>__next__</code>方法的对象会前进得到下一个结果,在一系列结果的末尾引发<code>StopIteration</code>异常</p>
<p>任何遵守迭代协议的对象都是可迭代对象,包括实际序列和按照需求而计算的虚拟序列</p>
<p>迭代工具可用于任何可迭代的对象,包括<code>for</code>循环、列表解析、<code>in</code>成员关系测试以及<code>map</code>内置函数等,他们内部工作都是在每次迭代中调用<code>__next__</code>,并且捕捉<code>StopIteration</code>异常来确定合适离开</p>
<h3 id="文件迭代器"><a href="#文件迭代器" class="headerlink" title="文件迭代器"></a>文件迭代器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;script1.py&apos;)  # Read a  4-line script file in this directory</span><br><span class="line">&gt;&gt;&gt; f.readline()            # readline loads one line on each all</span><br><span class="line">&apos;import sys\n&apos;</span><br><span class="line">&gt;&gt;&gt; f.readline()</span><br><span class="line">&apos;print(sys.path)\n&apos;</span><br><span class="line">&gt;&gt;&gt; f.readline()</span><br><span class="line">&apos;x = 2\n&apos;</span><br><span class="line">&gt;&gt;&gt; f.readline()</span><br><span class="line">&apos;print(2 ** 33)\n&apos;</span><br><span class="line">&gt;&gt;&gt; f.readline()</span><br><span class="line">&apos;&apos;</span><br><span class="line">&gt;&gt;&gt; f = open(&apos;script1.py&apos;)  # __next__loads one line on each call too</span><br><span class="line">&gt;&gt;&gt; f.__next__()            # But raises an exception at end-of-file</span><br><span class="line">&apos;import sys\n&apos;</span><br><span class="line">&gt;&gt;&gt; f.__next__()</span><br><span class="line">&apos;print(sys.path)\n&apos;</span><br><span class="line">&gt;&gt;&gt; f.__next__()</span><br><span class="line">&apos;x = 2\n&apos;</span><br><span class="line">&gt;&gt;&gt; f.__next__()</span><br><span class="line">&apos;print(2 ** 33)\n&apos;</span><br><span class="line">&gt;&gt;&gt; f.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt; for line in open(&apos;script1.py&apos;):</span><br><span class="line">...     print(line.upper(), end=&apos;&apos;)</span><br><span class="line">... </span><br><span class="line">IMPORT SYS</span><br><span class="line">PRINT(SYS.PATH)</span><br><span class="line">X = 2</span><br><span class="line">PRINT(2 ** 33)</span><br></pre></td></tr></table></figure>

<p>文件对象的<code>readline</code>方法可以一次从一个文件中读取一行文本,每次调用就会前进到下一行,到达文件末尾时返回空字符串</p>
<p>文件对象的<code>__next__</code>方法可以每次调用返回文件中的下一行,到达文件末尾时引发内置的<code>StopIteration</code>异常</p>
<p><code>for</code>循环在每轮自动调用<code>next</code>从而前进到下一行,这是最简单的写法,运行最快,从内存使用情况来说也是最好的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for line in open(&apos;script1.py&apos;).readlines():</span><br><span class="line">...     print(line.upper(), end=&apos;&apos;)</span><br><span class="line">... </span><br><span class="line">IMPORT SYS</span><br><span class="line">PRINT(SYS.PATH)</span><br><span class="line">X = 2</span><br><span class="line">PRINT(2 ** 33)</span><br><span class="line">&gt;&gt;&gt; f = open(&apos;script1.py&apos;)</span><br><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">...     line = f.readline()</span><br><span class="line">...     if not line: break</span><br><span class="line">...     print(line.upper(), end=&apos;&apos;)</span><br><span class="line">... </span><br><span class="line">IMPORT SYS</span><br><span class="line">PRINT(SYS.PATH)</span><br><span class="line">X = 2</span><br><span class="line">PRINT(2 ** 33)</span><br></pre></td></tr></table></figure>

<p><code>readlines</code>方法将文件内容加载到内存,做成行字符串的列表,如果文件太大,可能导致计算机内存空间不够,甚至不能工作</p>
<p>比起迭代器<code>for</code>循环,<code>while</code>循环逐行读取文件运行得更慢,因为迭代器在Python中是以C语言的速度运行的</p>
<h3 id="手动迭代-iter和next"><a href="#手动迭代-iter和next" class="headerlink" title="手动迭代:iter和next"></a>手动迭代:iter和next</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;script1.py&apos;)</span><br><span class="line">&gt;&gt;&gt; f.__next__()            # Call iteration method directly</span><br><span class="line">&apos;import sys\n&apos;</span><br><span class="line">&gt;&gt;&gt; f.__next__()</span><br><span class="line">&apos;print(sys.path\n&apos;</span><br><span class="line">&gt;&gt;&gt; f = open(&apos;script1.py&apos;)</span><br><span class="line">&gt;&gt;&gt; next(f)                 # next built-in calls __next__</span><br><span class="line">&apos;import sys\n&apos;</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">&apos;print(sys.path\n&apos;</span><br></pre></td></tr></table></figure>

<p>内置函数<code>next</code>可以自动调用一个对象的<code>__next__</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; iter(L) is L</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; L.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;list&apos; object has no attribute &apos;__next__&apos;</span><br><span class="line">&gt;&gt;&gt; I = iter(L)     # Obtain an iterator object</span><br><span class="line">&gt;&gt;&gt; I.__next__()    # Call next to advance to next item</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(I)         # Same as I.__next__()</span><br><span class="line">2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt; f = open(&apos;script1.py&apos;)</span><br><span class="line">&gt;&gt;&gt; iter(f) is f</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; f.__next__()</span><br><span class="line">&apos;import sys\n&apos;</span><br></pre></td></tr></table></figure>

<p><code>iter</code>内置函数接受一个可迭代的对象,返回含有<code>__next__</code>方法的迭代器</p>
<p>列表与很多其他内置对象支持多次调用迭代器,因此它们自身不是迭代器,需要调用<code>iter</code>函数启动迭代</p>
<p>文件对象就是一个迭代器,拥有<code>__next__</code>方法,不需要传给<code>iter</code>函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; for X in L:                     # Automatic iteration</span><br><span class="line">...     print(X ** 2, end=&apos; &apos;)      # Obtains iter,calls __next__,catches exceptions</span><br><span class="line">... </span><br><span class="line">1 4 9</span><br><span class="line">&gt;&gt;&gt; I = iter(L)                     # Manual iteration:what for loops usually do</span><br><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">...     try:                        # try statement catches exceptions</span><br><span class="line">...             X = next(I)         # Or call I.__next__</span><br><span class="line">...     except StopIteration:</span><br><span class="line">...             break</span><br><span class="line">...     print(X ** 2, end=&apos; &apos;)</span><br><span class="line">... </span><br><span class="line">1 4 9</span><br></pre></td></tr></table></figure>

<p>迭代工具会将可迭代对象传给<code>iter</code>内置函数获得一个含有<code>__next__</code>方法的迭代器</p>
<p>可以手动地应用迭代协议,可以使用<code>__next__</code>方法或者<code>next</code>函数</p>
<p> <code>try</code>语句运行一个动作并且捕获在运行过程中发生的异常</p>
<h3 id="其他内置类型迭代器"><a href="#其他内置类型迭代器" class="headerlink" title="其他内置类型迭代器"></a>其他内置类型迭代器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for key in D.keys():</span><br><span class="line">...     print(key, D[key])</span><br><span class="line">... </span><br><span class="line">a 1</span><br><span class="line">b 2</span><br><span class="line">c 3</span><br><span class="line">&gt;&gt;&gt; I = iter(D)</span><br><span class="line">&gt;&gt;&gt; next(I)</span><br><span class="line">&apos;a&apos;</span><br><span class="line">&gt;&gt;&gt; next(I)</span><br><span class="line">&apos;b&apos;</span><br><span class="line">&gt;&gt;&gt; next(I)</span><br><span class="line">&apos;c&apos;</span><br><span class="line">&gt;&gt;&gt; next(I)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt; for key in D:</span><br><span class="line">...     print(key,D[key])</span><br><span class="line">... </span><br><span class="line">a 1</span><br><span class="line">b 2</span><br><span class="line">c 3</span><br></pre></td></tr></table></figure>

<p>遍历字典键可以明确地获取键的列表</p>
<p>字典有一个迭代器,在迭代环境中可以自动一次返回一个键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">P = os.popen(&apos;cd&apos;)</span><br><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; P = os.popen(&apos;ls&apos;)</span><br><span class="line">&gt;&gt;&gt; P.__next__()</span><br><span class="line">&apos;test.py\n&apos;</span><br><span class="line">&gt;&gt;&gt; next(P)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p><code>shelves</code>(用于Python对象的一个根据键访问的文件系统)和<code>os.popen</code>(读取shell命令输出的一个工具)的结果也是可迭代的</p>
<p><code>popen</code>对象支持<code>P.next()</code>方法,但不支持<code>next(P)</code>内置函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; R = range(5)</span><br><span class="line">&gt;&gt;&gt; R                       # Ranges are iterables in 3.0</span><br><span class="line">range(0, 5)</span><br><span class="line">&gt;&gt;&gt; I = iter(R)             # Use iteration protocol to produce results</span><br><span class="line">&gt;&gt;&gt; next(I)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(I)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; list(range(5))</span><br><span class="line">[0, 1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; E = enumerate(&apos;spam&apos;)   # enumerate is an iterable too</span><br><span class="line">&gt;&gt;&gt; E</span><br><span class="line">&lt;enumerate object at 0x104216c60&gt;</span><br><span class="line">&gt;&gt;&gt; I = iter(E)</span><br><span class="line">&gt;&gt;&gt; next(I)                 # Generate results with iteration protocol</span><br><span class="line">(0, &apos;s&apos;)</span><br><span class="line">&gt;&gt;&gt; next(I)                 # Or use list to force generation to run</span><br><span class="line">(1, &apos;p&apos;)</span><br><span class="line">&gt;&gt;&gt; list(enumerate(&apos;spam&apos;))</span><br><span class="line">[(0, &apos;s&apos;), (1, &apos;p&apos;), (2, &apos;a&apos;), (3, &apos;m&apos;)]</span><br></pre></td></tr></table></figure>

<p>由于迭代协议一次返回一个结果,只能把某些结果包装到<code>list</code>调用以一次性得到完整的值</p>
<hr>
<h2 id="列表解析-初探"><a href="#列表解析-初探" class="headerlink" title="列表解析:初探"></a>列表解析:初探</h2><p>列表解析是最常应用迭代协议的环境之一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [1, 2, 3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; for i in range(len(L)):</span><br><span class="line">...     L[i] += 10</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[11, 12, 13, 14, 15]</span><br><span class="line">&gt;&gt;&gt; L = [x + 10 for x in L]</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[21, 22, 23, 24, 25]</span><br></pre></td></tr></table></figure>

<p>列表解析可以用单个表达式替代循环产生所需的结果列表,代码较少且可能运行的更快</p>
<p>列表解析会产生一个新的列表对象</p>
<h3 id="列表解析基础知识"><a href="#列表解析基础知识" class="headerlink" title="列表解析基础知识"></a>列表解析基础知识</h3><p>列表解析写在一个方括号中,以一个任意的表达式开始,后边跟着<code>for</code>循环头部,它声明了循环变量和一个可迭代对象</p>
<p>Python在解释器内部执行一个迭代,按照顺序把循环变量赋值为每个元素引用,得到一个对循环变量运行左边表达式的结果</p>
<p>可以用<code>for</code>循环手动地构建一个表达式结果的列表,但是列表解析编写更加精简,可用于多种环境,且比<code>for</code>循环语句运行的更快</p>
<h3 id="在文件上使用列表解析"><a href="#在文件上使用列表解析" class="headerlink" title="在文件上使用列表解析"></a>在文件上使用列表解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;script1.py&apos;)</span><br><span class="line">&gt;&gt;&gt; lines = f.readlines()</span><br><span class="line">&gt;&gt;&gt; lines</span><br><span class="line">[&apos;import sys\n&apos;, &apos;print(sys.path)\n&apos;, &apos;x = 2\n&apos;, &apos;print(2 ** 33)\n&apos;]</span><br><span class="line">&gt;&gt;&gt; lines = [line.rstrip() for line in lines]</span><br><span class="line">&gt;&gt;&gt; lines</span><br><span class="line">[&apos;import sys&apos;, &apos;print(sys.path&apos;, &apos;)x = 2&apos;, &apos;print(2 ** 33)&apos;]</span><br><span class="line">&gt;&gt;&gt; lines = [line.rstrip() for line in open(&apos;script1.py&apos;)]</span><br><span class="line">&gt;&gt;&gt; lines</span><br><span class="line">[&apos;import sys&apos;, &apos;print(sys.path&apos;, &apos;)x = 2&apos;, &apos;print(2 ** 33)&apos;]</span><br></pre></td></tr></table></figure>

<p>文件对象的<code>readlines</code>方法一次性把文件载入到包含所有行字符串的列表</p>
<p>通过列表解析对每一行运行<code>rstrip</code>方法可以移除右端的空白(当确保所有的行正确结束时可以使用分片)</p>
<p>列表解析与<code>for</code>循环一样是一个迭代环境,在表达式中打开文件时,列表解析会自动使用迭代协议调用文件的<code>next</code>方法</p>
<p>在表达式中打开文件时,Python会扫描文件并构建操作结果的一个列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [line.upper() for line in open(&apos;script1.py&apos;)]</span><br><span class="line">[&apos;IMPORT SYS\n&apos;, &apos;PRINT(SYS.PATH)\n&apos;, &apos;X = 2\n&apos;, &apos;PRINT(2 ** 33)\n&apos;]</span><br><span class="line">&gt;&gt;&gt; [line.rstrip().upper() for line in open(&apos;script1.py&apos;)]</span><br><span class="line">[&apos;IMPORT SYS&apos;, &apos;PRINT(SYS.PATH)&apos;, &apos;X = 2&apos;, &apos;PRINT(2 ** 33)&apos;]</span><br><span class="line">&gt;&gt;&gt; [line.split() for line in open(&apos;script1.py&apos;)]</span><br><span class="line">[[&apos;import&apos;, &apos;sys&apos;], [&apos;print(sys.path)&apos;], [&apos;x&apos;, &apos;=&apos;, &apos;2&apos;], [&apos;print(2&apos;, &apos;**&apos;, &apos;33)&apos;]]</span><br><span class="line">&gt;&gt;&gt; [line.replace(&apos; &apos;, &apos;!&apos;) for line in open(&apos;script1.py&apos;)]</span><br><span class="line">[&apos;import!sys\n&apos;, &apos;print(sys.path)\n&apos;, &apos;x!=!2\n&apos;, &apos;print(2!**!33)\n&apos;]</span><br><span class="line">&gt;&gt;&gt; [(&apos;sys&apos; in line,line[0]) for line in open(&apos;script1.py&apos;)]</span><br><span class="line">[(True, &apos;i&apos;), (True, &apos;p&apos;), (False, &apos;x&apos;), (False, &apos;p&apos;)]</span><br></pre></td></tr></table></figure>

<p>可以在迭代时在一个文件的行上运行任何的字符串操作</p>
<h3 id="拓展的列表解析语法"><a href="#拓展的列表解析语法" class="headerlink" title="拓展的列表解析语法"></a>拓展的列表解析语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; lines = [line.rstrip() for line in open(&apos;script1.py&apos;) if line[0] == &apos;p&apos;]</span><br><span class="line">&gt;&gt;&gt; lines</span><br><span class="line">[&apos;print(sys.path)&apos;, &apos;print(2 ** 33)&apos;]</span><br><span class="line">&gt;&gt;&gt; res = []</span><br><span class="line">&gt;&gt;&gt; for line in open(&apos;script1.py&apos;):</span><br><span class="line">...     if line[0] == &apos;p&apos;:</span><br><span class="line">...             res.append(line.rstrip())</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; res</span><br><span class="line">[&apos;print(sys.path)&apos;, &apos;print(2 ** 33)&apos;]</span><br><span class="line">&gt;&gt;&gt; [x + y for x in &apos;abc&apos; for y in &apos;lmn&apos;]</span><br><span class="line">[&apos;al&apos;, &apos;am&apos;, &apos;an&apos;, &apos;bl&apos;, &apos;bm&apos;, &apos;bn&apos;, &apos;cl&apos;, &apos;cm&apos;, &apos;cn&apos;]</span><br><span class="line">&gt;&gt;&gt; res = []</span><br><span class="line">&gt;&gt;&gt; for x in &apos;abc&apos;:</span><br><span class="line">...     for y in &apos;lmn&apos;:</span><br><span class="line">...             res.append(x + y)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; res</span><br><span class="line">[&apos;al&apos;, &apos;am&apos;, &apos;an&apos;, &apos;bl&apos;, &apos;bm&apos;, &apos;bn&apos;, &apos;cl&apos;, &apos;cm&apos;, &apos;cn&apos;]</span><br></pre></td></tr></table></figure>

<p>列表解析表达式中嵌套的<code>for</code>循环可以有一个相关的<code>if</code>子句来过滤测试不为真的结果项</p>
<p>通常可以把列表解析转换为一条<code>for</code>语句,但可能运行起来要慢很多</p>
<p>列表解析可以包含嵌套的循环,也编写一系列的<code>for</code>子句,每个子句有一个可选的<code>if</code>子句</p>
<hr>
<h2 id="其他迭代环境"><a href="#其他迭代环境" class="headerlink" title="其他迭代环境"></a>其他迭代环境</h2><p>实现了迭代协议的任何工具,都能够在提供了该工具的任何内置类型或用户定义的类上自动地工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for line in open(&apos;script1.py&apos;):     # Use file iterators</span><br><span class="line">...     print(line.upper(), end=&apos;&apos;)</span><br><span class="line">... </span><br><span class="line">IMPORT SYS</span><br><span class="line">PRINT(SYS.PATH)</span><br><span class="line">X = 2</span><br><span class="line">PRINT(2 ** 33)</span><br><span class="line">&gt;&gt;&gt; uppers = [line.upper() for line in open(&apos;script1.py&apos;)]</span><br><span class="line">&gt;&gt;&gt; uppers</span><br><span class="line">[&apos;IMPORT SYS\n&apos;, &apos;PRINT(SYS.PATH\n&apos;, &apos;)X = 2\n&apos;, &apos;PRINT(2 ** 33)\n&apos;]</span><br><span class="line">&gt;&gt;&gt; map(str.upper, open(&apos;script1.py&apos;))</span><br><span class="line">&lt;map object at 0x104218828&gt;</span><br><span class="line">&gt;&gt;&gt; list(map(str.upper, open(&apos;script1.py&apos;)))</span><br><span class="line">[&apos;IMPORT SYS\n&apos;, &apos;PRINT(SYS.PATH\n&apos;, &apos;)X = 2\n&apos;, &apos;PRINT(2 ** 33)\n&apos;]</span><br><span class="line">&gt;&gt;&gt; &apos;y = 2\n&apos; in open(&apos;script1.py&apos;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; &apos;x = 2\n&apos; in open(&apos;script1.py&apos;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p><code>for</code>循环、列表解析、<code>in</code>成员关系测试、<code>map</code>内置函数都使用了迭代协议</p>
<p>所有使用文件对象的迭代器都自动地按行扫描</p>
<p><code>map</code>函数把一个函数应用于传入的可迭代对象中的每一项,返回一个可迭代的对象,需要包含到<code>list</code>调用中迫使其一次性给出所有的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted(open(&apos;script1.py&apos;))</span><br><span class="line">[&apos;import sys\n&apos;, &apos;print(2 ** 33)\n&apos;, &apos;print(sys.path)\n&apos;, &apos;x = 2\n&apos;]</span><br><span class="line">&gt;&gt;&gt; list(zip(open(&apos;script1.py&apos;), open(&apos;script1.py&apos;)))</span><br><span class="line">[(&apos;import sys\n&apos;, &apos;import sys\n&apos;), (&apos;print(sys.path)\n&apos;, &apos;print(sys.path)\n&apos;), (&apos;x = 2\n&apos;, &apos;x = 2\n&apos;), (&apos;print(2 ** 33)\n&apos;, &apos;print(2 ** 33)\n&apos;)]</span><br><span class="line">&gt;&gt;&gt; list(enumerate(open(&apos;script1.py&apos;)))</span><br><span class="line">[(0, &apos;import sys\n&apos;), (1, &apos;print(sys.path)\n&apos;), (2, &apos;x = 2\n&apos;), (3, &apos;print(2 ** 33)\n&apos;)]</span><br><span class="line">&gt;&gt;&gt; list(filter(bool,open(&apos;script1.py&apos;)))</span><br><span class="line">[&apos;import sys\n&apos;, &apos;print(sys.path)\n&apos;, &apos;x = 2\n&apos;, &apos;print(2 ** 33)\n&apos;]</span><br><span class="line">&gt;&gt;&gt; import functools,operator</span><br><span class="line">&gt;&gt;&gt; functools.reduce(operator.add, open(&apos;script1.py&apos;))</span><br><span class="line">&apos;import sys\nprint(sys.path)\nx = 2\nprint(2 ** 33)\n&apos;</span><br></pre></td></tr></table></figure>

<p><code>sorted</code>函数接受任何可迭代的对象并返回一个新的排序的列表作为结果</p>
<p><code>zip</code>组合多个可迭代对象中的各项</p>
<p><code>enumerate</code>返回可迭代对象中的偏移与项</p>
<p><code>filter</code>选择一个函数返回为真的项</p>
<p><code>reduce</code>针对可迭代对象中的成对的项运行一个函数</p>
<p>这些函数都接受一个可迭代对象,<code>zip</code>、<code>enumerate</code>和<code>filter</code>返回一个可迭代对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sum([3, 2, 4, 1, 5, 0]) # sum expects numbers only</span><br><span class="line">15</span><br><span class="line">&gt;&gt;&gt; any([&apos;spam&apos;, &apos;&apos;, &apos;ni&apos;])</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; all([&apos;spam&apos;, &apos;&apos;, &apos;ni&apos;])</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; max([3, 2, 5, 1, 4])</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; min([3, 2, 5, 1, 5])</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; max(open(&apos;script1.py&apos;)) # Line with max/min string value</span><br><span class="line">&apos;x = 2\n&apos;</span><br><span class="line">&gt;&gt;&gt; min(open(&apos;script1.py&apos;))</span><br><span class="line">&apos;import sys\n&apos;</span><br></pre></td></tr></table></figure>

<p><code>sum</code>函数计算任何可迭代对象中的总数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">any`函数在一个可迭代对象中任何的项为真时返回`True</span><br><span class="line">all`函数在一个可迭代对象中所有的项为真时返回`True</span><br></pre></td></tr></table></figure>

<p><code>max</code>和<code>min</code>函数分别返回一个可迭代对象中的最大和最小的项,当对象为文件时返回具有最高的和最低的字符串值的行</p>
<p>他们都接受任何一个可迭代的对象作为一个参数,并且使用迭代协议来扫描它,但返回单个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(open(&apos;script1.py&apos;))</span><br><span class="line">[&apos;import sys\n&apos;, &apos;print(sys.path)\n&apos;, &apos;x = 2\n&apos;, &apos;print(2 ** 33)\n&apos;]</span><br><span class="line">&gt;&gt;&gt; tuple(open(&apos;script1.py&apos;))</span><br><span class="line">(&apos;import sys\n&apos;, &apos;print(sys.path)\n&apos;, &apos;x = 2\n&apos;, &apos;print(2 ** 33)\n&apos;)</span><br><span class="line">&gt;&gt;&gt; &apos;&amp;&amp;&apos;.join(open(&apos;script1.py&apos;))</span><br><span class="line">&apos;import sys\n&amp;&amp;print(sys.path)\n&amp;&amp;x = 2\n&amp;&amp;print(2 ** 33)\n&apos;</span><br><span class="line">&gt;&gt;&gt; a, b, c, d = open(&apos;script1.py&apos;)</span><br><span class="line">&gt;&gt;&gt; a, d</span><br><span class="line">(&apos;import sys\n&apos;, &apos;print(2 ** 33)\n&apos;)</span><br><span class="line">&gt;&gt;&gt; a, *b = open(&apos;script1.py&apos;)      # 3.0 extended form</span><br><span class="line">&gt;&gt;&gt; a, b</span><br><span class="line">(&apos;import sys\n&apos;, [&apos;print(sys.path)\n&apos;, &apos;x = 2\n&apos;, &apos;print(2 ** 33)\n&apos;])</span><br></pre></td></tr></table></figure>

<p>所有从左到右地扫描一个传入的对象的工具都使用了迭代协议</p>
<p><code>list</code>和<code>tuple</code>内置函数从可迭代对象构建了一个新的对象</p>
<p><code>dict</code>函数接收一个可迭代的<code>zip</code>结果</p>
<p><code>str.join</code>方法将一个子字符串放置到一个可迭代对象中所有的字符串项之间</p>
<p>序列赋值从左到右扫描对象进行赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; set(open(&apos;script1.py&apos;))</span><br><span class="line">&#123;&apos;print(2 ** 33)\n&apos;, &apos;import sys\n&apos;, &apos;print(sys.path)\n&apos;, &apos;x = 2\n&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; &#123;line for line in open(&apos;script1.py&apos;)&#125;</span><br><span class="line">&#123;&apos;print(2 ** 33)\n&apos;, &apos;import sys\n&apos;, &apos;print(sys.path)\n&apos;, &apos;x = 2\n&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; &#123;ix: line for ix, line in enumerate(open(&apos;script1.py&apos;))&#125;</span><br><span class="line">&#123;0: &apos;import sys\n&apos;, 1: &apos;print(sys.path)\n&apos;, 2: &apos;x = 2\n&apos;, 3: &apos;print(2 ** 33)\n&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; &#123;line for line in open(&apos;script1.py&apos;) if line[0] == &apos;p&apos;&#125;</span><br><span class="line">&#123;&apos;print(2 ** 33)\n&apos;, &apos;print(sys.path)\n&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; &#123;ix: line for ix, line in enumerate(open(&apos;script1.py&apos;)) if line[0] == &apos;p&apos;&#125;</span><br><span class="line">&#123;1: &apos;print(sys.path)\n&apos;, 3: &apos;print(2 ** 33)\n&apos;&#125;</span><br></pre></td></tr></table></figure>

<p>集合解析和字典解析与列表解析一样,都支持列表解析的拓展语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(a, b, c, d): print(a, b, c, d, sep=&apos;&amp;&apos;)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; f(1, 2, 3, 4)</span><br><span class="line">1&amp;2&amp;3&amp;4</span><br><span class="line">&gt;&gt;&gt; f(*[1, 2, 3, 4])            # Unpackeds into arguments</span><br><span class="line">1&amp;2&amp;3&amp;4</span><br><span class="line">&gt;&gt;&gt; f(*open(&apos;script1.py&apos;))      # Iterates by lines too!</span><br><span class="line">import sys</span><br><span class="line">&amp;print(sys.path)</span><br><span class="line">&amp;x = 2</span><br><span class="line">&amp;print(2 ** 33)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; X = (1, 2)</span><br><span class="line">&gt;&gt;&gt; Y = (3, 4)</span><br><span class="line">&gt;&gt;&gt; list(zip(X, Y))             # Zip tiples:returns an iterable</span><br><span class="line">[(1, 3), (2, 4)]</span><br><span class="line">&gt;&gt;&gt; A, B = zip(*zip(X, Y))      # Unzip a zip!</span><br><span class="line">&gt;&gt;&gt; A</span><br><span class="line">(1, 2)</span><br><span class="line">&gt;&gt;&gt; B</span><br><span class="line">(3, 4)</span><br></pre></td></tr></table></figure>

<p>函数调用中参数的特殊形式<code>*arg</code>接收任何可迭代对象,把一个集合的值解包为单个的参数</p>
<p><code>*</code>将一个可迭代对象解包,使用<code>zip</code>函数可以重新组合</p>
<hr>
<h2 id="Python-3-0中的新的可迭代对象"><a href="#Python-3-0中的新的可迭代对象" class="headerlink" title="Python 3.0中的新的可迭代对象"></a>Python 3.0中的新的可迭代对象</h2><p>字典方法<code>keys</code>、<code>values</code>和<code>items</code>与内置函数<code>range</code>、<code>map</code>、<code>zip</code>和<code>filter</code>都处理可迭代对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; zip(&apos;abc&apos;, &apos;xyz&apos;)           # An iterable in Python 3.0</span><br><span class="line">&lt;zip object at 0x104717e88&gt;</span><br><span class="line">&gt;&gt;&gt; list(zip(&apos;abc&apos;, &apos;xyz&apos;))     # Force list of results in 3.0 to display</span><br><span class="line">[(&apos;a&apos;, &apos;x&apos;), (&apos;b&apos;, &apos;y&apos;), (&apos;c&apos;, &apos;z&apos;)]</span><br></pre></td></tr></table></figure>

<p>在Python 3.0中,这些函数返回可迭代的对象,根据需要产生结果,可以节约内存,但是显示结果需要额外的录入</p>
<h3 id="range迭代器"><a href="#range迭代器" class="headerlink" title="range迭代器"></a>range迭代器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; R = range(10)       # range returns an iterator,not a list </span><br><span class="line">&gt;&gt;&gt; R</span><br><span class="line">range(0, 10)</span><br><span class="line">&gt;&gt;&gt; I = iter(R)         # Make an iterator from the range</span><br><span class="line">&gt;&gt;&gt; next(I)             # Advance to next result</span><br><span class="line">0                       # What happens in for loops:conprehensions,etc</span><br><span class="line">&gt;&gt;&gt; next(I)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(I)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; list(range(10))     # To force a listof </span><br><span class="line">range(0, 10)</span><br><span class="line">&gt;&gt;&gt; len(R)              # range also does len and indexing,but no others</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; R[0]</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; R[-1]</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; next(I)             # Continue taking from interator,where left off</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; I.__next__()</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p><code>range</code>内置函数返回一个迭代器,根据需要产生范围的数字</p>
<p><code>range</code>对象只支持迭代、索引和<code>len</code>函数</p>
<p>使用<code>list(range(...))</code>强制产生一个真正的范围列表</p>
<h3 id="map、zip和filter迭代器"><a href="#map、zip和filter迭代器" class="headerlink" title="map、zip和filter迭代器"></a>map、zip和filter迭代器</h3><p><code>map</code>、<code>zip</code>以及<code>filiter</code>内置函数步进处理可迭代对象,而且在Python 3.0中返回一个迭代器而不再在内存中一次性生成一个结果列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; M = map(abs, (-1, 0, 1))        # map returns an iterator,not a list</span><br><span class="line">&gt;&gt;&gt; M</span><br><span class="line">&lt;map object at 0x10421e0f0&gt;</span><br><span class="line">&gt;&gt;&gt; next(M)                         # Use iterator manually:exhausts results</span><br><span class="line">1                                   # These do not support len() or indexing</span><br><span class="line">&gt;&gt;&gt; next(M)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(M)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(M)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt; for x in M: print(x)            # map iterator is now empty:ont pass only</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; M = map(abs, (-1, 0, 1))        # Make a new iterator to scan again</span><br><span class="line">&gt;&gt;&gt; for x in M: print(x)            # Iteration contexts auto call next()</span><br><span class="line">... </span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; list(map(abs, (-1, 0, 1)))      # Can force a real list if needed</span><br><span class="line">[1, 0, 1]</span><br><span class="line">&gt;&gt;&gt; Z = zip((1, 2, 3),(10, 20, 30)) # zip is the same:a one-pass iterator</span><br><span class="line">&gt;&gt;&gt; Z</span><br><span class="line">&lt;zip object at 0x10421a508&gt;</span><br><span class="line">&gt;&gt;&gt; list(Z)</span><br><span class="line">[(1, 10), (2, 20), (3, 30)]</span><br><span class="line">&gt;&gt;&gt; for pair in Z: print(pair)      # Exhausted after one pass</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; Z = zip((1, 2, 3),(10, 20, 30))</span><br><span class="line">&gt;&gt;&gt; for pair in Z: print(pair)      # Iterator used automatically or manually</span><br><span class="line">... </span><br><span class="line">(1, 10)</span><br><span class="line">(2, 20)</span><br><span class="line">(3, 30)</span><br><span class="line">&gt;&gt;&gt; Z = zip((1, 2, 3),(10, 20, 30))</span><br><span class="line">&gt;&gt;&gt; next(Z)</span><br><span class="line">(1, 10)</span><br><span class="line">&gt;&gt;&gt; next(Z)</span><br><span class="line">(2, 20)</span><br><span class="line">&gt;&gt;&gt; filter(bool, [&apos;spam&apos;, &apos;&apos;, &apos;ni&apos;])</span><br><span class="line">&lt;filter object at 0x10474ff98&gt;</span><br><span class="line">&gt;&gt;&gt; list(filter(bool, [&apos;spam&apos;, &apos;&apos;, &apos;ni&apos;]))</span><br><span class="line">[&apos;spam&apos;, &apos;ni&apos;]</span><br></pre></td></tr></table></figure>

<p>与<code>range</code>需要手动使用<code>iter</code>产生一个迭代器不同,这些函数都是自己的迭代器,在遍历其结果一遍后就用尽</p>
<h3 id="多个迭代器-VS-单个迭代器"><a href="#多个迭代器-VS-单个迭代器" class="headerlink" title="多个迭代器 VS 单个迭代器"></a>多个迭代器 VS 单个迭代器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; R = range(3)                    # range allows multiple iterators</span><br><span class="line">&gt;&gt;&gt; next(R)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &apos;range&apos; object is not an iterator</span><br><span class="line">&gt;&gt;&gt; I1 = iter(R)</span><br><span class="line">&gt;&gt;&gt; next(I1)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(I1)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; I2 = iter(R)                    # Two iterators on one range</span><br><span class="line">&gt;&gt;&gt; next(I2)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(I2)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(I1)                        # I1 is at a different spot than 12</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; Z = zip((1, 2, 3), (10, 11, 12))</span><br><span class="line">&gt;&gt;&gt; I1 = iter(Z)</span><br><span class="line">&gt;&gt;&gt; I2 = iter(Z)</span><br><span class="line">&gt;&gt;&gt; next(I1)</span><br><span class="line">(1, 10)</span><br><span class="line">&gt;&gt;&gt; next(I1)</span><br><span class="line">(2, 11)</span><br><span class="line">&gt;&gt;&gt; next(I2)                        # I2 is same spot as I1</span><br><span class="line">(3, 12)</span><br><span class="line">&gt;&gt;&gt; M = map(abs, (-1, 0, 1))        # Ditto for map(and filter)</span><br><span class="line">&gt;&gt;&gt; I1 = iter(M); I2 = iter(M)</span><br><span class="line">&gt;&gt;&gt; print(next(I1), next(I1), next(I1))</span><br><span class="line">1 0 1</span><br><span class="line">&gt;&gt;&gt; next(I2)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt; R = range(3)                    # But range allows many iterators</span><br><span class="line">&gt;&gt;&gt; I1, I2 = iter(R), iter(R)</span><br><span class="line">&gt;&gt;&gt; [next(I1), next(I1), next(I1)]</span><br><span class="line">[0 1 2]</span><br><span class="line">&gt;&gt;&gt; next(I2)</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><code>range</code>支持<code>len</code>和索引,它不是自己的迭代器(手动迭代时,使用<code>iter</code>产生一个迭代器),并且支持将其结果作为多个迭代器</p>
<p><code>zip</code>、<code>map</code>和<code>filter</code>则不支持相同结果上的多个活跃迭代器</p>
<h3 id="字典视图迭代器"><a href="#字典视图迭代器" class="headerlink" title="字典视图迭代器"></a>字典视图迭代器</h3><p>在Python 3.0中,字典的<code>keys</code>、<code>values</code>和<code>items</code>方法返回可迭代的视图对象,它们一次产生一个结果项,而不是在内存中一次产生全部结果列表</p>
<p>视图项保持和字典中的那些项相同的物理顺序,并且可以对底层的字典做出的修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; D = dict(a=1, b=2, c=3)</span><br><span class="line">&gt;&gt;&gt; D</span><br><span class="line">&#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; K = D.keys()                            # A view object in 3.0,not a list</span><br><span class="line">&gt;&gt;&gt; K</span><br><span class="line">dict_keys([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])</span><br><span class="line">&gt;&gt;&gt; next(K)                                 # Views are not iterators themselves</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &apos;dict_keys&apos; object is not an iterator</span><br><span class="line">&gt;&gt;&gt; I = iter(K)                             # Views have an iterator.</span><br><span class="line">&gt;&gt;&gt; next(I)                                 # which can be used manually</span><br><span class="line">&apos;a&apos;                                         # but does not support len(),index</span><br><span class="line">&gt;&gt;&gt; next(I)</span><br><span class="line">&apos;b&apos;</span><br><span class="line">&gt;&gt;&gt; for k in D.keys(): print(k, end=&apos; &apos;)    # All iteration contexts use auto</span><br><span class="line">... </span><br><span class="line">a b c</span><br><span class="line">&gt;&gt;&gt; K = D.keys()</span><br><span class="line">&gt;&gt;&gt; list(K)                                 # Can still force a real list if needed</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">&gt;&gt;&gt; V = D.values()                          # Ditto for values() and items() views</span><br><span class="line">&gt;&gt;&gt; V</span><br><span class="line">dict_values([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; list(V)</span><br><span class="line">[1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; list(D.items())</span><br><span class="line">[(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 3)]</span><br><span class="line">&gt;&gt;&gt; for (k,v) in D.items(): print(k, v, end=&apos; &apos;)</span><br><span class="line">... </span><br><span class="line">a 1 b 2 c 3</span><br><span class="line">&gt;&gt;&gt; I = iter(D)                             # Dictionaries still have own iterator</span><br><span class="line">&gt;&gt;&gt; next(I)                                 # Returns next key on each iteration</span><br><span class="line">&apos;a&apos;</span><br><span class="line">&gt;&gt;&gt; next(I)</span><br><span class="line">&apos;b&apos;</span><br><span class="line">&gt;&gt;&gt; for key in D: print(key, end=&apos; &apos;)       # Still no need to call keys() to iterate</span><br><span class="line">...                                         # But keys is an iterator in 3.0 too!</span><br><span class="line">a b c</span><br></pre></td></tr></table></figure>

<p>字典视图可以传递到<code>list</code>函数中,强制构建一个真正的列表</p>
<p>字典有自己的迭代器,可以返回连续的键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; D = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; for k in sorted(D.keys()): print(k, D[k], end=&apos; &apos;)</span><br><span class="line">... </span><br><span class="line">a 1 b 2 c 3</span><br><span class="line">&gt;&gt;&gt; D</span><br><span class="line">&#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; for k in sorted(D):print(k, D[k], end=&apos; &apos;)</span><br><span class="line">... </span><br><span class="line">a 1 b 2 c 3</span><br></pre></td></tr></table></figure>

<p>无法按照排序的键返回一个字典,可以用一个<code>list</code>调用来转换<code>keys</code>视图,或者在一个键视图或字典自身上使用<code>sorted</code>调用</p>
<hr>
<h2 id="其他迭代器主题"><a href="#其他迭代器主题" class="headerlink" title="其他迭代器主题"></a>其他迭代器主题</h2><blockquote>
<ul>
<li>使用yield语句,用户定义的函数可以转换为可迭代的生成器函数</li>
<li>当编写在圆括号中的时候,列表解析转变为可迭代的生成器表达式</li>
<li>用户定义的类通过<code>__iter__</code>或<code>__getitem__</code>运算符重载变得可迭代</li>
</ul>
</blockquote>
<hr>
<h2 id="本章习题-4"><a href="#本章习题-4" class="headerlink" title="本章习题"></a>本章习题</h2><ol>
<li><p><code>for</code>循环和迭代器之间有什么关系</p>
<blockquote>
<p><code>for</code>循环会使用迭代协议来遍历迭代对象中的每一个项</p>
<p><code>for</code>循环会在每次迭代中调用该对象的<code>__next__</code>方法(由<code>next</code>内置函数运行),而且会捕捉<code>StopIteration</code> 异常,从而决定何时停止循环</p>
<p>支持这种模式的任何对象,都可以用于<code>for</code>循环以及其他迭代环境中</p>
</blockquote>
</li>
<li><p><code>for</code>循环和列表解析直接有什么关系</p>
<blockquote>
<p>两者都是迭代工具</p>
<p>列表解析是执行常见<code>for</code>循环任务的简明并且高效的方法:对可迭代对象内所有元素应用一个表达式,并收集其结果</p>
<p>可以把列表解析转换成for循环,而列表解析表达式的一部分的语法看起来就像是for循环的首行</p>
</blockquote>
</li>
<li><p>举出Python中的4种迭代环境</p>
<blockquote>
<p>Python中的迭代环境包括<code>for</code>循环、列表解析、<code>map</code>内置函数、<code>in</code>成员关系测试表达式以及内置函数<code>sorted</code>、<code>sum</code>、<code>any</code>和<code>all</code></p>
<p>这个分类也包括了内置函数<code>list</code>和<code>tuple</code>、字符串<code>join</code>方法以及序列赋值运算</p>
<p>所有这些都使用了迭代协议(<code>next</code>方法)来一次一个元素逐个遍历可迭代对象</p>
</blockquote>
</li>
<li><p>如今从一个文本文件逐行读取行的最好的方法是什么</p>
<blockquote>
<p>如今从文本文件中读取文本行的最佳方式是不要刻意去读取:其替代方法是,在迭代环境中打开文件,诸如<code>for</code>循环或列表解析中,然后,让迭代工具在每次迭代中执行该文件的next方法,自动一次扫描一行</p>
<p>从代码编写的简易性、执行速度以及内存空间需求等方面来看,这种做法通常都是最佳方式</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="第十五章-文档"><a href="#第十五章-文档" class="headerlink" title="第十五章 文档"></a>第十五章 文档</h1><blockquote>
<ul>
<li>本章介绍程序的文档概念</li>
<li>认识了文档字符串</li>
<li>探索Python的在线手册</li>
<li>学习PyDoc的help函数和网页接口如何提供额外的文档来源</li>
<li>复习常见的编写代码的错误</li>
</ul>
</blockquote>
<hr>
<h2 id="Python文档资源"><a href="#Python文档资源" class="headerlink" title="Python文档资源"></a>Python文档资源</h2><p>Python预置的功能数量惊人:内置函数和异常、预先定义的对象属性和方法、标准库模块</p>
<p>Python文档资源</p>
<table>
<thead>
<tr>
<th>形式</th>
<th>角色</th>
</tr>
</thead>
<tbody><tr>
<td>#注释</td>
<td>文件中的文档</td>
</tr>
<tr>
<td>dir函数</td>
<td>对象中可用属性的列表</td>
</tr>
<tr>
<td>文档字符串：_<em>doc_</em></td>
<td>附加在对象上的文件中的文档</td>
</tr>
<tr>
<td>PyDoc:help函数</td>
<td>对象的交互帮助</td>
</tr>
<tr>
<td>PyDoc:HTML报表</td>
<td>浏览器中的模块文档</td>
</tr>
<tr>
<td>标准手册</td>
<td>正式的语言和库的说明</td>
</tr>
<tr>
<td>网站资源</td>
<td>在线教程、例子等</td>
</tr>
<tr>
<td>出版的书籍</td>
<td>商业参考书籍</td>
</tr>
</tbody></table>
<h3 id="注释"><a href="#注释" class="headerlink" title="#注释"></a>#注释</h3><p><code>#</code>注释是代码编写文档的最基本方式</p>
<p>Python会忽略<code>#</code>之后所有文字(只要<code>#</code>不是位于字符串常量中),可以在<code>#</code>插入一些对程序员有意义的文字和说<br>明</p>
<p>不过这类注释只能从源代码文件中看到</p>
<h3 id="dir函数"><a href="#dir函数" class="headerlink" title="dir函数"></a>dir函数</h3><p>内置的dir函数是抓取对象内可用所有属性列表的简单方式,它能够调用任何有属性的对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(sys)</span><br><span class="line">[<span class="string">'__displayhook__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__excepthook__'</span>, <span class="string">'__interactivehook__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'__stderr__'</span>, <span class="string">'__stdin__'</span>, <span class="string">'__stdout__'</span>, <span class="string">'_clear_type_cache'</span>, <span class="string">'_current_frames'</span>, <span class="string">'_debugmallocstats'</span>, <span class="string">'_getframe'</span>, <span class="string">'_git'</span>, <span class="string">'_home'</span>, <span class="string">'_xoptions'</span>, <span class="string">'abiflags'</span>, <span class="string">'api_version'</span>, <span class="string">'argv'</span>, <span class="string">'base_exec_prefix'</span>, <span class="string">'base_prefix'</span>, <span class="string">'builtin_module_names'</span>, <span class="string">'byteorder'</span>, <span class="string">'call_tracing'</span>, <span class="string">'callstats'</span>, <span class="string">'copyright'</span>, <span class="string">'displayhook'</span>, <span class="string">'dont_write_bytecode'</span>, <span class="string">'exc_info'</span>, <span class="string">'excepthook'</span>, <span class="string">'exec_prefix'</span>, <span class="string">'executable'</span>, <span class="string">'exit'</span>, <span class="string">'flags'</span>, <span class="string">'float_info'</span>, <span class="string">'float_repr_style'</span>, <span class="string">'get_asyncgen_hooks'</span>, <span class="string">'get_coroutine_wrapper'</span>, <span class="string">'getallocatedblocks'</span>, <span class="string">'getcheckinterval'</span>, <span class="string">'getdefaultencoding'</span>, <span class="string">'getdlopenflags'</span>, <span class="string">'getfilesystemencodeerrors'</span>, <span class="string">'getfilesystemencoding'</span>, <span class="string">'getprofile'</span>, <span class="string">'getrecursionlimit'</span>, <span class="string">'getrefcount'</span>, <span class="string">'getsizeof'</span>, <span class="string">'getswitchinterval'</span>, <span class="string">'gettrace'</span>, <span class="string">'hash_info'</span>, <span class="string">'hexversion'</span>, <span class="string">'implementation'</span>, <span class="string">'int_info'</span>, <span class="string">'intern'</span>, <span class="string">'is_finalizing'</span>, <span class="string">'last_traceback'</span>, <span class="string">'last_type'</span>, <span class="string">'last_value'</span>, <span class="string">'maxsize'</span>, <span class="string">'maxunicode'</span>, <span class="string">'meta_path'</span>, <span class="string">'modules'</span>, <span class="string">'path'</span>, <span class="string">'path_hooks'</span>, <span class="string">'path_importer_cache'</span>, <span class="string">'platform'</span>, <span class="string">'prefix'</span>, <span class="string">'ps1'</span>, <span class="string">'ps2'</span>, <span class="string">'set_asyncgen_hooks'</span>, <span class="string">'set_coroutine_wrapper'</span>, <span class="string">'setcheckinterval'</span>, <span class="string">'setdlopenflags'</span>, <span class="string">'setprofile'</span>, <span class="string">'setrecursionlimit'</span>, <span class="string">'setswitchinterval'</span>, <span class="string">'settrace'</span>, <span class="string">'stderr'</span>, <span class="string">'stdin'</span>, <span class="string">'stdout'</span>, <span class="string">'thread_info'</span>, <span class="string">'version'</span>, <span class="string">'version_info'</span>, <span class="string">'warnoptions'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir([])</span><br><span class="line">[<span class="string">'__add__'</span>, <span class="string">'__class__'</span>, <span class="string">'__contains__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__delitem__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getitem__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__iadd__'</span>, <span class="string">'__imul__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__le__'</span>, <span class="string">'__len__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__mul__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__reversed__'</span>, <span class="string">'__rmul__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__setitem__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'append'</span>, <span class="string">'clear'</span>, <span class="string">'copy'</span>, <span class="string">'count'</span>, <span class="string">'extend'</span>, <span class="string">'index'</span>, <span class="string">'insert'</span>, <span class="string">'pop'</span>, <span class="string">'remove'</span>, <span class="string">'reverse'</span>, <span class="string">'sort'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(<span class="string">''</span>)</span><br><span class="line">[<span class="string">'__add__'</span>, <span class="string">'__class__'</span>, <span class="string">'__contains__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getitem__'</span>, <span class="string">'__getnewargs__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__le__'</span>, <span class="string">'__len__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__mod__'</span>, <span class="string">'__mul__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__rmod__'</span>, <span class="string">'__rmul__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'capitalize'</span>, <span class="string">'casefold'</span>, <span class="string">'center'</span>, <span class="string">'count'</span>, <span class="string">'encode'</span>, <span class="string">'endswith'</span>, <span class="string">'expandtabs'</span>, <span class="string">'find'</span>, <span class="string">'format'</span>, <span class="string">'format_map'</span>, <span class="string">'index'</span>, <span class="string">'isalnum'</span>, <span class="string">'isalpha'</span>, <span class="string">'isdecimal'</span>, <span class="string">'isdigit'</span>, <span class="string">'isidentifier'</span>, <span class="string">'islower'</span>, <span class="string">'isnumeric'</span>, <span class="string">'isprintable'</span>, <span class="string">'isspace'</span>, <span class="string">'istitle'</span>, <span class="string">'isupper'</span>, <span class="string">'join'</span>, <span class="string">'ljust'</span>, <span class="string">'lower'</span>, <span class="string">'lstrip'</span>, <span class="string">'maketrans'</span>, <span class="string">'partition'</span>, <span class="string">'replace'</span>, <span class="string">'rfind'</span>, <span class="string">'rindex'</span>, <span class="string">'rjust'</span>, <span class="string">'rpartition'</span>, <span class="string">'rsplit'</span>, <span class="string">'rstrip'</span>, <span class="string">'split'</span>, <span class="string">'splitlines'</span>, <span class="string">'startswith'</span>, <span class="string">'strip'</span>, <span class="string">'swapcase'</span>, <span class="string">'title'</span>, <span class="string">'translate'</span>, <span class="string">'upper'</span>, <span class="string">'zfill'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(str) == dir(<span class="string">''</span>)		<span class="comment"># Same  result as prior example</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(list) == dir([])</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>可以显示模块的诸多变量名</p>
<p>可以为<code>dir</code>传入所需<strong>类型的常量</strong>或<strong>类型的名称</strong>找出内置对象提供的属性,任何内置类型的<code>dir</code>结果都包含了一组属性,这些属性与该类型的实现相关</p>
<h3 id="文档字符串-doc"><a href="#文档字符串-doc" class="headerlink" title="文档字符串:_doc_"></a>文档字符串:_<em>doc_</em></h3><p>Python支持自动附加在对象上的文档,运行时可以查看保存</p>
<p>文档字符串是写成字符串,放在模块文件、函数以及类语句的顶端的注释</p>
<p>Python自动封装文档字符串,使其成为相应对象的__doc__属性</p>
<h4 id="用户定义的文档字符串"><a href="#用户定义的文档字符串" class="headerlink" title="用户定义的文档字符串"></a>用户定义的文档字符串</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Module documentation</span></span><br><span class="line"><span class="string">Words Go Here</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">spam = <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	function documentation</span></span><br><span class="line"><span class="string">	can we have your liver then?</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="keyword">return</span> x ** <span class="number">2</span>		<span class="comment"># square</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">	<span class="string">"class documentation"</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(square(<span class="number">4</span>))</span><br><span class="line">print(square.__doc__)</span><br></pre></td></tr></table></figure>

<p>文档字符串出现在文件开端以及其中的函数和类的开头</p>
<p>文档协议的重点在于注释会保存在<code>__doc__</code>属性中以供查看</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> docstrings</span><br><span class="line"><span class="number">16</span></span><br><span class="line"></span><br><span class="line">	function documentation</span><br><span class="line">	can we have your liver then?</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(docstrings.__doc__)</span><br><span class="line"></span><br><span class="line">Module documentation</span><br><span class="line">Words Go Here</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(docstrings.square.__doc__)</span><br><span class="line"></span><br><span class="line">	function documentation</span><br><span class="line">	can we have your liver then?</span><br><span class="line">	</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(docstringstest4.Employee.__doc__)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">documentation</span></span></span><br></pre></td></tr></table></figure>

<p>导入文件并打印其<code>__doc__</code>属性可以显示模块以及对象关联的文档字符串</p>
<p>可以通过路径访问类<code>module.class.method.__doc__</code></p>
<h4 id="文档字符串标准"><a href="#文档字符串标准" class="headerlink" title="文档字符串标准"></a>文档字符串标准</h4><p>文档字符串的结构没有标准</p>
<p>现在有各种标记语言和末班协议(HTML或XML)</p>
<h4 id="内置文档字符串"><a href="#内置文档字符串" class="headerlink" title="内置文档字符串"></a>内置文档字符串</h4><p>Python内置模块和对象都可以查看可读的说明信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sys.__doc__)</span><br><span class="line">This module provides access to some objects used <span class="keyword">or</span> maintained by the</span><br><span class="line">interpreter <span class="keyword">and</span> to functions that interact strongly <span class="keyword">with</span> the interpreter.</span><br><span class="line"></span><br><span class="line">Dynamic objects:</span><br><span class="line"></span><br><span class="line">argv -- command line arguments; argv[<span class="number">0</span>] <span class="keyword">is</span> the script pathname <span class="keyword">if</span> known</span><br><span class="line">path -- module search path; path[<span class="number">0</span>] <span class="keyword">is</span> the script directory, <span class="keyword">else</span> <span class="string">''</span></span><br><span class="line">modules -- dictionary of loaded modules</span><br><span class="line"></span><br><span class="line">displayhook -- called to show results <span class="keyword">in</span> an interactive session</span><br><span class="line">excepthook -- called to handle any uncaught exception other than SystemExit</span><br><span class="line">  To customize printing <span class="keyword">in</span> an interactive session <span class="keyword">or</span> to install a custom</span><br><span class="line">  top-level exception handler, assign other functions to replace these.</span><br><span class="line"></span><br><span class="line">stdin -- standard input file object; used by input()</span><br><span class="line">stdout -- standard output file object; used by print()</span><br><span class="line">stderr -- standard error object; used <span class="keyword">for</span> error messages</span><br><span class="line">  By assigning other file objects (<span class="keyword">or</span> objects that behave like files)</span><br><span class="line">  to these, it <span class="keyword">is</span> possible to redirect all of the interprete<span class="string">r's I/O.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">last_type -- type of last uncaught exception</span></span><br><span class="line"><span class="string">last_value -- value of last uncaught exception</span></span><br><span class="line"><span class="string">last_traceback -- traceback of last uncaught exception</span></span><br><span class="line"><span class="string">  These three are only available in an interactive session after a</span></span><br><span class="line"><span class="string">  traceback has been printed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Static objects:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">builtin_module_names -- tuple of module names built into this interpreter</span></span><br><span class="line"><span class="string">copyright -- copyright notice pertaining to this interpreter</span></span><br><span class="line"><span class="string">exec_prefix -- prefix used to find the machine-specific Python library</span></span><br><span class="line"><span class="string">executable -- absolute path of the executable binary of the Python interpreter</span></span><br><span class="line"><span class="string">float_info -- a struct sequence with information about the float implementation.</span></span><br><span class="line"><span class="string">float_repr_style -- string indicating the style of repr() output for floats</span></span><br><span class="line"><span class="string">hash_info -- a struct sequence with information about the hash algorithm.</span></span><br><span class="line"><span class="string">hexversion -- version information encoded as a single integer</span></span><br><span class="line"><span class="string">implementation -- Python implementation information.</span></span><br><span class="line"><span class="string">int_info -- a struct sequence with information about the int implementation.</span></span><br><span class="line"><span class="string">maxsize -- the largest supported length of containers.</span></span><br><span class="line"><span class="string">maxunicode -- the value of the largest Unicode code point</span></span><br><span class="line"><span class="string">platform -- platform identifier</span></span><br><span class="line"><span class="string">prefix -- prefix used to find the Python library</span></span><br><span class="line"><span class="string">thread_info -- a struct sequence with information about the thread implementation.</span></span><br><span class="line"><span class="string">version -- the version of this interpreter as a string</span></span><br><span class="line"><span class="string">version_info -- version information as a named tuple</span></span><br><span class="line"><span class="string">__stdin__ -- the original stdin; don'</span>t touch!</span><br><span class="line">__stdout__ -- the original stdout; don<span class="string">'t touch!</span></span><br><span class="line"><span class="string">__stderr__ -- the original stderr; don'</span>t touch!</span><br><span class="line">__displayhook__ -- the original displayhook; don<span class="string">'t touch!</span></span><br><span class="line"><span class="string">__excepthook__ -- the original excepthook; don'</span>t touch!</span><br><span class="line"></span><br><span class="line">Functions:</span><br><span class="line"></span><br><span class="line">displayhook() -- <span class="keyword">print</span> an object to the screen, <span class="keyword">and</span> save it <span class="keyword">in</span> builtins._</span><br><span class="line">excepthook() -- <span class="keyword">print</span> an exception <span class="keyword">and</span> its traceback to sys.stderr</span><br><span class="line">exc_info() -- <span class="keyword">return</span> thread-safe information about the current exception</span><br><span class="line">exit() -- exit the interpreter by raising SystemExit</span><br><span class="line">getdlopenflags() -- returns flags to be used <span class="keyword">for</span> dlopen() calls</span><br><span class="line">getprofile() -- get the <span class="keyword">global</span> profiling function</span><br><span class="line">getrefcount() -- <span class="keyword">return</span> the reference count <span class="keyword">for</span> an object (plus one :-)</span><br><span class="line">getrecursionlimit() -- <span class="keyword">return</span> the max recursion depth <span class="keyword">for</span> the interpreter</span><br><span class="line">getsizeof() -- <span class="keyword">return</span> the size of an object <span class="keyword">in</span> bytes</span><br><span class="line">gettrace() -- get the <span class="keyword">global</span> debug tracing function</span><br><span class="line">setcheckinterval() -- control how often the interpreter checks <span class="keyword">for</span> events</span><br><span class="line">setdlopenflags() -- set the flags to be used <span class="keyword">for</span> dlopen() calls</span><br><span class="line">setprofile() -- set the <span class="keyword">global</span> profiling function</span><br><span class="line">setrecursionlimit() -- set the max recursion depth <span class="keyword">for</span> the interpreter</span><br><span class="line">settrace() -- set the <span class="keyword">global</span> debug tracing function</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sys.getrefcount.__doc__)</span><br><span class="line">getrefcount(object) -&gt; integer</span><br><span class="line"></span><br><span class="line">Return the reference count of object.  The count returned <span class="keyword">is</span> generally</span><br><span class="line">one higher than you might expect, because it includes the (temporary)</span><br><span class="line">reference <span class="keyword">as</span> an argument to getrefcount().</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(int.__doc__)</span><br><span class="line">int(x=0) -&gt; integer</span><br><span class="line">int(x, base=10) -&gt; integer</span><br><span class="line"></span><br><span class="line">Convert a number <span class="keyword">or</span> string to an integer, <span class="keyword">or</span> <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> no arguments</span><br><span class="line">are given.  If x <span class="keyword">is</span> a number, <span class="keyword">return</span> x.__int__().  For floating point</span><br><span class="line">numbers, this truncates towards zero.</span><br><span class="line"></span><br><span class="line">If x <span class="keyword">is</span> <span class="keyword">not</span> a number <span class="keyword">or</span> <span class="keyword">if</span> base <span class="keyword">is</span> given, then x must be a string,</span><br><span class="line">bytes, <span class="keyword">or</span> bytearray instance representing an integer literal <span class="keyword">in</span> the</span><br><span class="line">given base.  The literal can be preceded by <span class="string">'+'</span> <span class="keyword">or</span> <span class="string">'-'</span> <span class="keyword">and</span> be surrounded</span><br><span class="line">by whitespace.  The base defaults to <span class="number">10.</span>  Valid bases are <span class="number">0</span> <span class="keyword">and</span> <span class="number">2</span><span class="number">-36.</span></span><br><span class="line">Base <span class="number">0</span> means to interpret the base <span class="keyword">from</span> the string <span class="keyword">as</span> an integer literal.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'0b100'</span>, base=<span class="number">0</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(map.__doc__)</span><br><span class="line">map(func, *iterables) --&gt; map object</span><br><span class="line"></span><br><span class="line">Make an iterator that computes the function using arguments <span class="keyword">from</span></span><br><span class="line">each of the iterables.  Stops when the shortest iterable <span class="keyword">is</span> exhausted.</span><br></pre></td></tr></table></figure>

<p>查看内置模块的可读说明,可将其导入,并打印其<code>__doc__</code>字符串</p>
<p>内置模块内的函数、类以及方法在其<code>__doc__</code>属性内也有附加的说明信息</p>
<p>也可以通过文档字符串读取内置函数的说明</p>
<h3 id="PyDoc-help函数"><a href="#PyDoc-help函数" class="headerlink" title="PyDoc:help函数"></a>PyDoc:help函数</h3><p>PyDoc工具是Python程序代码,知道如何提取<strong>文档字符串</strong>并且自动提取其<strong>结构化的信息</strong>,并将其格式化成各种类型的排列友好的报表</p>
<p>Python在其标准库中附带了PyDoc</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(sys.getrefcount)</span><br><span class="line"></span><br><span class="line">Help on built-<span class="keyword">in</span> function getrefcount <span class="keyword">in</span> module sys:</span><br><span class="line"></span><br><span class="line">getrefcount(...)</span><br><span class="line">    getrefcount(object) -&gt; integer</span><br><span class="line">    </span><br><span class="line">    Return the reference count of object.  The count returned <span class="keyword">is</span> generally</span><br><span class="line">    one higher than you might expect, because it includes the (temporary)</span><br><span class="line">    reference <span class="keyword">as</span> an argument to getrefcount().</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(sys)</span><br><span class="line"></span><br><span class="line">Help on built-<span class="keyword">in</span> module sys:</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">    sys</span><br><span class="line"></span><br><span class="line">MODULE REFERENCE</span><br><span class="line">    https://docs.python.org/<span class="number">3.6</span>/library/sys</span><br><span class="line">    </span><br><span class="line">    The following documentation <span class="keyword">is</span> automatically generated <span class="keyword">from</span> the Python</span><br><span class="line">    source files.  It may be incomplete, incorrect <span class="keyword">or</span> include features that</span><br><span class="line">    are considered implementation detail <span class="keyword">and</span> may vary between Python</span><br><span class="line">    implementations.  When <span class="keyword">in</span> doubt, consult the module reference at the</span><br><span class="line">    location listed above.</span><br></pre></td></tr></table></figure>

<p><code>help</code>函数会启用PyDoc从而产生简单的文字报表</p>
<p>当对象较大时,如模块和类,<code>help</code>显示内容会分成几段,有些是文档字符串,有些是PyDoc自动查看对象内部而收集的结构化信息,通过交互模式查看所有段内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(dict)</span><br><span class="line"></span><br><span class="line">Help on <span class="class"><span class="keyword">class</span> <span class="title">dict</span> <span class="title">in</span> <span class="title">module</span> <span class="title">builtins</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dict</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">dict</span><span class="params">()</span> -&gt; new empty dictionary</span></span><br><span class="line"><span class="class"> |  dict(mapping) -&gt; new dictionary initialized from a mapping object's</span></span><br><span class="line"><span class="class"> |      (key, value) pairs</span></span><br><span class="line"><span class="class"> |  dict(iterable) -&gt; new dictionary initialized as if via:</span></span><br><span class="line"> |      d = &#123;&#125;</span><br><span class="line"> |      <span class="keyword">for</span> k, v <span class="keyword">in</span> iterable:</span><br><span class="line"> |          d[k] = v</span><br><span class="line"> |  dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs</span><br><span class="line"> |      <span class="keyword">in</span> the keyword argument list.  For example:  dict(one=<span class="number">1</span>, two=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(object)</span><br><span class="line"></span><br><span class="line">Help on <span class="class"><span class="keyword">class</span> <span class="title">object</span> <span class="title">in</span> <span class="title">module</span> <span class="title">builtins</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">object</span></span></span><br><span class="line"><span class="class"> |  <span class="title">The</span> <span class="title">most</span> <span class="title">base</span> <span class="title">type</span></span></span><br><span class="line"><span class="class"><span class="params">(END)</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">help</span><span class="params">(str.replace)</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Help</span> <span class="title">on</span> <span class="title">method_descriptor</span>:</span></span><br><span class="line"></span><br><span class="line">replace(...)</span><br><span class="line">    S.replace(old, new[, count]) -&gt; str</span><br><span class="line">    </span><br><span class="line">    Return a copy of S <span class="keyword">with</span> all occurrences of substring</span><br><span class="line">    old replaced by new.  If the optional argument count <span class="keyword">is</span></span><br><span class="line">    given, only the first count occurrences are replaced.</span><br><span class="line">(END)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(ord)</span><br><span class="line"></span><br><span class="line">Help on built-<span class="keyword">in</span> function ord <span class="keyword">in</span> module builtins:</span><br><span class="line"></span><br><span class="line">ord(c, /)</span><br><span class="line">    Return the Unicode code point <span class="keyword">for</span> a one-character string.</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<p>可以对内置函数、方法以及类型使用help,取得内置类型的<code>help</code>信息可以使用类型名称(<code>dict</code>、<code>str</code>、<code>list</code>)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> docstrings</span><br><span class="line"><span class="number">16</span></span><br><span class="line"></span><br><span class="line">	function documentation</span><br><span class="line">	can we have your liver then?</span><br><span class="line">	</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(docstrings.square)</span><br><span class="line"></span><br><span class="line">Help on function square <span class="keyword">in</span> module docstrings:</span><br><span class="line"></span><br><span class="line">square(x)</span><br><span class="line">    function documentation</span><br><span class="line">    can we have your liver then?</span><br><span class="line">(END)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(docstrings.Employee)</span><br><span class="line"></span><br><span class="line">Help on <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="title">in</span> <span class="title">module</span> <span class="title">docstrings</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span><span class="params">(builtins.object)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">class</span> <span class="title">documentation</span></span></span><br><span class="line"><span class="class"> |  </span></span><br><span class="line"><span class="class"> |  <span class="title">Data</span> <span class="title">descriptors</span> <span class="title">defined</span> <span class="title">here</span>:</span></span><br><span class="line"> |  </span><br><span class="line"> |  __dict__</span><br><span class="line"> |      dictionary <span class="keyword">for</span> instance variables (<span class="keyword">if</span> defined)</span><br><span class="line"> |  </span><br><span class="line"> |  __weakref__</span><br><span class="line"> |      list of weak references to the object (<span class="keyword">if</span> defined)</span><br><span class="line">(END)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(docstrings)</span><br><span class="line"></span><br><span class="line">Help on module docstrings:</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">    docstrings</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">    Module documentation</span><br><span class="line">    Words Go Here</span><br><span class="line"></span><br><span class="line">CLASSES</span><br><span class="line">    builtins.object</span><br><span class="line">        Employee</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Employee</span><span class="params">(builtins.object)</span></span></span><br><span class="line"><span class="class">     |  <span class="title">class</span> <span class="title">documentation</span></span></span><br><span class="line"><span class="class">     |  </span></span><br><span class="line"><span class="class">     |  <span class="title">Data</span> <span class="title">descriptors</span> <span class="title">defined</span> <span class="title">here</span>:</span></span><br><span class="line">     |  </span><br><span class="line">     |  __dict__</span><br><span class="line">     |      dictionary <span class="keyword">for</span> instance variables (<span class="keyword">if</span> defined)</span><br><span class="line">     |  </span><br><span class="line">     |  __weakref__</span><br><span class="line">     |      list of weak references to the object (<span class="keyword">if</span> defined)</span><br><span class="line"></span><br><span class="line">FUNCTIONS</span><br><span class="line">    square(x)</span><br><span class="line">        function documentation</span><br><span class="line">        can we have your liver then?</span><br><span class="line"></span><br><span class="line">DATA</span><br><span class="line">    spam = <span class="number">40</span></span><br><span class="line"></span><br><span class="line">FILE</span><br><span class="line">    ~/Desktop/test/docstrings.py</span><br><span class="line"></span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<p><code>help</code>可以用在模块上,其中有些是文档字符串,有些是查看对象的结构而自动取出的信息</p>
<h3 id="PyDoc-HTML函数"><a href="#PyDoc-HTML函数" class="headerlink" title="PyDoc:HTML函数"></a>PyDoc:HTML函数</h3><p>PyDoc提供了GUI接口,可以将其报表通过HTML网页格式来呈现,PyDoc可以在本地运行或者作为客户端/服务器模式中的远程服务器来运行</p>
<h4 id="GUI模式PyDoc的启动"><a href="#GUI模式PyDoc的启动" class="headerlink" title="GUI模式PyDoc的启动"></a>GUI模式PyDoc的启动</h4><blockquote>
<ul>
<li>首先通过<code>Windows Python</code>的<code>Start</code>按钮中的<code>Module Docs</code>菜单,或者<code>PythonTools</code>目录下的<code>pydocgui.pyw</code>脚本,或者执行pydoc. py再带一个-g命令行参数来启动<strong>搜索引擎GUI</strong></li>
<li>输入模块名称,按下回车键,Python会深人到模块的导入搜索路径(sys.path)从而寻找所请求的模块的索引内容</li>
<li>找到对象后,选中,点击<code>go to selected</code>,Python会在机器上打开网页浏览器,以HTML格式显示报表</li>
</ul>
</blockquote>
<p>网页<code>Module</code>部分超链接可以跳到相关模块的PyDoc网页,当网页较大时,也会产生超链接指向网页的不同部分</p>
<p>GUI接口也能用在用户定义的模块上</p>
<h4 id="PyDoc技巧"><a href="#PyDoc技巧" class="headerlink" title="PyDoc技巧"></a>PyDoc技巧</h4><p>当搜索模块名称留空时,按下<code>go to selected</code>按钮,PyDoc会产生一个网页,其中包含了可能在计算机上导人的每个模块的超链接,这包括Python标准库模块、已安装的第三方扩展模块、位于导入搜索路径上的用户定义模块以及静态或动态连结的C程序模块</p>
<p>PyDoc可以把模块的HTML文档保存在文件中,以便在今后查看或打印</p>
<p>由于以GUII模式执行时可能和标准输入文字没有连接,PyDoc可能无法很好的运行对象是从标准输入读取数据的脚本</p>
<h3 id="标准手册集"><a href="#标准手册集" class="headerlink" title="标准手册集"></a>标准手册集</h3><p>Python手册以HTML和其他格式来实现</p>
<p>可以在Windows上从<code>开始</code>按钮的Python选单中选取,或者在IDLE的<code>Help</code>选项菜单中开启,或者从<a href="http://www.python.org获得不同格式的手册,或者在该网站上在线阅读,Windows上的手册与在线版本支持搜索" target="_blank" rel="noopener">http://www.python.org获得不同格式的手册,或者在该网站上在线阅读,Windows上的手册与在线版本支持搜索</a></p>
<p>在Windows格式的手册上,<code>Library Reference</code>说明内置类型、函数、异常以及标准库模块,<code>Language Regerence</code>提供语言层次的细节的官方说明</p>
<h3 id="网络资源"><a href="#网络资源" class="headerlink" title="网络资源"></a>网络资源</h3><p>在官方的<a href="http://www.python.org" target="_blank" rel="noopener">Python程序设计语言</a>网站上有各种Python资源的链接,而其中一些涵盖了特定的主题或领域</p>
<p>点击<code>Documentation</code>链接可以获取在线教程以及<code>Beginners Guide to Python</code>,这个网站也列出了非英文的Python资源</p>
<p>Web上有各种Python维基、博客、网站以及其他许多资源</p>
<h3 id="已出版的书籍"><a href="#已出版的书籍" class="headerlink" title="已出版的书籍"></a>已出版的书籍</h3><p>书籍会比Python最新的变动慢得多</p>
<hr>
<h2 id="常见编写代码的陷阱"><a href="#常见编写代码的陷阱" class="headerlink" title="常见编写代码的陷阱"></a>常见编写代码的陷阱</h2><blockquote>
<ul>
<li><p>冒号</p>
<p>复合语句首行末尾输入<code>:</code>(if、while、for等的第一行)</p>
</li>
<li><p>从第1行开始</p>
<p>要确定顶层(无嵌套)程序代码从第1列开始,包括在模块文件中输入的无嵌套的代码,在交互模式提示符下输人的无嵌套的代码</p>
</li>
<li><p>空白行在交互模式提示符下很重要</p>
<p>模块文件中复合语句内的空白行都会被Python解释器忽视,但是,交互模式提示符下输入代码时,空白行则是结束语句,如果想继续,就不要在<code>...</code>提示符下( 或IDLE中)按Enter键,直到完成为止</p>
</li>
<li><p>不要在Python中写C代码</p>
<ul>
<li>在<code>if</code>和<code>while</code>首行,不用在测试两侧输入括号(例如,<code>if(X==1):</code>),虽然可以这么做.但这是多余的</li>
<li>不要以分号终止所有的语句,这么做在技术上也是合法的,但是完全没用,除非把一个以上的语句放在同一行中(每行的结尾通常就是该语句的终结)</li>
<li>不要在<code>while</code>循环测试中嵌人赋值语句</li>
<li>不要在块周围使用<code>{}</code> </li>
</ul>
</li>
<li><p>使用简单的<code>for</code>循环,而不是<code>while</code>或<code>range</code></p>
<p>比起<code>while</code>或者<code>range</code>式的计数器循环来讲,简单的for循环(例如,<code>for x in seq:</code>) 总是比较容易写,运行起来也更快</p>
<p>Python会在内部为简单的<code>for</code>循环处理索引运算,因此有时会比等效的<code>while</code>快两倍</p>
</li>
<li><p>要注意赋值语句中的可变对象</p>
<p>在多重目标赋值语句(<code>a = b=[]</code>)以及在增强指定语句(<code>a += [1,2]</code>)中使用可变对象时,在原处的修改会影响其他变量</p>
</li>
<li><p>不要期待在原处修改对象的函数会返回结果</p>
<p><code>list.append</code>和<code>list.sort</code>方法,并不会有返回值(除<code>None</code>),所以在调用时不要对其结果进行赋值</p>
<p>Python 2.X的代码中<code>for k in D.keys().sort():</code>用<code>keys</code>方法建立键列表,<code>sort</code>方法排序,但是由于<code>sort</code>方法返回<code>None</code>会导致循环失败</p>
</li>
<li><p>一定要使用括号调用函数</p>
<p>必须在函数名称后面加括号才能对它进行调用,无论它是否带有参数(例如,使用<code>function()</code>)</p>
<p>函数是对象,只是有特殊的运算<code>()</code>触发对它的调用<br>输入<code>file.close</code>因为是引用函数而不是对它调用所以也是合法的,但是它并没有关闭文件</p>
</li>
<li><p>不要在导入和重载中使用扩展名或路径</p>
<p>在<code>import</code>语句中省略目录路径和文件拓展名(例如,要写<code>import mod</code>,而不是<code>import mod.py</code>),因为模块可能有<code>.py</code>以外的其他后缀名(例如,<code>.pyc</code>),硬编码的后缀名不仅是不合法的语法,也说不通</p>
<p>任何平台特定的目录路径语法是属于模块搜索路径设置的,而不是import语句</p>
</li>
</ul>
</blockquote>
<hr>
<h2 id="本章习题-5"><a href="#本章习题-5" class="headerlink" title="本章习题"></a>本章习题</h2><ol>
<li><p>在什么时候应该使用文档字符串而不是<code>#</code>字注释</p>
<blockquote>
<p>文档字符串被认为最适用于较大、功能性的文档,用来描述程序中的模块、函数、类以及方法的使用</p>
<p>如今的<code>#</code>号注释最好只限于关于费解的表达式或语句的微型文档</p>
<p>一方面因为文件字符串在源代码文件中比较容易找到,另一方面也是因为PyDoc系统能将其取出并显示</p>
</blockquote>
</li>
<li><p>举出3种查看文档字符串的方式</p>
<blockquote>
<p>可以打印对象的<code>__ doc__</code> 属性,传给<code>PyDoc</code>的<code>help</code>函数,以及选取服务器/客户端模式下<code>PyDoc GUI</code>搜索引擎中的模块,查看文档字符串</p>
<p>此外，<code>PyDoc</code>可以把模块的文档储存在<code>HTML</code>文件中以便稍后查看或打印</p>
</blockquote>
</li>
<li><p>如何获得对象中可用属性的列表</p>
<blockquote>
<p>内置的<code>dir(X)</code>函数会返回附加在任何对象上的所有属性的列表</p>
</blockquote>
</li>
<li><p>如何获得计算机中所有可用模块的列表</p>
<blockquote>
<p>执行PyDoc GUI接口,保持模块名称空白,然后选择<code>Open Browser</code>,这样会打开一个网页,其中包含了程序中每个可用模块的链接</p>
</blockquote>
</li>
<li><p>阅读本书之后,应该买哪本Python书籍</p>
<blockquote>
<p>前言列出的一些推荐的进阶书籍,包括了参考书籍和应用程序开发的教程</p>
</blockquote>
</li>
</ol>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="http://abcdefghijklmnopqrst.xyz">骑麦兜看落日</a>
            <p>原文链接：<a href="http://abcdefghijklmnopqrst.xyz/2018/07/30/Code_Python学习手册_3/">http://abcdefghijklmnopqrst.xyz/2018/07/30/Code_Python学习手册_3/</a>
            <p>发表日期：<a href="http://abcdefghijklmnopqrst.xyz/2018/07/30/Code_Python学习手册_3/">July 30th 2018, 10:00:00 pm</a>
            <p>更新日期：<a href="http://abcdefghijklmnopqrst.xyz/2018/07/30/Code_Python学习手册_3/">September 26th 2018, 12:00:00 am</a>
            <p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2018/07/30/Linux_INT80/" title= "[Linux]int 80">
                    <div class="nextTitle">[Linux]int 80</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2018/07/25/Binary_Canary/" title= "[Binary]Canary">
                    <div class="prevTitle">[Binary]Canary</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

    <div id="lv-container" data-id="city" data-uid= MTAyMC8zNzY1OS8xNDE5MA==>
        <script type="text/javascript">
            (function (d, s) {
                var j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') { return; }
                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:qimaidoukanluori@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/qimaidoukanluori" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">到访的小伙伴: <span id="busuanzi_value_site_pv"></span>只 </span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:30vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第十章-Python语句简介"><span class="toc-number">1.</span> <span class="toc-text">第十章 Python语句简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#重访Python程序结构"><span class="toc-number">1.1.</span> <span class="toc-text">重访Python程序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Python的语句"><span class="toc-number">1.1.1.</span> <span class="toc-text">Python的语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#两个if的故事"><span class="toc-number">1.2.</span> <span class="toc-text">两个if的故事</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Python增加了什么"><span class="toc-number">1.2.1.</span> <span class="toc-text">Python增加了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python删除了什么"><span class="toc-number">1.2.2.</span> <span class="toc-text">Python删除了什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#括号是可选的"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">括号是可选的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#终止行就是终止语句"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">终止行就是终止语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缩进的结束就是代码块的结束"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">缩进的结束就是代码块的结束</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么使用缩进语法"><span class="toc-number">1.2.3.</span> <span class="toc-text">为什么使用缩进语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#几个特殊实例"><span class="toc-number">1.2.4.</span> <span class="toc-text">几个特殊实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#语句规则的特殊情况"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">语句规则的特殊情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码块规则特殊实例"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">代码块规则特殊实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简短实例-交互循环"><span class="toc-number">1.3.</span> <span class="toc-text">简短实例:交互循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一个简单的交互式循环"><span class="toc-number">1.3.1.</span> <span class="toc-text">一个简单的交互式循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对用户输入数据做数学运算"><span class="toc-number">1.3.2.</span> <span class="toc-text">对用户输入数据做数学运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用测试输入数据来处理错误"><span class="toc-number">1.3.3.</span> <span class="toc-text">用测试输入数据来处理错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用try语句处理错误"><span class="toc-number">1.3.4.</span> <span class="toc-text">用try语句处理错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套代码三层"><span class="toc-number">1.3.5.</span> <span class="toc-text">嵌套代码三层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章习题"><span class="toc-number">1.4.</span> <span class="toc-text">本章习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十一章-赋值、表达式和打印"><span class="toc-number">2.</span> <span class="toc-text">第十一章 赋值、表达式和打印</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#赋值语句"><span class="toc-number">2.1.</span> <span class="toc-text">赋值语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#赋值语句的形式"><span class="toc-number">2.1.1.</span> <span class="toc-text">赋值语句的形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#序列赋值"><span class="toc-number">2.1.2.</span> <span class="toc-text">序列赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#高级序列赋值语句模式"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">高级序列赋值语句模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-3-0中的拓展序列解包"><span class="toc-number">2.1.3.</span> <span class="toc-text">Python 3.0中的拓展序列解包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展的解包的实际应用"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">扩展的解包的实际应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#边界情况"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">边界情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一个有用的便利形式"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">一个有用的便利形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#应用于for循环"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">应用于for循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多目标赋值语句"><span class="toc-number">2.1.4.</span> <span class="toc-text">多目标赋值语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#多目标赋值以及共享引用"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">多目标赋值以及共享引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增强赋值语句"><span class="toc-number">2.1.5.</span> <span class="toc-text">增强赋值语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#增强赋值以及共享引用"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">增强赋值以及共享引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量命名规则"><span class="toc-number">2.1.6.</span> <span class="toc-text">变量命名规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本规则"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">基本规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-3-0中的保留字"><span class="toc-number">2.1.6.2.</span> <span class="toc-text">Python 3.0中的保留字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命名规则"><span class="toc-number">2.1.6.3.</span> <span class="toc-text">命名规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量名没有类型-但对象有"><span class="toc-number">2.1.6.4.</span> <span class="toc-text">变量名没有类型,但对象有</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python的废弃协议"><span class="toc-number">2.1.7.</span> <span class="toc-text">Python的废弃协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#表达式语句"><span class="toc-number">2.2.</span> <span class="toc-text">表达式语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#表达式语句和在原处的修改"><span class="toc-number">2.2.1.</span> <span class="toc-text">表达式语句和在原处的修改</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#打印操作"><span class="toc-number">2.3.</span> <span class="toc-text">打印操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-3-0的print函数"><span class="toc-number">2.3.1.</span> <span class="toc-text">Python 3.0的print函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#调用格式"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">调用格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-3-0的print函数的应用"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">Python 3.0的print函数的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-2-6print语句"><span class="toc-number">2.3.2.</span> <span class="toc-text">Python 2.6print语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#语句形式"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">语句形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-2-6-print语句应用"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">Python 2.6 print语句应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打印流重定向"><span class="toc-number">2.3.3.</span> <span class="toc-text">打印流重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Python的”Hello-World”程序"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">Python的”Hello World”程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重定向输出流"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">重定向输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自动化流重定向"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">自动化流重定向</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#版本独立的打印"><span class="toc-number">2.3.4.</span> <span class="toc-text">版本独立的打印</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要注意print和stdout"><span class="toc-number">2.3.5.</span> <span class="toc-text">为什么要注意print和stdout</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章习题-1"><span class="toc-number">2.4.</span> <span class="toc-text">本章习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十二章-if测试和语法规则"><span class="toc-number">3.</span> <span class="toc-text">第十二章 if测试和语法规则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#if语句"><span class="toc-number">3.1.</span> <span class="toc-text">if语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通用格式"><span class="toc-number">3.1.1.</span> <span class="toc-text">通用格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本例子"><span class="toc-number">3.1.2.</span> <span class="toc-text">基本例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多路分支"><span class="toc-number">3.1.3.</span> <span class="toc-text">多路分支</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python语法规则"><span class="toc-number">3.2.</span> <span class="toc-text">Python语法规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码块分隔符"><span class="toc-number">3.2.1.</span> <span class="toc-text">代码块分隔符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#避免混合使用制表符和空格-Python-3-0中心的错误检查"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">避免混合使用制表符和空格:Python 3.0中心的错误检查</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#语句的分隔符"><span class="toc-number">3.2.2.</span> <span class="toc-text">语句的分隔符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一些特殊情况"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">一些特殊情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#真值测试"><span class="toc-number">3.3.</span> <span class="toc-text">真值测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if-else三元表达式"><span class="toc-number">3.4.</span> <span class="toc-text">if/else三元表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么要在意布尔值"><span class="toc-number">3.5.</span> <span class="toc-text">为什么要在意布尔值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章习题-2"><span class="toc-number">3.6.</span> <span class="toc-text">本章习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十三章-while和for循环"><span class="toc-number">4.</span> <span class="toc-text">第十三章 while和for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#while循环"><span class="toc-number">4.1.</span> <span class="toc-text">while循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一般格式"><span class="toc-number">4.1.1.</span> <span class="toc-text">一般格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例子"><span class="toc-number">4.1.2.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#break、continue、pass和循环else"><span class="toc-number">4.1.3.</span> <span class="toc-text">break、continue、pass和循环else</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一般循环格式"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">一般循环格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pass"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">pass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#continue"><span class="toc-number">4.1.3.3.</span> <span class="toc-text">continue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#break"><span class="toc-number">4.1.3.4.</span> <span class="toc-text">break</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#循环else"><span class="toc-number">4.1.3.5.</span> <span class="toc-text">循环else</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#关于循环else分句的更多内容"><span class="toc-number">4.1.3.5.1.</span> <span class="toc-text">关于循环else分句的更多内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要在意”模拟C语言的while循环”"><span class="toc-number">4.1.4.</span> <span class="toc-text">为什么要在意”模拟C语言的while循环”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for循环"><span class="toc-number">4.2.</span> <span class="toc-text">for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一般格式-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">一般格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例子-1"><span class="toc-number">4.2.2.</span> <span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本应用"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">基本应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他数据类型"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">其他数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在for循环中的元组赋值"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">在for循环中的元组赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-3-0在for循环中拓展的序列赋值"><span class="toc-number">4.2.2.4.</span> <span class="toc-text">Python 3.0在for循环中拓展的序列赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#嵌套for循环"><span class="toc-number">4.2.2.5.</span> <span class="toc-text">嵌套for循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要在意”文件扫描”"><span class="toc-number">4.2.3.</span> <span class="toc-text">为什么要在意”文件扫描”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编写循环的技巧"><span class="toc-number">4.3.</span> <span class="toc-text">编写循环的技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#循环计数器-while和range"><span class="toc-number">4.3.1.</span> <span class="toc-text">循环计数器:while和range</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非完备遍历-range和分片"><span class="toc-number">4.3.2.</span> <span class="toc-text">非完备遍历:range和分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修改列表-range"><span class="toc-number">4.3.3.</span> <span class="toc-text">修改列表:range</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并行遍历-zip和map"><span class="toc-number">4.3.4.</span> <span class="toc-text">并行遍历:zip和map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-2-6中的map的等价形式"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">Python 2.6中的map的等价形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用zip构造字典"><span class="toc-number">4.3.4.2.</span> <span class="toc-text">使用zip构造字典</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#产生偏移和元素-enumerate"><span class="toc-number">4.3.5.</span> <span class="toc-text">产生偏移和元素:enumerate</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章习题-3"><span class="toc-number">4.4.</span> <span class="toc-text">本章习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十四章-迭代器和解析-第一部分"><span class="toc-number">5.</span> <span class="toc-text">第十四章 迭代器和解析,第一部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代器-初探"><span class="toc-number">5.1.</span> <span class="toc-text">迭代器:初探</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件迭代器"><span class="toc-number">5.1.1.</span> <span class="toc-text">文件迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#手动迭代-iter和next"><span class="toc-number">5.1.2.</span> <span class="toc-text">手动迭代:iter和next</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他内置类型迭代器"><span class="toc-number">5.1.3.</span> <span class="toc-text">其他内置类型迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#列表解析-初探"><span class="toc-number">5.2.</span> <span class="toc-text">列表解析:初探</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#列表解析基础知识"><span class="toc-number">5.2.1.</span> <span class="toc-text">列表解析基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在文件上使用列表解析"><span class="toc-number">5.2.2.</span> <span class="toc-text">在文件上使用列表解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓展的列表解析语法"><span class="toc-number">5.2.3.</span> <span class="toc-text">拓展的列表解析语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他迭代环境"><span class="toc-number">5.3.</span> <span class="toc-text">其他迭代环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-3-0中的新的可迭代对象"><span class="toc-number">5.4.</span> <span class="toc-text">Python 3.0中的新的可迭代对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#range迭代器"><span class="toc-number">5.4.1.</span> <span class="toc-text">range迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map、zip和filter迭代器"><span class="toc-number">5.4.2.</span> <span class="toc-text">map、zip和filter迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多个迭代器-VS-单个迭代器"><span class="toc-number">5.4.3.</span> <span class="toc-text">多个迭代器 VS 单个迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字典视图迭代器"><span class="toc-number">5.4.4.</span> <span class="toc-text">字典视图迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他迭代器主题"><span class="toc-number">5.5.</span> <span class="toc-text">其他迭代器主题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章习题-4"><span class="toc-number">5.6.</span> <span class="toc-text">本章习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十五章-文档"><span class="toc-number">6.</span> <span class="toc-text">第十五章 文档</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python文档资源"><span class="toc-number">6.1.</span> <span class="toc-text">Python文档资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注释"><span class="toc-number">6.1.1.</span> <span class="toc-text">#注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dir函数"><span class="toc-number">6.1.2.</span> <span class="toc-text">dir函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文档字符串-doc"><span class="toc-number">6.1.3.</span> <span class="toc-text">文档字符串:_doc_</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用户定义的文档字符串"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">用户定义的文档字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文档字符串标准"><span class="toc-number">6.1.3.2.</span> <span class="toc-text">文档字符串标准</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内置文档字符串"><span class="toc-number">6.1.3.3.</span> <span class="toc-text">内置文档字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PyDoc-help函数"><span class="toc-number">6.1.4.</span> <span class="toc-text">PyDoc:help函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PyDoc-HTML函数"><span class="toc-number">6.1.5.</span> <span class="toc-text">PyDoc:HTML函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GUI模式PyDoc的启动"><span class="toc-number">6.1.5.1.</span> <span class="toc-text">GUI模式PyDoc的启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PyDoc技巧"><span class="toc-number">6.1.5.2.</span> <span class="toc-text">PyDoc技巧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准手册集"><span class="toc-number">6.1.6.</span> <span class="toc-text">标准手册集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络资源"><span class="toc-number">6.1.7.</span> <span class="toc-text">网络资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#已出版的书籍"><span class="toc-number">6.1.8.</span> <span class="toc-text">已出版的书籍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见编写代码的陷阱"><span class="toc-number">6.2.</span> <span class="toc-text">常见编写代码的陷阱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章习题-5"><span class="toc-number">6.3.</span> <span class="toc-text">本章习题</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 52
        </div>
        <!-- search  -->
        
            <div class="site-search popup-trigger">
                <span class="iconfont-archer search-icon">&#xe627;</span>
            </div>
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/19</span><a class="archive-post-title" href= "/2020/04/19/Vuln_BUG_191731_WebKit_RegExp_lastIndex_类型混淆/" >[Vuln]BUG-191731 WebKit RegExp lastIndex 类型混淆</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/19</span><a class="archive-post-title" href= "/2020/04/19/Vuln_CVE_2016_4622_WebKit_Array_slice_数组访问越界/" >[Vuln]CVE-2016-4622 WebKit Array slice 数组访问越界</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/09</span><a class="archive-post-title" href= "/2019/12/09/Binary_Iot设备如何拿到调试shell/" >[Binary]Iot设备如何拿到调试shell</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/30</span><a class="archive-post-title" href= "/2019/10/30/Binary_Unicorn学习/" >[Binary]Unicorn学习</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2019/09/10/WP_2019ByteCTF/" >[WriteUp]2019ByteCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/26</span><a class="archive-post-title" href= "/2019/08/26/WP_2019OGeek/" >[WriteUp]2019OGeek</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/31</span><a class="archive-post-title" href= "/2019/07/31/WP_2019CISCN final/" >[WriteUp]2019CISCN final</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/07</span><a class="archive-post-title" href= "/2019/07/07/WP_2019WCTF/" >[WriteUp]2019WCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/02</span><a class="archive-post-title" href= "/2019/07/02/Asm_WASM格式化字符串攻击尝试/" >[Asm]WASM格式化字符串攻击尝试</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/22</span><a class="archive-post-title" href= "/2019/01/22/Code_Python可变类型的一些问题/" >[Code]Python可变类型的一些问题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/13</span><a class="archive-post-title" href= "/2019/01/13/Asm_WASM初步/" >[Asm]WASM初步</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/20</span><a class="archive-post-title" href= "/2018/12/20/Binary_通过a的leak/" >[Binary]通过%a的leak</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/07</span><a class="archive-post-title" href= "/2018/12/07/WP_hxpCTF/" >[WriteUp]hxpCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/27</span><a class="archive-post-title" href= "/2018/11/27/WP_2018BCTF/" >[WriteUp]2018BCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/14</span><a class="archive-post-title" href= "/2018/11/14/Binary_IO_FILE源码分析/" >[Binary]IO_FILE</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/05</span><a class="archive-post-title" href= "/2018/11/05/Binary_ArmPwn/" >[Asm]ARMPwn</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/04</span><a class="archive-post-title" href= "/2018/11/04/WP_上海杯/" >[WriteUp]上海杯</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/27</span><a class="archive-post-title" href= "/2018/10/27/WP_HCTF/" >[WriteUp]HCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/27</span><a class="archive-post-title" href= "/2018/10/27/WP_SECCONCTF/" >[WriteUp]SECCONCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/27</span><a class="archive-post-title" href= "/2018/10/27/WP_湖湘杯/" >[WriteUp]湖湘杯</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href= "/2018/10/24/Binary_Tcache/" >[Binary]Tcache</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/17</span><a class="archive-post-title" href= "/2018/10/17/Asm_RealmodeAsm/" >[Asm]RealmodeAsm</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/13</span><a class="archive-post-title" href= "/2018/10/13/WP_2018护网杯/" >[WriteUp]护网杯</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/06</span><a class="archive-post-title" href= "/2018/10/06/Binary_IDADynamic/" >[Binary]IDADynamic</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2018/10/05/Linux_pwn环境搭建/" >[Linux]pwn环境搭建</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2018/10/05/WP_DragonCTF/" >[WriteUp]DefCampCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2018/10/05/WP_InCTF/" >[WriteUp]InCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span><a class="archive-post-title" href= "/2018/09/28/Binary_PDF/" >[Binary]PDF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/27</span><a class="archive-post-title" href= "/2018/09/27/Linux_GDB/" >[Linux]GDB</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/27</span><a class="archive-post-title" href= "/2018/09/27/Linux_GDB的python调试/" >[Linux]GDB的Python调试</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/25</span><a class="archive-post-title" href= "/2018/09/25/WP_DefCampCTF/" >[WriteUp]DefCampCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/18</span><a class="archive-post-title" href= "/2018/09/18/Android_JNI/" >[Android]JNI</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/18</span><a class="archive-post-title" href= "/2018/09/18/BInary_HeapExploit/" >[Binary]HeapExploit</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/13</span><a class="archive-post-title" href= "/2018/09/13/Binary_IO_FILE/" >[Binary]IO_FILE</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2018/09/10/Linux_GDB的源码调试/" >[Linux]GDB源码调试</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/01</span><a class="archive-post-title" href= "/2018/09/01/Binary_ptmalloc源码分析/" >[Binary]ptmalloc源码分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/25</span><a class="archive-post-title" href= "/2018/08/25/WP_pwnable.tw/" >[WriteUp]pwnable.tw</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/21</span><a class="archive-post-title" href= "/2018/08/21/Code_Python学习手册_7/" >[Code]Python学习手册_第七部分_异常和工具</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/21</span><a class="archive-post-title" href= "/2018/08/21/WP_网鼎杯/" >[WriteUp]网鼎杯</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/14</span><a class="archive-post-title" href= "/2018/08/14/Code_Python学习手册_6/" >[Code]Python学习手册_第六部分_类和OOP</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/13</span><a class="archive-post-title" href= "/2018/08/13/WP_JarvisOJ/" >[WriteUp]JarvisOJ</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/10</span><a class="archive-post-title" href= "/2018/08/10/Code_Python学习手册_5/" >[Code]Python学习手册_第五部分_模块</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/05</span><a class="archive-post-title" href= "/2018/08/05/Code_Python学习手册_4/" >[Code]Python学习手册_第四部分_函数</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/05</span><a class="archive-post-title" href= "/2018/08/05/Binary_Heap/" >[Binary]Heap</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/30</span><a class="archive-post-title" href= "/2018/07/30/Linux_INT80/" >[Linux]int 80</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/30</span><a class="archive-post-title" href= "/2018/07/30/Code_Python学习手册_3/" >[Code]Python学习手册_第三部分_语句和语法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/25</span><a class="archive-post-title" href= "/2018/07/25/Binary_Canary/" >[Binary]Canary</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/24</span><a class="archive-post-title" href= "/2018/07/24/Code_Python学习手册_2/" >[Code]Python学习手册_第二部分_类型和运算</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/22</span><a class="archive-post-title" href= "/2018/07/22/Binary_fmt/" >[Binary]FormatString</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/21</span><a class="archive-post-title" href= "/2018/07/21/Code_Python学习手册_1/" >[Code]Python学习手册_第一部分_使用入门</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/21</span><a class="archive-post-title" href= "/2018/07/21/WP_巅峰极客/" >[WriteUp]巅峰极客</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/22</span><a class="archive-post-title" href= "/2018/01/22/Code_Python的C拓展/" >[Code]Python的C拓展</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="Note"><span class="iconfont-archer">&#xe606;</span>Note</span>
    
        <span class="sidebar-tag-name" data-tags="Android"><span class="iconfont-archer">&#xe606;</span>Android</span>
    
        <span class="sidebar-tag-name" data-tags="Java"><span class="iconfont-archer">&#xe606;</span>Java</span>
    
        <span class="sidebar-tag-name" data-tags="JNI"><span class="iconfont-archer">&#xe606;</span>JNI</span>
    
        <span class="sidebar-tag-name" data-tags="Assembly"><span class="iconfont-archer">&#xe606;</span>Assembly</span>
    
        <span class="sidebar-tag-name" data-tags="WASM"><span class="iconfont-archer">&#xe606;</span>WASM</span>
    
        <span class="sidebar-tag-name" data-tags="Asm"><span class="iconfont-archer">&#xe606;</span>Asm</span>
    
        <span class="sidebar-tag-name" data-tags="Binary"><span class="iconfont-archer">&#xe606;</span>Binary</span>
    
        <span class="sidebar-tag-name" data-tags="Pwn"><span class="iconfont-archer">&#xe606;</span>Pwn</span>
    
        <span class="sidebar-tag-name" data-tags="Heap"><span class="iconfont-archer">&#xe606;</span>Heap</span>
    
        <span class="sidebar-tag-name" data-tags="Canary"><span class="iconfont-archer">&#xe606;</span>Canary</span>
    
        <span class="sidebar-tag-name" data-tags="IDA"><span class="iconfont-archer">&#xe606;</span>IDA</span>
    
        <span class="sidebar-tag-name" data-tags="Linux"><span class="iconfont-archer">&#xe606;</span>Linux</span>
    
        <span class="sidebar-tag-name" data-tags="IO_FILE"><span class="iconfont-archer">&#xe606;</span>IO_FILE</span>
    
        <span class="sidebar-tag-name" data-tags="Iot"><span class="iconfont-archer">&#xe606;</span>Iot</span>
    
        <span class="sidebar-tag-name" data-tags="PDF"><span class="iconfont-archer">&#xe606;</span>PDF</span>
    
        <span class="sidebar-tag-name" data-tags="Tcache"><span class="iconfont-archer">&#xe606;</span>Tcache</span>
    
        <span class="sidebar-tag-name" data-tags="Unicorn"><span class="iconfont-archer">&#xe606;</span>Unicorn</span>
    
        <span class="sidebar-tag-name" data-tags="Fmt"><span class="iconfont-archer">&#xe606;</span>Fmt</span>
    
        <span class="sidebar-tag-name" data-tags="Code"><span class="iconfont-archer">&#xe606;</span>Code</span>
    
        <span class="sidebar-tag-name" data-tags="Python"><span class="iconfont-archer">&#xe606;</span>Python</span>
    
        <span class="sidebar-tag-name" data-tags="GDB"><span class="iconfont-archer">&#xe606;</span>GDB</span>
    
        <span class="sidebar-tag-name" data-tags="Gdb"><span class="iconfont-archer">&#xe606;</span>Gdb</span>
    
        <span class="sidebar-tag-name" data-tags="Pwntools"><span class="iconfont-archer">&#xe606;</span>Pwntools</span>
    
        <span class="sidebar-tag-name" data-tags="Qemu"><span class="iconfont-archer">&#xe606;</span>Qemu</span>
    
        <span class="sidebar-tag-name" data-tags="Browser"><span class="iconfont-archer">&#xe606;</span>Browser</span>
    
        <span class="sidebar-tag-name" data-tags="WebKit"><span class="iconfont-archer">&#xe606;</span>WebKit</span>
    
        <span class="sidebar-tag-name" data-tags="TypeConfusion"><span class="iconfont-archer">&#xe606;</span>TypeConfusion</span>
    
        <span class="sidebar-tag-name" data-tags="OOB"><span class="iconfont-archer">&#xe606;</span>OOB</span>
    
        <span class="sidebar-tag-name" data-tags="CTF"><span class="iconfont-archer">&#xe606;</span>CTF</span>
    
        <span class="sidebar-tag-name" data-tags="WriteUp"><span class="iconfont-archer">&#xe606;</span>WriteUp</span>
    
        <span class="sidebar-tag-name" data-tags="CTFtime"><span class="iconfont-archer">&#xe606;</span>CTFtime</span>
    
        <span class="sidebar-tag-name" data-tags="XCTF"><span class="iconfont-archer">&#xe606;</span>XCTF</span>
    
        <span class="sidebar-tag-name" data-tags="Fastbin"><span class="iconfont-archer">&#xe606;</span>Fastbin</span>
    
        <span class="sidebar-tag-name" data-tags="FormatString"><span class="iconfont-archer">&#xe606;</span>FormatString</span>
    
        <span class="sidebar-tag-name" data-tags="StackOvrtflow"><span class="iconfont-archer">&#xe606;</span>StackOvrtflow</span>
    
        <span class="sidebar-tag-name" data-tags="IntegerOverflow"><span class="iconfont-archer">&#xe606;</span>IntegerOverflow</span>
    
        <span class="sidebar-tag-name" data-tags="Cfunc"><span class="iconfont-archer">&#xe606;</span>Cfunc</span>
    
        <span class="sidebar-tag-name" data-tags="HouseOfRoman"><span class="iconfont-archer">&#xe606;</span>HouseOfRoman</span>
    
        <span class="sidebar-tag-name" data-tags="ShellCode"><span class="iconfont-archer">&#xe606;</span>ShellCode</span>
    
        <span class="sidebar-tag-name" data-tags="prctl"><span class="iconfont-archer">&#xe606;</span>prctl</span>
    
        <span class="sidebar-tag-name" data-tags="global_max_fast"><span class="iconfont-archer">&#xe606;</span>global_max_fast</span>
    
        <span class="sidebar-tag-name" data-tags="read"><span class="iconfont-archer">&#xe606;</span>read</span>
    
        <span class="sidebar-tag-name" data-tags="UAF"><span class="iconfont-archer">&#xe606;</span>UAF</span>
    
        <span class="sidebar-tag-name" data-tags="FastbinAttack"><span class="iconfont-archer">&#xe606;</span>FastbinAttack</span>
    
        <span class="sidebar-tag-name" data-tags="HeapOverflow"><span class="iconfont-archer">&#xe606;</span>HeapOverflow</span>
    
        <span class="sidebar-tag-name" data-tags="Re"><span class="iconfont-archer">&#xe606;</span>Re</span>
    
        <span class="sidebar-tag-name" data-tags="wargame"><span class="iconfont-archer">&#xe606;</span>wargame</span>
    
        <span class="sidebar-tag-name" data-tags="Cpp"><span class="iconfont-archer">&#xe606;</span>Cpp</span>
    
        <span class="sidebar-tag-name" data-tags="SystemCall"><span class="iconfont-archer">&#xe606;</span>SystemCall</span>
    
        <span class="sidebar-tag-name" data-tags="Arm"><span class="iconfont-archer">&#xe606;</span>Arm</span>
    
        <span class="sidebar-tag-name" data-tags="StackOverflow"><span class="iconfont-archer">&#xe606;</span>StackOverflow</span>
    
        <span class="sidebar-tag-name" data-tags="OJ"><span class="iconfont-archer">&#xe606;</span>OJ</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="Code"><span class="iconfont-archer">&#xe60a;</span>Code</span>
    
        <span class="sidebar-category-name" data-categories="Assembly"><span class="iconfont-archer">&#xe60a;</span>Assembly</span>
    
        <span class="sidebar-category-name" data-categories="Binary"><span class="iconfont-archer">&#xe60a;</span>Binary</span>
    
        <span class="sidebar-category-name" data-categories="Linux"><span class="iconfont-archer">&#xe60a;</span>Linux</span>
    
        <span class="sidebar-category-name" data-categories="Vuln"><span class="iconfont-archer">&#xe60a;</span>Vuln</span>
    
        <span class="sidebar-category-name" data-categories="WriteUp"><span class="iconfont-archer">&#xe60a;</span>WriteUp</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "骑麦兜看落日"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
        <div class="site-search">
  <div class="algolia-popup popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="iconfont-archer">&#xe609;</i>
    </span>
  </div>
</div>
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.8.0/dist/instantsearch.min.js" defer></script>
        <script src="/scripts/search.js" defer></script>
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


