<!DOCTYPE html>
<html lang="">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="骑麦兜看落日">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="骑麦兜看落日">
    
    <meta name="keywords" content="Hexo,骑麦兜看落日">
    
    <meta name="description" content>
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>[Code]Python学习手册_第四部分_函数 · 骑麦兜看落日&#39;s Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
        <!-- algolia -->
        <script>
            
            var hits = JSON.parse('{"per_page":10}')
            var labels = JSON.parse('{"input_placeholder":"Search for Posts","hits_empty":"We did not find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}')

            var algolia = {
                applicationID: '5D5KDIMZEQ',
                apiKey: 'b4ec67c101aa9269e65e640e2e469343',
                indexName: 'my_index',
                hits: hits,
                labels: labels
            }
        </script>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Hexo</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">[Code]Python学习手册_第四部分_函数</a>
            </div>
    </div>
    
    <a class="home-link" href=/>Hexo</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:30vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            [Code]Python学习手册_第四部分_函数
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "Note">Note</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "Code">Code</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "Python">Python</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">32.4k</span>阅读时长: <span class="post-count reading-time">143 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2018/08/05</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="第十六章-函数基础"><a href="#第十六章-函数基础" class="headerlink" title="第十六章_函数基础"></a>第十六章_函数基础</h1><blockquote>
<ul>
<li>本章介绍了函数定义的语法以及<code>def</code>和<code>return</code>语句的操作,函数调用表达式的行为,以及Python函数中多态的概念和优点</li>
<li>探索本地变量和作用域的概念</li>
<li>介绍生成器和函数式工具</li>
<li>回顾多态</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>语句</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>Calls</td>
<td>myfunc(“spam”, “eggs”, meat = ham)</td>
</tr>
<tr>
<td>def</td>
<td>def adder(a, b,*c):</td>
</tr>
<tr>
<td>return</td>
<td>return a+b+c[0]</td>
</tr>
<tr>
<td>global</td>
<td>def changer(): global x; x = ‘new’</td>
</tr>
<tr>
<td>nonlocal</td>
<td>def changer(): nonlocal x; x = ‘new’</td>
</tr>
<tr>
<td>yield</td>
<td>def squares(x): for i in range(x): yield i ** 2</td>
</tr>
<tr>
<td>lambda</td>
<td>Funcs = [lambda x: x*<em>2, lambda x: x</em>3]</td>
</tr>
</tbody></table>
<hr>
<h2 id="为何使用函数"><a href="#为何使用函数" class="headerlink" title="为何使用函数"></a>为何使用函数</h2><p>函数是一个通用的程序结构部件</p>
<blockquote>
<ul>
<li><p>最大化的代码重用和最小化代码冗余</p>
<p>Python的函数通过一种简单的办法去打包逻辑算法,使其能够在之后不止在一处、不止一次地使用</p>
<p>函数允许整合以及通用化代码,以便这些代码能够在之后多次使用</p>
<p>因为允许一处编写多处运行,使程序中减少代码的冗余成为现实,并为代码的维护节省了不少的力气</p>
</li>
<li><p>流程的分解</p>
<p>函数提供了一种将一个系统分割为定义完好的不同部分的工具</p>
<p>独立的实现较小的任务要比一次完成整个流程要容易得多</p>
</li>
</ul>
</blockquote>
<h2 id="编写函数"><a href="#编写函数" class="headerlink" title="编写函数"></a>编写函数</h2><blockquote>
<ul>
<li><p><code>def</code>是可执行的代码</p>
<p>Python的函数由<code>def</code>语句编写</p>
<p><code>def</code>是一个可执行的语句,直到Python运行了<code>def</code>后函数才存在</p>
<p>在<code>if</code>语句、<code>while</code>循环甚至是其他的<code>def</code>中嵌套是合法的</p>
</li>
<li><p><code>def</code>创建了一个对象并将其赋值给某一变量名</p>
<p>当Python运行到<code>def</code>语句时,它将会生成一个新的函数对象并将其赋值给这个函数名,函数名变成了某一个函数的引用,函数对象还可以赋值给其他的变量名,保存在列表之中</p>
<p>函数也可以通过lambda表达式来创建</p>
</li>
<li><p><code>lambda</code>创建一个对象但将其作为结果返回</p>
<p>可以用<code>lambda</code>表达式创建函数,把函数定义内联到语法上<strong>一条</strong><code>def</code>语句不能工作的地方</p>
</li>
<li><p><code>return</code>将一个结果对象发送给调用者</p>
<p>当函数被调用时,其调用者停止运行直到这个函数完成了它的工作,之后函数才将控制权返回调用者</p>
<p>函数是通过return语句将计算得到的值传递给调用者的,返回值成为函数调用的结果</p>
</li>
<li><p><code>yield</code>向调用者发回一个结果对象,但是记住它离开的地方</p>
<p>像生成器这样的函数也可以通过<code>yield</code>语句来返回值,并挂起它们的状态以便稍后能够恢复状态</p>
</li>
<li><p><code>global</code>声明了一个<strong>模块级</strong>的变量并被赋值</p>
<p>在默认情况下,所有在一个函数中被赋值的对象,是这个函数的<strong>本地变量</strong>,并且仅在这个函数运行的过程中在存在</p>
<p>为了分配一个可以在整个模块中都可以使用的变量名,函数需要在<code>global</code>语句中声明</p>
<p>通常情况下,变量名需要关注它的作用域(也就是说变量存储的地方),并且是通过实赋值语句将变量名绑定至作用域的</p>
</li>
<li><p><code>nonlocal</code>声明了将要赋值的一个封闭的函数变量</p>
<p><code>nonlocal</code>语句允许一个函数来赋值一条语法封闭的<code>def</code>语句的作用域中已有的名称</p>
<p>这就允许封闭的函数作为保留状态的一个地方一当一个函数调用的时候,信息被记住了一而不必使用共享的全局名称</p>
</li>
<li><p>函数是通过赋值(对象引用)传递的</p>
<p>参数通过赋值传递给了函数,调用者以及函数通过引用共享对象,但是不需要别名</p>
<p>改变函数中的<strong>参数名</strong>并不会改变调用者中的变量名,但是改变传递的可变对象可以改变调用者共享的那个对象</p>
</li>
<li><p>参数、返回值以及变量并不是声明</p>
<p>在函数中没有类型约束,可以传递任意类型的参数给函数,函数也可以返回任意类型的对象</p>
<p>所以一个函数可以用在很多类型的对象上,任意支持兼容接口(方法和表达式)的对象都能使用,无论它们是什么类型</p>
</li>
</ul>
</blockquote>
<h3 id="def语句"><a href="#def语句" class="headerlink" title="def语句"></a>def语句</h3><p><code>def</code>语句格式为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> &lt;<span class="title">name</span>&gt;<span class="params">(arg1,arg2,...,argN)</span>:</span></span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure>

<p><code>def</code>语句包含了首行并有一个缩进的代码块跟随在后边,这个代码块就是函数的的主体</p>
<p>首行</p>
<blockquote>
<ul>
<li>def`的首行定义了函数名,将函数名赋值为函数对象</li>
<li>在括号中包含了0个以上的参数(形参).函数调用时,参数名赋值为括号中传递来的对象</li>
</ul>
</blockquote>
<p>函数主体</p>
<blockquote>
<ul>
<li>函数主体包含一条可选<code>return</code>语句,表示函数调用的结束,并将结果返回至函数调用出,它可以在函数主体的任何地方,没有<code>return</code>时函数在执行完函数主体时结束并返回<code>None</code>对象</li>
<li>函数可以有<code>yield</code>语句,产生一系列值在每次调用时返回</li>
</ul>
</blockquote>
<h3 id="def语句是实时执行的"><a href="#def语句是实时执行的" class="headerlink" title="def语句是实时执行的"></a>def语句是实时执行的</h3><p><code>def</code>语句在运行时创建一个新的函数对象,并将其赋值给一个变量名,<code>def</code>之中的代码在函数调用后解释</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> test:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span>		<span class="comment"># Define func this way</span></span><br><span class="line">		...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span>		<span class="comment"># Or else this way</span></span><br><span class="line">		...</span><br><span class="line">...</span><br><span class="line">func()</span><br><span class="line">othername = func	<span class="comment"># Assign function object</span></span><br><span class="line">othername()			<span class="comment"># Cakk func again</span></span><br></pre></td></tr></table></figure>

<p><code>def</code>语句可以出现在语句可以出现的地方,包括嵌套在其他语句中</p>
<p>函数名只是引用了函数对象的变量,可以通过新的变量名进行调用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span> ...		<span class="comment"># Create function object</span></span><br><span class="line">func()				<span class="comment"># Call object</span></span><br><span class="line">func.attr = value	<span class="comment"># Attach attributes</span></span><br></pre></td></tr></table></figure>

<p>函数允许任意的属性附加到记录信息以供随后使用</p>
<hr>
<h2 id="第一个例子-定义和调用"><a href="#第一个例子-定义和调用" class="headerlink" title="第一个例子:定义和调用"></a>第一个例子:定义和调用</h2><p>函数描绘了两个方面</p>
<ul>
<li>定义:<code>def</code>创建一个函数</li>
<li>调用:表达式告诉Python去运行函数主体</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">times</span><span class="params">(x, y)</span>:</span>	<span class="comment"># Create and assign function</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * y	<span class="comment"># Body executed when called</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当Python运行到<code>def</code>语句时会创建一个新的函数对象,封装这个函数的代码并将这个对象赋值给变量名</p>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">times</span><span class="params">(x, y)</span>:</span>	<span class="comment"># Create and assign function</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * y	<span class="comment"># Body executed when called</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>times(<span class="number">2</span>, <span class="number">4</span>)			<span class="comment"># Arguments in parentheses</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = times(<span class="number">3.14</span>, <span class="number">4</span>)	<span class="comment"># Sace the result object</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">12.56</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>times(<span class="string">'Ni'</span>, <span class="number">4</span>)		<span class="comment"># Functions are "typeless"</span></span><br><span class="line"><span class="string">'NiNiNiNi'</span></span><br></pre></td></tr></table></figure>

<p><code>def</code>语句运行后,可以在程序中通过在函数名后增加括号调用函数</p>
<p>括号中可以包含一个或多个对象参数,这些参数通过赋值传递给函数头部的参数名</p>
<p><code>return</code>语句返回的对象可以赋值给另一个变量</p>
<p>由于在Python中未对变量、参数或者返回值有变量的声明,所以可以把<code>*</code>用作数字的乘法或是序列的重复</p>
<h3 id="Python中的多态"><a href="#Python中的多态" class="headerlink" title="Python中的多态"></a>Python中的多态</h3><p>表达式的意义取决于表达式中对象类型的行为称为多态</p>
<p>函数的参数支持所有的对象类型,只要对象支持所预期的接口,函数就能处理,否则会检测到错误并自动抛出一个异常</p>
<p>Python为对象编写接口,而不是数据类型编写接口</p>
<hr>
<h2 id="第二个例子-寻找序列的交集"><a href="#第二个例子-寻找序列的交集" class="headerlink" title="第二个例子:寻找序列的交集"></a>第二个例子:寻找序列的交集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq1 = <span class="string">"spam"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq2 = <span class="string">"scam"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> seq1:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> x <span class="keyword">in</span> seq2:</span><br><span class="line"><span class="meta">... </span>            res.append(x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">[<span class="string">'s'</span>, <span class="string">'a'</span>, <span class="string">'m'</span>]</span><br></pre></td></tr></table></figure>

<p>这个程序被设置为只能列出定义好的变量并且不能继续使用</p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>编写寻找序列的交集可以将<code>for</code>循环封装在一个函数之中</p>
<blockquote>
<ul>
<li>把代码放在函数中能够成为一个想运行多少次就运行多少次的工具</li>
<li>调用者可以传递任意类型的参数,函数对于任意两个希望寻找其交集的序列(或者其他可迭代的类型)都是通用的</li>
<li>当逻辑由一个函数进行封装的时候,需要修改重复性的任务时,只需要在函数里进行修改搜索交集的方式就可以了</li>
<li>在模块文件中编写函数意味着它可以被计算机中的任意程序来导入和重用</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(seq1, seq2)</span>:</span></span><br><span class="line">	res = []					<span class="comment"># Start empty</span></span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> seq1:				<span class="comment"># Scan seq1</span></span><br><span class="line">		<span class="keyword">if</span> x <span class="keyword">in</span> seq2:			<span class="comment"># Common item?</span></span><br><span class="line">			res.append(x)		<span class="comment"># Add to end</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>将代码封装在函数中,使它成为一个通用搜索交集的工具</p>
<h3 id="调用-1"><a href="#调用-1" class="headerlink" title="调用"></a>调用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(seq1, seq2)</span>:</span></span><br><span class="line"><span class="meta">... </span>    res = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> x <span class="keyword">in</span> seq1:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> x <span class="keyword">in</span> seq2:</span><br><span class="line"><span class="meta">... </span>                    res.append(x)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> res</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">"SPAM"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">"SCAM"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>intersect(s1, s2)		<span class="comment"># Strings</span></span><br><span class="line">[<span class="string">'S'</span>, <span class="string">'A'</span>, <span class="string">'M'</span>]</span><br></pre></td></tr></table></figure>

<p>在<code>def</code>语句运行后,可以通过在括号中传递对象来调用这个函数</p>
<h3 id="重访多态"><a href="#重访多态" class="headerlink" title="重访多态"></a>重访多态</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(seq1, seq2)</span>:</span></span><br><span class="line"><span class="meta">... </span>    res = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> x <span class="keyword">in</span> seq1:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> x <span class="keyword">in</span> seq2:</span><br><span class="line"><span class="meta">... </span>                    res.append(x)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> res</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = interset([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="number">1</span>, <span class="number">4</span>))		<span class="comment"># Mixed types</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x									<span class="comment"># Saved result object</span></span><br><span class="line">[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>Python中的函数是多态的,只要函数参数类型支持拓展对象接口就可以处理</p>
<p>当传入了不支持这些接口的对象,Python将呼自动检测出不匹配,并抛出一个异常</p>
<h3 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h3><p>本地变量只在<code>def</code>内的函数中可见,并且仅在函数运行时存在</p>
<blockquote>
<ul>
<li>在函数内被赋值的变量是本地变量</li>
<li>通过赋值传入的参数是本地变量</li>
</ul>
</blockquote>
<p>所有的本地变量都会在函数调用时出现,在函数退出时消失</p>
<p><code>return</code>返回结果对象,引用结果对象的本地变量消失</p>
<hr>
<h2 id="本章习题"><a href="#本章习题" class="headerlink" title="本章习题"></a>本章习题</h2><ol>
<li><p>编写函数有什么意义</p>
<blockquote>
<p>函数是Python避免程序代码冗余的最基本方式:把代码分解成函数,意味着未来只有一个运算的代码的拷贝需要更新</p>
<p>函数是Python中代码重用的基本单位:在函数中包装代码,就使其成为可再利用的工具,可在许多程序中调用它</p>
<p>函数可让我们把复杂系统分割为可管理的部分,而每一部分都可独立进行开发</p>
</blockquote>
</li>
<li><p>什么时候Python将会创建函数</p>
<blockquote>
<p>当Python运行到并执行<code>def</code>语句时,函数就会被创建,这个语句会创建函数对象,并将其赋值给函数名</p>
</blockquote>
</li>
<li><p>当一个函数没有<code>return</code>语句时，它将返回什么</p>
<blockquote>
<p>如果控制流程来到函数主体末尾并没有运行return语句,函数就会传回<code>None</code>对象</p>
<p>这类函数通常是通过表达式语句调用,并将其None结果赋值给变量通常是没有意义的</p>
</blockquote>
</li>
<li><p>在函数定义内部的语句什么时候运行</p>
<blockquote>
<p>函数主体(嵌套在函数定义语句中的代码)在函数稍后通过一个调用表达式调用时执行</p>
<p>函数每次被调用,主体都会全新运行一次</p>
</blockquote>
</li>
<li><p>检查传入函数的对象类型有什么错误</p>
<blockquote>
<p>检查传入函数的对象类型,实质上就是破坏函数的灵活性,把函数限制在特定的类型上</p>
<p>没有这类检查时,函数可能处理所有的对象类型:任何支持函数所预期的接口的对象都能用(接口一词是指函数所执行的一组方法和表达式运算符)</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="第十七章-作用域"><a href="#第十七章-作用域" class="headerlink" title="第十七章 作用域"></a>第十七章 作用域</h1><blockquote>
<ul>
<li>本章深入介绍Python作用域(变量定义以及查找的地方)以及参数传递(传递给函数作为其输入对象的方式)</li>
<li>学习嵌套函数作用域和函数属性</li>
<li>学习通用的设计观点</li>
</ul>
</blockquote>
<hr>
<h2 id="Python作用域基础"><a href="#Python作用域基础" class="headerlink" title="Python作用域基础"></a>Python作用域基础</h2><p>Python中变量名在赋值时绑定到特定的命名空间,被赋值的位置决定了这个变量名能被访问到的作用域</p>
<p>创建、改变或查找变量名都是在命名空间中进行的</p>
<p>变量的作用域有变量在程序文件中源代码的位置决定,而不是由函数调用决定,称为语义作用域</p>
<p>函数中的所有变量名与这个函数的命名空间相关联</p>
<blockquote>
<ul>
<li>一个在<code>def</code>内定义的变量名能够被<code>def</code>内的代码使用,不能在函数的外部引用这样的变量名</li>
<li><code>def</code>之中的变量名与<code>def</code>之外的变量名并不冲突,即使别处使用相同的变量名</li>
</ul>
</blockquote>
<p>不同地方赋值变量所对应的作用域</p>
<blockquote>
<ul>
<li>如果一个变量在<code>def</code>内赋值,它被定位在这个函数之内</li>
<li>如果一个变量在一个嵌套的<code>def</code>中赋值,对于嵌套的函数来说,它是非本地的</li>
<li>如果在<code>def</code>之外赋值,它就是整个文件全局的</li>
</ul>
</blockquote>
<h3 id="作用域法则"><a href="#作用域法则" class="headerlink" title="作用域法则"></a>作用域法则</h3><p>函数提供了嵌套的命名空间(作用域),使其内部使用的变量名本地化,以便函数内部使用的变量名不会与此函数外的变量名产生冲突</p>
<ul>
<li>函数定义的本地作用域与模块定义的全局作用域关系</li>
</ul>
<blockquote>
<ul>
<li><p>内嵌模块是全局作用域</p>
<p>每个模块都是一个<strong>全局作用域</strong>,即一个模块文件顶层的变量的命名空间</p>
<p>其他模块文件的全局变量称为成为一个模块对象的属性,能够像简单的变量一样使用</p>
</li>
<li><p>全局作用域的作用范围仅限于单个文件</p>
<p>全局指在一个文件的顶层的变量名仅对这个文件内部的代码而言是全局的</p>
<p>变量名由模块文件分开,只有精确地导入一个模块文件才能够使用这个文件中定义的变量名</p>
</li>
<li><p>每次对函数的调用都创建了一个新的本地作用域</p>
</li>
<li><p>赋值的变量名除非声明为全局变量或非本地变量,否则均为本地变量</p>
<p>所有函数定义内部的变量名是位于本地作用域内的,需要通过<code>global</code>语句给一个在函数内部却需要位于模块文件顶层命名空间的变量名赋值</p>
<p>通过<code>nonlocal</code>语句给位于一个嵌套的<code>def</code>中的名称赋值</p>
</li>
<li><p>所有其他的变量名都可以归纳为本地、全局或者内置的</p>
<p>内置的变量名由Python的预定义<code>__builtin__</code>模块提供</p>
</li>
</ul>
</blockquote>
<ul>
<li>交互模式运行的代码输入到<code>__main__</code>模块的内置模块中,所以交互模式也在模块中创建名称,遵守常规的作用域规则</li>
<li>一个函数内部的任何类型的赋值都会把变量名划定为本地的,包括<code>=</code>语句、<code>import</code>中的模块名称、<code>def</code>中的函数名称、函数参数名称等</li>
<li>具有可变性的对象只有在对变量名赋值时才可以划分为本地对象,对一个名称赋值并不是修改一个对象</li>
</ul>
<h3 id="变量名解析-LEGB原则"><a href="#变量名解析-LEGB原则" class="headerlink" title="变量名解析:LEGB原则"></a>变量名解析:LEGB原则</h3><p>所有在函数<code>def</code>语句或<code>lambda</code>语句内赋值的变量名默认均为本地变量</p>
<p>函数能够在函数内部以及全局作用域直接使用变量名,但是必须声明为非本地变量和全局变量去改变其属性</p>
<p>对于<code>def</code>语句</p>
<blockquote>
<ul>
<li>变量名引用分为三个作用域进行查找:首先是本地,之后是函数内(如果有的话),之后全局,最后是内置</li>
<li>在默认情况下,变量名赋值会创建或者改变本地变量</li>
<li>全局声明和非本地声明将赋值的变量名映射到模块文件内部的作用域</li>
</ul>
</blockquote>
<p>Python变量名解析机制有时称为LEGB法则</p>
<blockquote>
<ul>
<li>当在函数中使用未认证的变量名时,Python搜索4个作用域[<strong>本地作用域(L)</strong>、上一层结构中<code>def</code>或<code>lambda</code>的<strong>本地作用域(E)</strong>、<strong>全局作用域(G)</strong>、<strong>内置作用域(B)</strong>]并且在第一处能够找到这个变量名的地方停下来,如果在搜索中没有找到变量名会报错</li>
<li>当在函数中给一个变量名赋值时,Python总是创建或改变为本地作用域的变量名或者显式的声明为全局变量</li>
<li>当在所有函数之外给一个变量名赋值时,本地作用域与全局作用域是相同的</li>
</ul>
</blockquote>
<h3 id="作用域实例"><a href="#作用域实例" class="headerlink" title="作用域实例"></a>作用域实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global scope</span></span><br><span class="line">X = <span class="number">99</span>				<span class="comment"># X and func assigned in module:global</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(Y)</span>:</span>		<span class="comment"># Y and Z assigned in function:locals</span></span><br><span class="line">	<span class="comment"># Local scope</span></span><br><span class="line">	Z = X + Y		<span class="comment"># X is a global</span></span><br><span class="line">	<span class="keyword">return</span> Z</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>)				<span class="comment"># func in module:result = 100</span></span><br></pre></td></tr></table></figure>

<p>变量名隔离机制的意义在于本地变量是作为临时的变量名,只有在函数运行时才需要它们,不会与模块命名空间内的变量或其他函数内的变量产生冲突</p>
<p><strong>全局变量名</strong>:X, func</p>
<p>X与func是在模块文件顶层注册的所以是全局变量,它能够在函数内部进行引用而不需要特意声明为全局变量</p>
<p>def语句在这个模块文件顶层将一个函数对象赋值给了变量名func</p>
<p><strong>本地变量名</strong>:Y, Z</p>
<p>Y和Z是本地变量(并且只在函数运行时存在),因为他们都是在函数定义内部进行赋值的:Z是通过=语句赋值的,而Y是由于参数总是通过赋值来进行传递的</p>
<h3 id="内置作用域"><a href="#内置作用域" class="headerlink" title="内置作用域"></a>内置作用域</h3><p>内置作用域是<code>__builtin__</code>的内置模块,必须先使用<code>import</code>语句导入才能使用内置作用域</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> builtins</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(builtins)</span><br><span class="line">[<span class="string">'ArithmeticError'</span>, <span class="string">'AssertionError'</span>, <span class="string">'AttributeError'</span>, <span class="string">'BaseException'</span>, <span class="string">'BlockingIOError'</span>, <span class="string">'BrokenPipeError'</span>, <span class="string">'BufferError'</span>, <span class="string">'BytesWarning'</span>, <span class="string">'ChildProcessError'</span>, <span class="string">'ConnectionAbortedError'</span>, <span class="string">'ConnectionError'</span>, <span class="string">'ConnectionRefusedError'</span>, <span class="string">'ConnectionResetError'</span>, <span class="string">'DeprecationWarning'</span>, <span class="string">'EOFError'</span>, <span class="string">'Ellipsis'</span>, <span class="string">'EnvironmentError'</span>, <span class="string">'Exception'</span>, <span class="string">'False'</span>, <span class="string">'FileExistsError'</span>, <span class="string">'FileNotFoundError'</span>, <span class="string">'FloatingPointError'</span>, <span class="string">'FutureWarning'</span>, <span class="string">'GeneratorExit'</span>, <span class="string">'IOError'</span>, <span class="string">'ImportError'</span>, <span class="string">'ImportWarning'</span>, <span class="string">'IndentationError'</span>, <span class="string">'IndexError'</span>, <span class="string">'InterruptedError'</span>, <span class="string">'IsADirectoryError'</span>, <span class="string">'KeyError'</span>, <span class="string">'KeyboardInterrupt'</span>, <span class="string">'LookupError'</span>, <span class="string">'MemoryError'</span>, <span class="string">'ModuleNotFoundError'</span>, <span class="string">'NameError'</span>, <span class="string">'None'</span>, <span class="string">'NotADirectoryError'</span>, <span class="string">'NotImplemented'</span>, <span class="string">'NotImplementedError'</span>, <span class="string">'OSError'</span>, <span class="string">'OverflowError'</span>, <span class="string">'PendingDeprecationWarning'</span>, <span class="string">'PermissionError'</span>, <span class="string">'ProcessLookupError'</span>, <span class="string">'RecursionError'</span>, <span class="string">'ReferenceError'</span>, <span class="string">'ResourceWarning'</span>, <span class="string">'RuntimeError'</span>, <span class="string">'RuntimeWarning'</span>, <span class="string">'StopAsyncIteration'</span>, <span class="string">'StopIteration'</span>, <span class="string">'SyntaxError'</span>, <span class="string">'SyntaxWarning'</span>, <span class="string">'SystemError'</span>, <span class="string">'SystemExit'</span>, <span class="string">'TabError'</span>, <span class="string">'TimeoutError'</span>, <span class="string">'True'</span>, <span class="string">'TypeError'</span>, <span class="string">'UnboundLocalError'</span>, <span class="string">'UnicodeDecodeError'</span>, <span class="string">'UnicodeEncodeError'</span>, <span class="string">'UnicodeError'</span>, <span class="string">'UnicodeTranslateError'</span>, <span class="string">'UnicodeWarning'</span>, <span class="string">'UserWarning'</span>, <span class="string">'ValueError'</span>, <span class="string">'Warning'</span>, <span class="string">'ZeroDivisionError'</span>, <span class="string">'_'</span>, <span class="string">'__build_class__'</span>, <span class="string">'__debug__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__import__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'abs'</span>, <span class="string">'all'</span>, <span class="string">'any'</span>, <span class="string">'ascii'</span>, <span class="string">'bin'</span>, <span class="string">'bool'</span>, <span class="string">'bytearray'</span>, <span class="string">'bytes'</span>, <span class="string">'callable'</span>, <span class="string">'chr'</span>, <span class="string">'classmethod'</span>, <span class="string">'compile'</span>, <span class="string">'complex'</span>, <span class="string">'copyright'</span>, <span class="string">'credits'</span>, <span class="string">'delattr'</span>, <span class="string">'dict'</span>, <span class="string">'dir'</span>, <span class="string">'divmod'</span>, <span class="string">'enumerate'</span>, <span class="string">'eval'</span>, <span class="string">'exec'</span>, <span class="string">'exit'</span>, <span class="string">'filter'</span>, <span class="string">'float'</span>, <span class="string">'format'</span>, <span class="string">'frozenset'</span>, <span class="string">'getattr'</span>, <span class="string">'globals'</span>, <span class="string">'hasattr'</span>, <span class="string">'hash'</span>, <span class="string">'help'</span>, <span class="string">'hex'</span>, <span class="string">'id'</span>, <span class="string">'input'</span>, <span class="string">'int'</span>, <span class="string">'isinstance'</span>, <span class="string">'issubclass'</span>, <span class="string">'iter'</span>, <span class="string">'len'</span>, <span class="string">'license'</span>, <span class="string">'list'</span>, <span class="string">'locals'</span>, <span class="string">'map'</span>, <span class="string">'max'</span>, <span class="string">'memoryview'</span>, <span class="string">'min'</span>, <span class="string">'next'</span>, <span class="string">'object'</span>, <span class="string">'oct'</span>, <span class="string">'open'</span>, <span class="string">'ord'</span>, <span class="string">'pow'</span>, <span class="string">'print'</span>, <span class="string">'property'</span>, <span class="string">'quit'</span>, <span class="string">'range'</span>, <span class="string">'repr'</span>, <span class="string">'reversed'</span>, <span class="string">'round'</span>, <span class="string">'set'</span>, <span class="string">'setattr'</span>, <span class="string">'slice'</span>, <span class="string">'sorted'</span>, <span class="string">'staticmethod'</span>, <span class="string">'str'</span>, <span class="string">'sum'</span>, <span class="string">'super'</span>, <span class="string">'tuple'</span>, <span class="string">'type'</span>, <span class="string">'vars'</span>, <span class="string">'zip'</span>]</span><br></pre></td></tr></table></figure>

<p><code>dir</code>调用得到的变量名组成了Python中的内置作用域,其中前一半是内置的异常,后一半是内置函数</p>
<p>根据<code>LEGB</code>法则,Python最后自动搜索这个模块,不需要导入即可使用这些变量名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>zip				<span class="comment"># The normal way</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">zip</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">builtins</span>.<span class="title">zip</span>	# <span class="title">The</span> <span class="title">hard</span> <span class="title">way</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">zip</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过<code>LEGB</code>法则或者手动导入<code>__builtin__</code>模块可以引用内置函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hider</span><span class="params">()</span>:</span></span><br><span class="line">	open = <span class="string">'spam'</span>		<span class="comment"># Local variable,hides built-in</span></span><br><span class="line">	...</span><br><span class="line">	open(<span class="string">'data.txt'</span>)	<span class="comment"># This won't open a file now in this scope!</span></span><br><span class="line"></span><br><span class="line">X = <span class="number">88</span>					<span class="comment"># Global X</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">	X = <span class="number">99</span>				<span class="comment"># Local X:hides global</span></span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line">print(X)				<span class="comment"># Prints 88:unchanged</span></span><br></pre></td></tr></table></figure>

<p>根据<code>LEGB</code>查找流程,在本地作用域的变量名可能会覆盖在全局作用域和内置作用域的有着相同变量名的变量</p>
<h3 id="在Python-2-6中违反通用性"><a href="#在Python-2-6中违反通用性" class="headerlink" title="在Python 2.6中违反通用性"></a>在Python 2.6中违反通用性</h3><p>由于在Python 2.6中名称<code>True</code>和<code>False</code>是内置作用域中的变量而不是保留字,通过<code>True = False</code>语句为它们重新赋值是可能的,这样只会在它出现的作用域中重新定义<code>True</code>,其他作用域仍然在内置作用域中查找</p>
<p>在Python 2.6中可以使用<code>builtin.True = False</code>在整个Python过程中把<code>True</code>重置为<code>False</code></p>
<p>Python 3.0中取消了这种类型的赋值,<code>True</code>和<code>False</code>和<code>None</code>一样作为保留字</p>
<hr>
<h2 id="global语句"><a href="#global语句" class="headerlink" title="global语句"></a>global语句</h2><p><code>global</code>语句是一个命名空间的声明,在函数中<strong>创建</strong>或<strong>修改</strong>一个或多个全局变量名</p>
<blockquote>
<ul>
<li>全局变量是位于模块文件内部的顶层的变量名</li>
<li>全局变量如果是在函数内被赋值的话,必须经过声明</li>
<li>全局变量名在函数的内部不经过声明也可以被引用</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X = <span class="number">88</span>			<span class="comment"># Global X</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> X</span><br><span class="line">	X = <span class="number">99</span>		<span class="comment"># Global X:outside def</span></span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line">print(X)		<span class="comment"># Prints 99</span></span><br></pre></td></tr></table></figure>

<p><code>global</code>语句包含关键字<code>global</code>,其后跟着一个或多个由逗号分开的变量名,当在函数主体被赋值或引用时,所有列出来的变量名将被<strong>映射到整个模块的作用域</strong></p>
<h3 id="最小化全局变量"><a href="#最小化全局变量" class="headerlink" title="最小化全局变量"></a>最小化全局变量</h3><p>若将本地变量改为全局变量,由于变量的值取决于函数调用的顺序,而函数自身是任意顺序进行排列的,导致调试起来变得困难,所以尽可能少的使用全局变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X = <span class="number">99</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> X</span><br><span class="line">	X = <span class="number">88</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> X</span><br><span class="line">	X = <span class="number">77</span></span><br></pre></td></tr></table></figure>

<p><code>global</code>声明使相同变量名的值取决于最后调用的函数</p>
<p>全局变量不像那些依赖于包含本地变量的函数构成的代码,全局变量使得程序更难理解和使用</p>
<p>当不使用面向对象的编程方法以及类的话,全局变量是Python中最直接保存状态信息的方法,但本地变量在函数返回时消失</p>
<p>全局变量在并行线程中在不同的函数之间称为了共享内存,扮演了通讯工具的角色</p>
<h3 id="最小化文件间的修改"><a href="#最小化文件间的修改" class="headerlink" title="最小化文件间的修改"></a>最小化文件间的修改</h3><p>编写程序往往不会直接修改另一个文件的变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># first.py</span></span><br><span class="line">X = <span class="number">99</span>				<span class="comment"># This code doesn't know about second.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># second.py</span></span><br><span class="line"><span class="keyword">import</span> first</span><br><span class="line">print(first.X)</span><br><span class="line">first.X = <span class="number">88</span></span><br></pre></td></tr></table></figure>

<p>每个模块都是自包含的命名空间,必须导入一个模块才能在另一个模块中看到它内部的变量</p>
<p>一个模块文件的全局变量被导入后就成为了这个模块对象的一个属性</p>
<p>一个模块对导入模块的变量重新赋值可能很难发现,并且会让两个文件有过于强的相关性,没有其中一个文件很难理解或重用另一个文件,导致代码不灵活或引发bug</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># first.py</span></span><br><span class="line">X = <span class="number">99</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setX</span><span class="params">(new)</span>:</span></span><br><span class="line">	<span class="keyword">global</span> X</span><br><span class="line">	X = new</span><br><span class="line"></span><br><span class="line"><span class="comment"># second.py</span></span><br><span class="line"><span class="keyword">import</span> first</span><br><span class="line">first.setX(<span class="number">88</span>)</span><br></pre></td></tr></table></figure>

<p>在文件间进行通信最好的办法是通过调用函数,传递参数,得到其返回值,使用<code>accessor</code>函数管理这种变化</p>
<p>这种办法可以提高可读性和可维护性</p>
<h3 id="其他访问全局变量的方法"><a href="#其他访问全局变量的方法" class="headerlink" title="其他访问全局变量的方法"></a>其他访问全局变量的方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># thismod.py</span></span><br><span class="line"></span><br><span class="line">var = <span class="number">99</span>							<span class="comment"># Global variable == module attribute</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loval</span><span class="params">()</span>:</span></span><br><span class="line">	var = <span class="number">0</span>							<span class="comment"># Change local var</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">glob1</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> var						<span class="comment"># Declare  global(normal)</span></span><br><span class="line">	var += <span class="number">1</span>						<span class="comment"># Change global var</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">glob2</span><span class="params">()</span>:</span></span><br><span class="line">	var = <span class="number">0</span>							<span class="comment"># Change loval var</span></span><br><span class="line">	<span class="keyword">import</span> thismod					<span class="comment"># Import myself</span></span><br><span class="line">	thismod.var += <span class="number">1</span>				<span class="comment"># Change global var</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">glob3</span><span class="params">()</span>:</span></span><br><span class="line">	var = <span class="number">0</span>							<span class="comment"># Change local var</span></span><br><span class="line">	<span class="keyword">import</span> sys						<span class="comment"># Import system table</span></span><br><span class="line">	glob = sys.modules[<span class="string">'thismod'</span>]	<span class="comment"># Get module object(or use __name__)</span></span><br><span class="line">	glob.var += <span class="number">1</span>					<span class="comment"># Change global var</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">	print(var)</span><br><span class="line">	local(); glob1(); glob2(); glob3()</span><br><span class="line">	print(var)</span><br></pre></td></tr></table></figure>

<p>全局变量构成了被导入对象的属性,能够通过使用导入嵌入的模块并对其属性进行赋值来伪造<code>global</code>语句</p>
<p>全局变量与模块的属性是等效的</p>
<hr>
<h2 id="作用域和嵌套函数"><a href="#作用域和嵌套函数" class="headerlink" title="作用域和嵌套函数"></a>作用域和嵌套函数</h2><p><code>LEGB</code>查找法则中<code>E</code>包括了任意嵌套函数内部的本地作用域</p>
<p>嵌套作用域也叫静态嵌套作用域</p>
<h3 id="嵌套作用域的细节"><a href="#嵌套作用域的细节" class="headerlink" title="嵌套作用域的细节"></a>嵌套作用域的细节</h3><blockquote>
<ul>
<li>一个引用首先在本地(函数内)作用域查找变量名;之后会在代码的语法上嵌套了的函数中的本地作用域,从内到外查找,之后查找当前的全局作用域(模块文件) ,最后再内置作用域内(模块_ builtin_ )</li>
<li>全局声明将会直接从全局(模块文件)作用域进行搜索。</li>
<li>在默认情况下,<strong>赋值</strong>会创建或改变了变量名的当前作用域<ul>
<li>如果在函数内部声明为全局变量,将会创建或改变变量名为整个模块的作用域</li>
<li>如果在函数内声明为<code>nonlocal</code>,赋值会修改最近的嵌套函数的本地作用域中的名称</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="嵌套作用域举例"><a href="#嵌套作用域举例" class="headerlink" title="嵌套作用域举例"></a>嵌套作用域举例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X = <span class="number">99</span>				<span class="comment"># Global scope name:not used</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">	X = <span class="number">88</span>			<span class="comment"># Enclosing def local</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">		print(X)	<span class="comment"># Reference made in nested def</span></span><br><span class="line">	f2()</span><br><span class="line"></span><br><span class="line">f1()				<span class="comment"># Prints 88:enclosing def local</span></span><br></pre></td></tr></table></figure>

<p><code>f1()</code>内的<code>def</code>语句生成一个函数,并将其赋值给变量名<code>f2</code>,<code>f2</code>是<code>f1</code>的本地作用域内的一个本地变量</p>
<p>通过<code>LEGB</code>法则,<code>f2</code>内的变量<code>x</code>自动映射了<code>f1</code>的本地作用域内的变量<code>x</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">	X = <span class="number">88</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">		print(X)	<span class="comment"># Remembers X in enclosing def scope</span></span><br><span class="line">	<span class="keyword">return</span> f2()		<span class="comment"># Return f2 but don't call it</span></span><br><span class="line"></span><br><span class="line">action = f1()		<span class="comment"># Make,return function</span></span><br><span class="line">action()			<span class="comment"># Call it now:prints 88</span></span><br></pre></td></tr></table></figure>

<p>嵌套作用域的查找法则在函数被返回后仍然有效</p>
<h4 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h4><p>作用域已不存在也能够记住嵌套作用域的变量值的函数叫做闭合或者工厂函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">maker</span><span class="params">(N)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(X)</span>:</span>			<span class="comment"># Make and return action</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> X ** N	<span class="comment"># action retains N fron enclosing scope</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> action</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = maker(<span class="number">2</span>)				<span class="comment"># Pass 2 to N</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f 							</span><br><span class="line">&lt;function maker.&lt;locals&gt;.action at <span class="number">0x104205a60</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">3</span>)						<span class="comment"># Pass 3 to X,N remembers 2:3 ** 2</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">4</span>)						<span class="comment"># 4 ** 2</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = maker(<span class="number">3</span>)				<span class="comment"># g remembers 3, f remembers 2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g(<span class="number">3</span>)						<span class="comment"># 3 ** 3</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">3</span>)						<span class="comment"># 3 ** 2</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>通过外层函数返回一个内嵌函数的引用</p>
<p>外层函数的本地作用域的变量作为执行的状态信息被内层函数保留了下来</p>
<p>当只调用内嵌函数时,尽管外部函数已经返回了值并退出,但仍会记住外层函数的本地作用域的变量名</p>
<p>如果再次调用外层函数,将得到一个新的有不同状态信息的嵌套函数,但最初的嵌套函数仍是原始的状态信息</p>
<p>对一个工厂函数的每次调用,都会得到自己的状态信息的集合</p>
<p>嵌套的作用域常常被<code>lambda</code>函数创建表达式使用,函数嵌套通常用作装饰器</p>
<p>类是一个更好的像这样进行”记忆”的选择</p>
<h4 id="使用默认参数来保留嵌套作用域的状态"><a href="#使用默认参数来保留嵌套作用域的状态" class="headerlink" title="使用默认参数来保留嵌套作用域的状态"></a>使用默认参数来保留嵌套作用域的状态</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">	x = <span class="number">88</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(x=x)</span>:</span>	<span class="comment"># Remember enclosing scope X with defaults</span></span><br><span class="line">		print(x)</span><br><span class="line">	f2()</span><br><span class="line"></span><br><span class="line">f1()				<span class="comment"># Prints(88)</span></span><br></pre></td></tr></table></figure>

<p><code>def</code>头部的<code>arg = val</code>语句表示参数<code>arg</code>在调用时没有值传入进来时默认使用值<code>val</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    x = <span class="number">88</span>		<span class="comment"># Pass x along instead of nesting</span></span><br><span class="line"><span class="meta">... </span>    f2(<span class="number">2</span>)		<span class="comment"># Forward reference okay</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>避免在<code>def</code>中嵌套<code>def</code>会降低复杂度</p>
<h4 id="嵌套作用域和lambda"><a href="#嵌套作用域和lambda" class="headerlink" title="嵌套作用域和lambda"></a>嵌套作用域和lambda</h4><p><code>lambda</code>和<code>def</code>语句相似,将会生成后面调用的一个新的函数</p>
<p><code>lambda</code>是一个表达式,能够使用在<code>def</code>中不能使用的地方</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">	x = <span class="number">4</span></span><br><span class="line">	action = (<span class="keyword">lambda</span> n: x ** n)		<span class="comment"># x remembered from enclosing def</span></span><br><span class="line">	<span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line">x = func()</span><br><span class="line">print(x(<span class="number">2</span>))							<span class="comment"># Prints 16, 4 ** 2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">	x = <span class="number">4</span></span><br><span class="line">	action (<span class="keyword">lambda</span> n, x=x:x ** n)	<span class="comment"># Pass x in manually</span></span><br><span class="line">	<span class="keyword">return</span> action</span><br></pre></td></tr></table></figure>

<p>由于嵌套作用域查找层,<code>lambda</code>能够看到所有在所编写的函数中可用的变量</p>
<p>可以使用默认参数从上层作用域传递值给<code>lambda</code></p>
<h4 id="作用域与带有循环变量的默认参数相比较"><a href="#作用域与带有循环变量的默认参数相比较" class="headerlink" title="作用域与带有循环变量的默认参数相比较"></a>作用域与带有循环变量的默认参数相比较</h4><p>如果在一个函数的循环中嵌套<code>lambda</code>或者<code>def</code>语句,并且嵌套的函数<strong>引用</strong>了外层作用域的循环变量,所有在这个循环中产生的函数都将是最后一次循环完成时被引用变量的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">makeActions</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    acts = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):						<span class="comment"># Tries to remember each i</span></span><br><span class="line"><span class="meta">... </span>            acts.append(<span class="keyword">lambda</span> x: i ** x)	<span class="comment"># All remember same last i</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> acts</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acts = makeActions()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acts[<span class="number">0</span>]</span><br><span class="line">&lt;function makeActions.&lt;locals&gt;.&lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x104205950</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acts[<span class="number">0</span>](<span class="number">2</span>)									<span class="comment"># All are 4 ** 2,value of last i</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acts[<span class="number">2</span>](<span class="number">2</span>)									<span class="comment"># This should be 2 ** 2</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acts[<span class="number">4</span>](<span class="number">2</span>)									<span class="comment"># This should be 4 ** 2</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>嵌套作用域中的变量在嵌套的函数被调用时才进行查找,所以它们实际上是最后一次循环迭代中循环变量的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">makeActions</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    acts = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):								<span class="comment"># Use defaults instead</span></span><br><span class="line"><span class="meta">... </span>            acts.append(<span class="keyword">lambda</span> x, i=i: i ** x)		<span class="comment"># Remember current i</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> acts</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acts = makeActions()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acts[<span class="number">0</span>](<span class="number">2</span>)											<span class="comment"># 0 ** 2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acts[<span class="number">2</span>](<span class="number">2</span>)											<span class="comment"># 2 ** 2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acts[<span class="number">4</span>](<span class="number">2</span>)											<span class="comment"># 4 ** 2</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>因为默认参数是在嵌套函数创建时评估的,必须使用默认参数把当前的值传递给嵌套作用域的变量,每一个函数记住自己的变量的值</p>
<h4 id="任意作用域的嵌套"><a href="#任意作用域的嵌套" class="headerlink" title="任意作用域的嵌套"></a>任意作用域的嵌套</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    x = <span class="number">99</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>                    print(x)	<span class="comment"># Found in f1's local scope!</span></span><br><span class="line"><span class="meta">... </span>            f3()</span><br><span class="line"><span class="meta">... </span>    f2()</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line"><span class="number">99</span></span><br></pre></td></tr></table></figure>

<p>Python会在搜索模块的全局作用域之前从内至外在所有内嵌的<code>def</code>中搜索本地作用域</p>
<hr>
<h2 id="nonlocal语句"><a href="#nonlocal语句" class="headerlink" title="nonlocal语句"></a>nonlocal语句</h2><p><code>nonlocal</code>语句使内层的<code>def</code>函数可以对<strong>任意层外层的嵌套函数</strong>的作用域的变量进行读取和写入访问</p>
<p>在声明<code>nonlocal</code>变量时,变量名必须已经存在于该外层的嵌套函数的作用域中</p>
<h3 id="nonlocal基础"><a href="#nonlocal基础" class="headerlink" title="nonlocal基础"></a>nonlocal基础</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">nonlocal</span> name1, name2, ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>nonlocal</code>只在函数内有意义,允许一个内层函数来修改一个任意层外层函数的作用域中定义的一个或多个变量名</p>
</li>
<li><p><code>nonlocal</code>使得变量名的查找直接从外层的<code>def</code>的作用域开始,而不是从声明函数的本地作用域开始</p>
</li>
<li><p><code>nonlocal</code>中列出的名称必须在外层的<code>def</code>中提前定义过,否则产生一个错误</p>
</li>
<li><p><code>nonlocal</code>变量名只能出现在外层的<code>def</code>中,而不能在模块的全局作用域中或<code>def</code>之外的内置作用域中</p>
</li>
<li><p><code>nonlocal</code>声明不会改变通用的名称引用<code>LEGB</code>规则</p>
<p>查找规则的限制</p>
<ul>
<li><code>global</code>使得作用域查找从嵌套的模块的作用域开始,并且允许对那里的名称赋值,如果名称不存在于该模块中,作用域查找继续到内置作用域,但是,对全局名称的赋值总是在模块的作用域中创建或修改它们</li>
<li><code>nonlocal</code>限制作用域查找只是嵌套的<code>def</code>,不会继续到全局或内置作用域,要求名称已经提前创建,并且允许对它们赋值</li>
</ul>
</li>
</ul>
<h3 id="nonlocal应用"><a href="#nonlocal应用" class="headerlink" title="nonlocal应用"></a>nonlocal应用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">tester</span><span class="params">(start)</span>:</span></span><br><span class="line"><span class="meta">... </span>    state = start					<span class="comment"># Referencing nonlocals works normally</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">(label)</span>:</span></span><br><span class="line"><span class="meta">... </span>            print(label, state)		<span class="comment"># Remembers state in enclosing scope</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> nested</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F = tester(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'spam'</span>)</span><br><span class="line">spam <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'ham'</span>)</span><br><span class="line">ham <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">tester</span><span class="params">(start)</span>:</span></span><br><span class="line"><span class="meta">... </span>    state = start</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">(label)</span>:</span></span><br><span class="line"><span class="meta">... </span>            print(label, state)</span><br><span class="line"><span class="meta">... </span>            state += <span class="number">1</span>				<span class="comment"># Cannot change by default</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> nested</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F = tester(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'spam'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> nested</span><br><span class="line">UnboundLocalError: local variable <span class="string">'state'</span> referenced before assignment</span><br></pre></td></tr></table></figure>

<p>默认情况下,不允许修改嵌套的<code>def</code>作用域中的名称</p>
<h4 id="使用nonlocal进行修改"><a href="#使用nonlocal进行修改" class="headerlink" title="使用nonlocal进行修改"></a>使用nonlocal进行修改</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">tester</span><span class="params">(start)</span>:</span></span><br><span class="line"><span class="meta">... </span>    state = start					<span class="comment"># Each call gets its own state</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">(label)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">nonlocal</span> state			<span class="comment"># Remembers state in enclosing scope</span></span><br><span class="line"><span class="meta">... </span>            print(label, state)</span><br><span class="line"><span class="meta">... </span>            state += <span class="number">1</span>				<span class="comment"># Allowed to change it if nonlocal</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> nested</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F = tester(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'spam'</span>)							<span class="comment"># Increments state on each call</span></span><br><span class="line">spam <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'ham'</span>)</span><br><span class="line">ham <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'eggs'</span>)</span><br><span class="line">eggs <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G = tester(<span class="number">42</span>)						<span class="comment"># Make a new tester that starts at 42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G(<span class="string">'spam'</span>)</span><br><span class="line">spam <span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G(<span class="string">'eggs'</span>)							<span class="comment"># My state information updated to 43</span></span><br><span class="line">eggs <span class="number">43</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'bacon'</span>)							<span class="comment"># But F's is where it left off:at 3</span></span><br><span class="line">bacon <span class="number">3</span>									<span class="comment"># Each call has different state information</span></span><br></pre></td></tr></table></figure>

<p>使用<code>nonlocal</code>声明后即可修改变量,即使内层函数被返回后外层函数退出也是有效的</p>
<p>多次调用外层函数可以在内存中获得其<strong>状态信息</strong>的多个副本,互不影响</p>
<h4 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">tester</span><span class="params">(start)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">(label)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">nonlocal</span> state 			<span class="comment"># Nonlocals must already exist in enclosing def!</span></span><br><span class="line"><span class="meta">... </span>            state = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>            print(label, state)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> nested</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span></span><br><span class="line">SyntaxError: no binding <span class="keyword">for</span> <span class="keyword">nonlocal</span> <span class="string">'state'</span> found</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">tester</span><span class="params">(start)</span>:</span>					<span class="comment"># Globals don't have to exist yet when declared</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">(label)</span>:</span>				<span class="comment"># This creates the name in the module now</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">global</span> state</span><br><span class="line"><span class="meta">... </span>            state = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>            print(label, state)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> nested</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F = tester(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'abc'</span>)</span><br><span class="line">abc <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><code>nonlocal</code>语句声明的变量名必须在一个嵌套的<code>def</code>作用域中赋值过,否则会得到一个错误</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = <span class="number">99</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">tester</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">nonlocal</span> spam		<span class="comment"># Must be in a def, not the module!</span></span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'Current='</span>, spam)</span><br><span class="line"><span class="meta">... </span>            spam += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> nested</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span></span><br><span class="line">SyntaxError: no binding <span class="keyword">for</span> <span class="keyword">nonlocal</span> <span class="string">'spam'</span> found</span><br></pre></td></tr></table></figure>

<p><code>nonlocal</code>限制作用域查找仅为嵌套的<code>def</code>,不会在嵌套的模块的全局作用域或所有<code>def</code>之外的内置作用域中查找</p>
<h3 id="为什么使用nonlocal"><a href="#为什么使用nonlocal" class="headerlink" title="为什么使用nonlocal"></a>为什么使用nonlocal</h3><p>在Python中,有各种不同的办法来记住跨函数和方法的<strong>状态信息</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">tester</span><span class="params">(start)</span>:</span></span><br><span class="line"><span class="meta">... </span>    state = start					<span class="comment"># Each call gets its own state</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">(label)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">nonlocal</span> state			<span class="comment"># Remembers state in enclosing scope</span></span><br><span class="line"><span class="meta">... </span>            print(label, state)</span><br><span class="line"><span class="meta">... </span>            state += <span class="number">1</span>				<span class="comment"># Allowed to change it if nonlocal</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> nested</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F = tester(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'spam'</span>)</span><br><span class="line">spam <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><code>nonlocal</code>语句允许在内存中保持可变状态的多个副本,并且解决了在类无法保证的情况下的简单的状态的保持</p>
<p>对外层函数的每次调用都创建了可变信息的一个小小的自包含宝,可变信息的名称不会与程序的其他部分产生任何冲突</p>
<h4 id="与全局共享状态"><a href="#与全局共享状态" class="headerlink" title="与全局共享状态"></a>与全局共享状态</h4><p>直接把状态信息移到全局作用域实现<code>nonlocal</code>效果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">tester</span><span class="params">(start)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">global</span> state			<span class="comment"># Move it out to the module to change it</span></span><br><span class="line"><span class="meta">... </span>    state = start			<span class="comment"># global allows changese in module scope</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">(label)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">global</span> state</span><br><span class="line"><span class="meta">... </span>            print(label, state)</span><br><span class="line"><span class="meta">... </span>            state += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> nested</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F = tester(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'spam'</span>)					<span class="comment"># Each call increments shared global state</span></span><br><span class="line">spam <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'eggs'</span>)</span><br><span class="line">eggs <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G = tester(<span class="number">42</span>)				<span class="comment"># Resets state's single copy in global scope</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G(<span class="string">'toast'</span>)</span><br><span class="line">toast <span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G(<span class="string">'bacon'</span>)</span><br><span class="line">bacon <span class="number">43</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G(<span class="string">'ham'</span>)					<span class="comment"># Oops -- my counter has been overwritten!</span></span><br><span class="line">ham <span class="number">44</span></span><br></pre></td></tr></table></figure>

<p>内层函数和外层函数都需要使用<code>global</code>声明</p>
<p>这样做可能会引发全局作用域中的名称冲突,且只考虑到状态信息的单个共享副本,再次调用外层函数将会重新设置状态信息</p>
<h4 id="使用类的状态-预览"><a href="#使用类的状态-预览" class="headerlink" title="使用类的状态(预览)"></a>使用类的状态(预览)</h4><p>使用带有属性的类可以让状态信息的访问比隐式的范围查找规则更明确,通过利用显式属性赋值而不是作用域查找</p>
<p>类的每个实例都得到状态信息的一个新副本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">tester</span>:</span>							<span class="comment"># Class-based alternative</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, start)</span>:</span>			<span class="comment"># On object construction</span></span><br><span class="line"><span class="meta">... </span>            self.state = start			<span class="comment"># save state explicitly in new object</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">(self, label)</span>:</span></span><br><span class="line"><span class="meta">... </span>            print(label, self.state)	<span class="comment"># Reference state explicitly</span></span><br><span class="line"><span class="meta">... </span>            self.state += <span class="number">1</span>				<span class="comment"># Changes are always allowed</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F = tester(<span class="number">0</span>)							<span class="comment"># Create instance, invoke __init__</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F.nested(<span class="string">'spam'</span>)						<span class="comment"># F is passed to self</span></span><br><span class="line">spam <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F.nested(<span class="string">'ham'</span>)</span><br><span class="line">ham <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G = tester(<span class="number">42</span>)							<span class="comment"># Each instance gets new copy of state</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G.nested(<span class="string">'toast'</span>)						<span class="comment"># Changing one does not impact others</span></span><br><span class="line">toast <span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G.nested(<span class="string">'bacon'</span>)</span><br><span class="line">bacon <span class="number">43</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F.nested(<span class="string">'eggs'</span>)						<span class="comment"># F's state is where it left off</span></span><br><span class="line">eggs <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F.state									<span class="comment"># State may be assessed outside class</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>状态信息在对象创建的时候显式的保存在对象中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">tester</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, start)</span>:</span></span><br><span class="line"><span class="meta">... </span>            self.state = start</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, label)</span>:</span>			<span class="comment"># Intercept direct instance calls</span></span><br><span class="line"><span class="meta">... </span>            print(label, self.state)	<span class="comment"># So .nested() not required</span></span><br><span class="line"><span class="meta">... </span>            self.state += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>H = tester(<span class="number">99</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>H(<span class="string">'juice'</span>)								<span class="comment"># Invokes __call__</span></span><br><span class="line">juice <span class="number">99</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>H(<span class="string">'pancakes'</span>)</span><br><span class="line">pancakes <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p><code>__call__</code>获取一个实例上的直接调用</p>
<h4 id="使用函数属性的状态"><a href="#使用函数属性的状态" class="headerlink" title="使用函数属性的状态"></a>使用函数属性的状态</h4><p>附加给内层函数一个函数属性可以实现与<code>nonlocal</code>相同的效果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">tester</span><span class="params">(start)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">(label)</span>:</span></span><br><span class="line"><span class="meta">... </span>            print(label, nested.state)	<span class="comment"># nested is in enclosing scope</span></span><br><span class="line"><span class="meta">... </span>            nested.state += <span class="number">1</span>			<span class="comment"># Change attr,not nested itself</span></span><br><span class="line"><span class="meta">... </span>    nested.state = start				<span class="comment"># Initial state after func defined</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> nested</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F = tester(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'spam'</span>)								<span class="comment"># F is a 'nested' with state attached</span></span><br><span class="line">spam <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'ham'</span>)</span><br><span class="line">ham <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F.state									<span class="comment"># Can access state outside functions too</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G = tester(<span class="number">42</span>)							<span class="comment"># G has own state, doesn't overwrite F's</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G(<span class="string">'eggs'</span>)</span><br><span class="line">eggs <span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'ham'</span>)</span><br><span class="line">ham <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>内层函数的函数名是外层函数的一个本地对象,可以被外层函数自由地索引</p>
<p>由于内层函数只是对本地变量修改引用而不是赋值,所以不需要<code>nonlocal</code></p>
<hr>
<h2 id="本章习题-1"><a href="#本章习题-1" class="headerlink" title="本章习题"></a>本章习题</h2><ol>
<li><p>下面的代码会输出什么,为什么</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = <span class="string">'Spam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(X)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的输出是<code>&#39;Spam&#39;</code>,因为函数引用的是所在模块中的全局变量(因为不是在函数中赋值的,所以被当作是全局变量)</p>
</blockquote>
</li>
<li><p>下面的代码会输出什么,为什么</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = <span class="string">'Spam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    X = <span class="string">'NI!'</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(X)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的输出也是<code>&#39;Spam&#39;</code>,因为在函数中赋值变量会将其变成本地变量,从而隐藏了同名的全局变量</p>
<p><code>print</code>语句会找到没有发生改变的全局(模块)作用域中的变量</p>
</blockquote>
</li>
<li><p>下面的代码会打印什么内容,为什么</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = <span class="string">'Spam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    X = <span class="string">'NI!'</span></span><br><span class="line"><span class="meta">... </span>    print(X)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(X)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这会在一行上打印<code>&#39;NI&#39;</code>,在另一行打印<code>&#39;Spam&#39;</code>,因为函数中引用的变量会找到其本地变量,而print中引用的变量会找到其全局变量</p>
</blockquote>
</li>
<li><p>下面的代码会输出什么,为什么</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = <span class="string">'Spam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">global</span> X</span><br><span class="line"><span class="meta">... </span>    X = <span class="string">'NI'</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(X)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这次只打印了<code>&#39;NI&#39;</code>,因为全局声明会强制函数中赋值的变量引用其所在的全局作用域中的变量</p>
</blockquote>
</li>
<li><p>下面的代码会输出什么,为什么</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = <span class="string">'Spam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    X = <span class="string">'NI'</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>            print(X)</span><br><span class="line"><span class="meta">... </span>    nested()</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个例子的输出还是<code>&#39;NI&#39;</code>一行,而<code>&#39;Spam&#39;</code>在另一行,因为嵌套函数中的<code>print</code>语句会在所在的函数本地作用域中发现变量名,而末尾的<code>print</code>会在全局作用城中发现这个变量</p>
</blockquote>
</li>
<li><p>这段代码在Python 3.0下会输出什么,为什么</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    X = <span class="string">'NI'</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">nonlocal</span> X</span><br><span class="line"><span class="meta">... </span>            X = <span class="string">'Spam'</span></span><br><span class="line"><span class="meta">... </span>    nested()</span><br><span class="line"><span class="meta">... </span>    print(X)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个示例打印出<code>&#39;Spam&#39;</code>,因为<code>nonlocal</code>语句意味着在嵌套函数中对X赋值,以修改嵌套函数的本地作用域中的X</p>
<p>没有这条语句,这个赋值将会把X当作是嵌套函数的本地变量,使它成为一个不同的变量,那么这段代码将会打印出<code>&#39;NI&#39;</code></p>
</blockquote>
</li>
<li><p>举出三种或四种Python函数中保存状态信息的方法</p>
<blockquote>
<p>尽管函数返回的时候本地变量的值已经不在了,我们可以使用共享的全局变量、嵌套函数内的嵌套函数作用域引用,或者使用默认参数值来让一个Python函数保持状态信息,函数属性有时候允许把状态附加到函数自身,而不是在作用域中查找,另一种替代方法是使用类来OOP,有时候比其他任何基于作用域的技术更好地支持状态保持,因为它使得属性赋值很明确</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="第十八章-参数"><a href="#第十八章-参数" class="headerlink" title="第十八章 参数"></a>第十八章 参数</h1><blockquote>
<ul>
<li>学习Python中的参数传递的概念,即对象作为输入发送给函数的方式</li>
<li>介绍关键字参数、默认参数和任意参数收集器等工具</li>
<li>学习了可变参数如何表现出与其他的对象共享引用一样的行为</li>
</ul>
</blockquote>
<hr>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>函数传递参数时的关键点</p>
<blockquote>
<ul>
<li><p>参数的传递是通过自动将对象赋值给本地变量名来实现的</p>
<p>函数参数是调用者发送的的共享对象引用值</p>
<p>引用是以指针的形式实现的,所有的参数都是通过指针进行传递的,作为参数被传递的对象从来不自动拷贝</p>
</li>
<li><p>在函数内部的参数名的<strong>赋值</strong>不会影响调用者</p>
<p>在函数运行时,在函数头部的参数名是一个新的、本地的变量名,这个变量名是函数的本地作用域内的</p>
<p>函数参数名和调用者作用域中的变量名没有别名</p>
</li>
<li><p>改变函数的可变对象参数的值也许会对调用者有影响</p>
<p>因为参数是简单地赋值给传入的对象,函数能够就地改变传入的可变对象,其结果会影响调用者</p>
<p>可变参数对于函数来说可以做输入和输出</p>
</li>
</ul>
</blockquote>
<p>Python通过赋值进行传递的机制</p>
<blockquote>
<ul>
<li><p>不可变参数”通过值”进行传递</p>
<p>像整数和字符串这样的对象是通过对象引用而不是拷贝进行传递的,但是因为不可能在原处改变不可变对象,实际的效果像创建了一份拷贝</p>
</li>
<li><p>可变对象通过”指针”进行传递</p>
<p>列表和字典这样的对象也通过对象引用进行传递,可变对象能够在函数内部进行原处的改变</p>
</li>
</ul>
</blockquote>
<h3 id="参数和共享引用"><a href="#参数和共享引用" class="headerlink" title="参数和共享引用"></a>参数和共享引用</h3><p>对可变对象在原处的修改会影响其他引用了该对象的变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(a):       # a is assigned to (references) passed pbject</span><br><span class="line">...     a = 99      # Changes local variable a only</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; b = 99</span><br><span class="line">&gt;&gt;&gt; f(b)            # a and b both reference same initially</span><br><span class="line">&gt;&gt;&gt; print(b)        # b is not changed</span><br><span class="line">99</span><br></pre></td></tr></table></figure>

<p>函数内部的参数只存在于调用的函数之中,对其赋值不会影响到函数调用作用域中的变量</p>
<p>函数内部的参数与函数调用中的参数共享传递的对象,对参数名进行重新赋值后不再为共享引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def changer(a, b):      # Arguments assigned references to objects</span><br><span class="line">...     a = 2               # Changes local name&apos;s value only</span><br><span class="line">...     b[0] = &apos;spam&apos;       # Changes shared object in-place</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; X = 1</span><br><span class="line">&gt;&gt;&gt; L = [1, 2]              # Caller</span><br><span class="line">&gt;&gt;&gt; changer(X, L)           # Pass immutable and mutable object</span><br><span class="line">&gt;&gt;&gt; X, L                    # X is unchanged,L is different!</span><br><span class="line">(1, [&apos;spam&apos;, 2])</span><br></pre></td></tr></table></figure>

<p>当参数传递可变对象时,对对象的原处修改可能在函数退出后依然有效,并由此影响到调用者</p>
<blockquote>
<ul>
<li>函数作用域内的本地变量名赋值对函数调用者没有影响,它仅仅把本地变量修改为引用另一个对象,并没有改变调用者作用域中的变量名的引用</li>
<li>若函数作用域内的本地变量名引用了一个可变对象,对对象原处修改的结果会在函数返回后影响调用者作用域中的变量名的引用</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X = 1</span><br><span class="line">&gt;&gt;&gt; a = X                   # They share the same object</span><br><span class="line">&gt;&gt;&gt; a = 2                   # Resets &apos;a&apos; only,&apos;X&apos; is still 1</span><br><span class="line">&gt;&gt;&gt; print(X)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; L = [1, 2]</span><br><span class="line">&gt;&gt;&gt; b = L                   # They share the same object</span><br><span class="line">&gt;&gt;&gt; b[0] = &apos;spam&apos;           # In-place change:&apos;L&apos; sees the change too</span><br><span class="line">&gt;&gt;&gt; print(L)</span><br><span class="line">[&apos;spam&apos;, 2]</span><br></pre></td></tr></table></figure>

<p>自动对传入的参数进行赋值的效果与运行一系列简单的赋值语句是相同的</p>
<h3 id="避免可变参数的修改"><a href="#避免可变参数的修改" class="headerlink" title="避免可变参数的修改"></a>避免可变参数的修改</h3><p>对可变参数的原处修改的行为是参数传递在Python中工作的方式</p>
<p>在Python中,默认通过引用(即指针)进行函数的参数传递实现了不需要创建多个拷贝就可以在程序中传递很大的对象,并且能够按照需要方便地更新这些对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def changer(a, b):</span><br><span class="line">...     a = 2</span><br><span class="line">...     b [0] = &apos;spam&apos;</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; X = 1</span><br><span class="line">&gt;&gt;&gt; L = [1, 2]</span><br><span class="line">&gt;&gt;&gt; changer(X, L[:])        # Pass a copy,so our &apos;L&apos; does not change</span><br><span class="line">&gt;&gt;&gt; def changer(a, b):</span><br><span class="line">...     b = b[:]            # Copy input list so we don&apos;t impact caller</span><br><span class="line">...     a = 2</span><br><span class="line">...     b[0] = &apos;spam&apos;       # Changes our list copy only</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; L = [1, 2]</span><br><span class="line">&gt;&gt;&gt; changer(X, tuple(L))    # Pass a tuple,so changes are errors</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 4, in changer</span><br><span class="line">TypeError: &apos;tuple&apos; object does not support item assignment</span><br></pre></td></tr></table></figure>

<p>如果不信函数内部在原处的修改影响传递给它的对象,可以简单地创建一个明确的可变对象的拷贝或者可以在函数内部进行拷贝</p>
<p>可以将可变对象转换为不可变对象来杜绝参数在原处修改,但是这种办法会让函数失去了调用原来对象的特定方法的能力</p>
<p>函数能够升级为传入可变对象的形式</p>
<p>在原处修改可以只修改定义良好的API的一部分而不是产生副本来修改</p>
<h3 id="对参数输出进行模拟"><a href="#对参数输出进行模拟" class="headerlink" title="对参数输出进行模拟"></a>对参数输出进行模拟</h3><p><code>return</code>语句能够返回任意种类的值,所以能够将其封装进一个元组或其他的集合类型返回多个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def multiple(x, t):</span><br><span class="line">...     x = 2                   # Changes local names only</span><br><span class="line">...     y = [3, 4]</span><br><span class="line">...     return x, y             # Return new values in a tuple</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; X = 1</span><br><span class="line">&gt;&gt;&gt; L = [1, 2]</span><br><span class="line">&gt;&gt;&gt; X, L = multiple(X, L)       # Assign results to caller&apos;s names</span><br><span class="line">&gt;&gt;&gt; X, L</span><br><span class="line">(2, [3, 4])</span><br></pre></td></tr></table></figure>

<p>可以返回元组并将结果解包,赋值给调用者的参数变量名来改变调用者的参数的值</p>
<p>在Python 3.0中,<code>def</code>语句头部不允许元组解包参数,而循环语句则支持</p>
<hr>
<h2 id="特定的参数匹配模型"><a href="#特定的参数匹配模型" class="headerlink" title="特定的参数匹配模型"></a>特定的参数匹配模型</h2><p>Python提供了改变调用过程中传入的变量引用与函数头部参数名匹配优先级的工具来编写支持更复杂的调用模式的函数</p>
<p>默认情况下,参数通过其位置从左至右进行匹配,参数和函数头部参数名必须一样多</p>
<p>参数还能通过定义变量名进行匹配,默认参数值以及对于额外参数的容器匹配</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>匹配模型是可选的,必须根据变量名匹配对象,匹配完成后在传递机制的底层依然是赋值</p>
<p>匹配的模型</p>
<blockquote>
<ul>
<li><p>位置:从左至右进行匹配 一-般情况下是通过位置按照从左到右的顺序把参数值传递给函数头部的参数名进行匹配</p>
</li>
<li><p>关键字参数:通过参数名进行匹配 通过在调用时使用参数的变量名<code>name=value</code>语法定义哪个函数接受值</p>
</li>
<li><p>默认参数:为没有传入值的参数定义参数值 如果调用时传入的值过少的话,函数使用语法<code>name=value</code>能够为参数定义接受的默认值</p>
</li>
<li><p>可变参数:收集任意多基于位置或关键字的参数 函数能够使用特定的参数,它们是以字符<code>*</code>开头,收集任意多的额外参数,这个特性叫做可变参数</p>
</li>
<li><p>可变参数解包:传递任意多的基于位置或关键字的参数 调用者能够再使用<code>*</code>语法将<strong>参数集合</strong>打散,分成参数</p>
</li>
<li><p>Keyword-only参数:参数必须按照名称传递 在Python 3.0中,函数也可以指定参数,参数必须用带有关键参数的名字(而不是位置)来传递</p>
<p>这样的参数通常用来定义实际参数以外的配置选项</p>
</li>
</ul>
</blockquote>
<h3 id="匹配语法"><a href="#匹配语法" class="headerlink" title="匹配语法"></a>匹配语法</h3><p>特定的参数匹配模式可以自由地确认有多少参数是必须传递给函数的</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>位置</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>func(value)</td>
<td>调用者</td>
<td>常规参数:通过位置进行匹配</td>
</tr>
<tr>
<td>func(name=value)</td>
<td>调用者</td>
<td>关键字参数:通过变量名匹配</td>
</tr>
<tr>
<td>func(*sequence)</td>
<td>调用者</td>
<td>以name传递所有的对象,并作为独立的基于位置的参数</td>
</tr>
<tr>
<td>func(**dict)</td>
<td>调用者</td>
<td>以name成对的传递所有的关键字/值,并作为独立的关键字参数</td>
</tr>
<tr>
<td>def func(name)</td>
<td>函数</td>
<td>常规参数:通过位置或变量名进行匹配</td>
</tr>
<tr>
<td>def func(name=value)</td>
<td>函数</td>
<td>没有在调用中传递时的默认参数值</td>
</tr>
<tr>
<td>def func(*name)</td>
<td>函数</td>
<td>匹配并收集(在元组中)所有包含位置的参数</td>
</tr>
<tr>
<td>def func(**name)</td>
<td>函数</td>
<td>匹配并收集(在字典中)所有包含位置的参数</td>
</tr>
<tr>
<td>def func(*args,name)</td>
<td>函数</td>
<td>参数必须在调用中按照关键字传递</td>
</tr>
<tr>
<td>def func(*, name=value)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>函数调用和定义的匹配模式</p>
<blockquote>
<ul>
<li>在函数的调用中<ul>
<li>简单的通过变量名位置进行匹配</li>
<li>关键字参数使用<code>name=value</code>的形式告诉Python依照变量名进行匹配</li>
<li>在调用中使用<code>*sequence</code>或者<code>**dict</code>允许我们在一个序列或字典中相应地封装任意多的位置相关或者关键字的对象,并且在将它们传递给函数的时候,将它们解包为分开的、单个的参数。</li>
</ul>
</li>
<li>在函数的头部<ul>
<li>一个简单的变量名是通过位置或变量名进行匹配的</li>
<li><code>name=value</code>的形式定义了默认的参数值</li>
<li><code>*name</code>的形式收集了任意的额外不匹配的参数到元组中</li>
<li><code>**name</code>的形式将会收集额外的关键字参数到字典之中</li>
<li>跟在<code>*name</code>或一个单独的<code>*</code>之后的、任何正式的或默认的参数名称,都是<code>keyword-only</code>参数,并且必须在调用中按照关键字传递</li>
</ul>
</li>
</ul>
</blockquote>
<p>关键字参数和默认参数</p>
<blockquote>
<ul>
<li>关键字参数允许使用其变量名去标记参数,让调用变得更有意义</li>
<li>默认参数允许创建任意可选的参数,并在函数定义中提供了默认值</li>
<li>函数头部的默认参数和调用中的关键字组合允许挑选要覆盖哪些默认参数</li>
</ul>
</blockquote>
<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>Python使用并混合特定的参数匹配模式遵循的顺序</p>
<blockquote>
<ul>
<li>在函数调用中,参数的顺序为:任何位置参数(value)、关键字参数(name=value)、<code>*sequence</code>形式的组合、<code>**dict</code>形式</li>
<li>在函数头部,参数的顺序为:任何一般参数(name)、任何默认参数(name=value)、<code>*name</code>形式、<code>name</code>或<code>name=value</code>的keyword-only参数、<code>**name</code>形式</li>
</ul>
</blockquote>
<p>Python内部参数匹配的步骤</p>
<blockquote>
<ol>
<li>通过位置分配非关键字参数</li>
<li>通过匹配变量名分配关键字参数</li>
<li>其他额外的非关键字参数分配到<code>*name</code>元组中</li>
<li>其他额外的关键字参数分配到<code>**name</code>字典中</li>
<li>用默认值分配给在头部未得到分配的参数</li>
</ol>
</blockquote>
<p>匹配模式后检测每个参数是否只传入了一个值,之后传递给参数名的对象赋值</p>
<h3 id="关键字参数和默认参数的实例"><a href="#关键字参数和默认参数的实例" class="headerlink" title="关键字参数和默认参数的实例"></a>关键字参数和默认参数的实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(a, b, c): print(a, b, c)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; f(1, 2, 3)</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>

<p>没有使用特殊的匹配语法时Python默认会通过为止从左至右匹配变量名</p>
<h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>关键字参数在调用中起到了数据标签的作用并且可以与默认值参数配合使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(a, b, c): print(a, b, c)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; f(c=3, b=2, a=1)</span><br><span class="line">1 2 3</span><br><span class="line">&gt;&gt;&gt; f(1, c=3, b=2)</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>

<p>关键字参数允许通过变量名进行匹配,Python将函数调用的变量名匹配并将值传递给函数定义头部的变量名</p>
<p>使用关键字参数时蚕食是通过变量名而不是根据位置进行传递进行传递的</p>
<p>混合使用基于位置的参数和基于关键字的参数时先将基于位置的参数按照从左至右顺序匹配头部的参数,之后再进行基于变量名进行关键字的匹配</p>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f(1, c=3, b=2)</span><br><span class="line">1 2 3</span><br><span class="line">&gt;&gt;&gt; def f(a, b=2, c=3): print(a, b, c)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; f(1)</span><br><span class="line">1 2 3</span><br><span class="line">&gt;&gt;&gt; f(a=1)</span><br><span class="line">1 2 3</span><br><span class="line">&gt;&gt;&gt; f(1, 4)</span><br><span class="line">1 4 3</span><br><span class="line">&gt;&gt;&gt; f(1, 4, 5)</span><br><span class="line">1 4 5</span><br><span class="line">&gt;&gt;&gt; f(1, c=6)</span><br><span class="line">1 2 6</span><br></pre></td></tr></table></figure>

<p>默认参数允许创建函数可选的参数,如果没有传入值的话,参数在函数运行前被赋予默认值</p>
<p>传入参数时默认按照从左至右的位置顺序进行匹配,使用关键字参数可以跳过默认值参数</p>
<h4 id="关键字参数和默认参数的混合"><a href="#关键字参数和默认参数的混合" class="headerlink" title="关键字参数和默认参数的混合"></a>关键字参数和默认参数的混合</h4><p><code>name=value</code>的形式在调用时代表关键字参数,<code>def</code>头部中代表默认值参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def func(spam, eggs, toast=0, ham=0):   # First 2 required</span><br><span class="line">    print((spam, eggs, toast, ham))</span><br><span class="line"></span><br><span class="line">func(1, 2)</span><br><span class="line">func(1, ham=1, eggs=0)</span><br><span class="line">func(spam=1, eggs=0)</span><br><span class="line">func(toast=1, eggs=2, spam=3)</span><br><span class="line">func(1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">(1, 2, 0, 0)</span><br><span class="line">(1, 0, 0, 1)</span><br><span class="line">(1, 0, 0, 0)</span><br><span class="line">(3, 2, 1, 0)</span><br><span class="line">(1, 2, 3, 4)</span><br><span class="line">[Finished in 0.6s]</span><br></pre></td></tr></table></figure>

<p>当关键字参数在调用过程中使用时,参数排列的位置并没有关系,Python通过变量名而不是位置进行匹配</p>
<h3 id="任意参数的实例"><a href="#任意参数的实例" class="headerlink" title="任意参数的实例"></a>任意参数的实例</h3><p><code>*</code>和<code>**</code>让函数支持接受任意数目的参数,可以出现在函数定义或是函数调用中</p>
<h4 id="收集参数"><a href="#收集参数" class="headerlink" title="收集参数"></a>收集参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(*args): print(args)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; f()</span><br><span class="line">()</span><br><span class="line">&gt;&gt;&gt; f(1)</span><br><span class="line">(1,)</span><br><span class="line">&gt;&gt;&gt; f(1, 2, 3, 4)</span><br><span class="line">(1, 2, 3, 4)</span><br></pre></td></tr></table></figure>

<p>在函数定义中,<code>*</code>将所有位置相关的参数传递给一个新的元组</p>
<p>参数可以索引或在一个<code>for</code>循环中步进</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(**args): print(args)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; f()</span><br><span class="line">&#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f(a=1, b=2)</span><br><span class="line">&#123;&apos;a&apos;: 1, &apos;b&apos;: 2&#125;</span><br></pre></td></tr></table></figure>

<p>在函数定义中,<code>**</code>将所有关键字参数传递给一个新的字典</p>
<p>参数能够通过一般的字典工具进行处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(a, *pargs, **kargs): print(a, pargs,kargs)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; f(1, 2, 3, x=1, y=2)</span><br><span class="line">1 (2, 3) &#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125;</span><br></pre></td></tr></table></figure>

<p>函数头部能够混合一般参数、<code>*</code>参数以及<code>**</code>去实现更灵活的调用方式</p>
<h4 id="解包参数"><a href="#解包参数" class="headerlink" title="解包参数"></a>解包参数</h4><p>解包参数在不能预测将要传入的函数的参数的数量时候很方便</p>
<p><code>*</code>接受任何可迭代对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def func(a, b, c, d): print(a, b, c, d)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; args = (1, 2)</span><br><span class="line">&gt;&gt;&gt; args += (3, 4)</span><br><span class="line">&gt;&gt;&gt; func(*args)</span><br><span class="line">1 2 3 4</span><br><span class="line">&gt;&gt;&gt; args = &#123;&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3&#125;</span><br><span class="line">&gt;&gt;&gt; args[&apos;d&apos;] = 4</span><br><span class="line">&gt;&gt;&gt; func(**args)</span><br><span class="line">1 2 3 4</span><br><span class="line">&gt;&gt;&gt; func(*(1, 2), **&#123;&apos;d&apos;:4, &apos;c&apos;:4&#125;)</span><br><span class="line">1 2 4 4</span><br><span class="line">&gt;&gt;&gt; func(1, *(2, 3), **&#123;&apos;d&apos;:4&#125;)</span><br><span class="line">1 2 3 4</span><br><span class="line">&gt;&gt;&gt; func(1, c=3, *(2,), **&#123;&apos;d&apos;:4&#125;)</span><br><span class="line">1 2 3 4</span><br><span class="line">&gt;&gt;&gt; func(1, *(2, 3), d=4)</span><br><span class="line">1 2 3 4</span><br><span class="line">&gt;&gt;&gt; f(1, *(2,), c=3, **&#123;&apos;d&apos;:4&#125;)</span><br><span class="line">1 (2,) &#123;&apos;c&apos;: 3, &apos;d&apos;: 4&#125;</span><br><span class="line">&gt;&gt;&gt; func(1, *(2,), c=3, **&#123;&apos;d&apos;:4&#125;)</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure>

<p>在调用函数时使用<code>*</code>语法会解包参数的集合而不是创建参数</p>
<p>在 调用函数时使用<code>**</code>会以键/值对的形式解包一个字典使其成为独立的参数</p>
<p>在调用中可以混合普通的参数、基于位置的参数以及关键字参数</p>
<h4 id="应用函数通用性"><a href="#应用函数通用性" class="headerlink" title="应用函数通用性"></a>应用函数通用性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if &lt;test&gt;:</span><br><span class="line">    action,args = func1, (1,)           # Call func1 with 1 arg in this case</span><br><span class="line">else:</span><br><span class="line">    action, args = func2, (1, 2, 3)     # Call func2 with 3 args here</span><br><span class="line">...</span><br><span class="line">action(*args)                           # Dispatch generically</span><br></pre></td></tr></table></figure>

<p>解包参数可以在编写一段脚本之前不知道一个函数调用需要多少参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def tracer(func, *pargs, **kargs):      # Accept arbitrary arguments</span><br><span class="line">    print(&apos;calling:&apos;, func.__name__)</span><br><span class="line">    return func(*pargs, **kargs)        # Pass along arbitrary arguments</span><br><span class="line"></span><br><span class="line">def func(a, b, c, d):</span><br><span class="line">    return a + b + c + d</span><br><span class="line"></span><br><span class="line">print(tracer(func, 1, 2, c=3, d=4))</span><br><span class="line"></span><br><span class="line">calling: func</span><br><span class="line">10</span><br><span class="line">[Finished in 0.1s]</span><br></pre></td></tr></table></figure>

<p>当编写脚本时无法直接编写一个函数调用,可以用序列操作构建一个参数列表,并解包参数以调用它</p>
<h4 id="废弃的apply内置函数-Python-2-6"><a href="#废弃的apply内置函数-Python-2-6" class="headerlink" title="废弃的apply内置函数(Python 2.6)"></a>废弃的apply内置函数(Python 2.6)</h4><p>Python 2.6内置函数<code>apply</code>可以实现<code>*args</code>和<code>**args</code>调用语法的效果</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; func(*pargs, **kargs)</span><br><span class="line">&gt; apply(func, pargs, kargs)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Python 3.0</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def echo(*args, **kwargs): print(args, kwargs)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; echo(1, 2, a=3, b=4)</span><br><span class="line">(1, 2) &#123;&apos;a&apos;: 3, &apos;b&apos;: 4&#125;</span><br><span class="line"></span><br><span class="line"># Python 2.6</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def echo(*args, **kwargs): print(args, kwargs)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; pargs = (1, 2)</span><br><span class="line">&gt;&gt;&gt; kargs = &#123;&apos;a&apos;:3, &apos;b&apos;:4&#125;</span><br><span class="line">&gt;&gt;&gt; apply(echo, pargs, kargs)</span><br><span class="line">((1, 2), &#123;&apos;a&apos;: 3, &apos;b&apos;: 4&#125;)</span><br></pre></td></tr></table></figure>

<p>解包调用语法形式比<code>apply</code>函数新,与<code>def</code>头部的<code>*pargs</code>和<code>**kargs</code>收集器对称且可以传递额外的参数</p>
<h3 id="Python-3-0-keyword-Only参数"><a href="#Python-3-0-keyword-Only参数" class="headerlink" title="Python 3.0 keyword-Only参数"></a>Python 3.0 keyword-Only参数</h3><p><code>keyword-only</code>参数必须按照关键字而不是位置传递参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def kwonly(a, *b, c):</span><br><span class="line">...     print(a, b, c)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; kwonly(1, 2, c=3)</span><br><span class="line">1 (2,) 3</span><br><span class="line">&gt;&gt;&gt; kwonly(1, c=3)</span><br><span class="line">1 () 3</span><br><span class="line">&gt;&gt;&gt; kwonly(1, 2, 3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: kwonly() missing 1 required keyword-only argument: &apos;c&apos;</span><br></pre></td></tr></table></figure>

<p><code>keyword-only</code>参数为关键字参数,必须使用关键字语法传递,出现在参数列表中<code>*args</code>之后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def kwonly(a, *, b, c,):</span><br><span class="line">...     print(a, b, c)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; kwonly(1, c=3, b=2)</span><br><span class="line">1 2 3</span><br><span class="line">&gt;&gt;&gt; kwonly(c=3, b=2, a=1)</span><br><span class="line">1 2 3</span><br><span class="line">&gt;&gt;&gt; kwonly(1, 2, 3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: kwonly() takes 1 positional argument but 3 were given</span><br><span class="line">&gt;&gt;&gt; kwonly(1)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: kwonly() missing 2 required keyword-only arguments: &apos;b&apos; and &apos;c&apos;</span><br></pre></td></tr></table></figure>

<p>在参数列表中使用<code>*</code>字符表示跟在<code>*</code>后面的所有参数都作为关键字传递</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def kwonly(a, *, b=1, c, d=2):</span><br><span class="line">...     print(a, b, c, d)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; kwonly(3, c=4)</span><br><span class="line">3 1 4 2</span><br><span class="line">&gt;&gt;&gt; kwonly(3, c=4, b=5)</span><br><span class="line">3 5 4 2</span><br><span class="line">&gt;&gt;&gt; kwonly(3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: kwonly() missing 1 required keyword-only argument: &apos;c&apos;</span><br><span class="line">&gt;&gt;&gt; kwonly(1, 2, 3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: kwonly() takes 1 positional argument but 3 were given</span><br></pre></td></tr></table></figure>

<p><code>keyword-only</code>参数可以使用默认值,没有默认值的<code>keyword-only</code>参数必须使用关键字传递</p>
<h4 id="排序规则"><a href="#排序规则" class="headerlink" title="排序规则"></a>排序规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def kwonly(a, **pargs, b, c):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1</span><br><span class="line">    def kwonly(a, **pargs, b, c):</span><br><span class="line">                           ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line">&gt;&gt;&gt; def kwonly(a, **, b, c):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1</span><br><span class="line">    def kwonly(a, **, b, c):</span><br><span class="line">                    ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<p><strong>函数定义</strong>中<code>keyword-only</code>参数不能出现在<code>**args</code>后面,一个<code>**</code>不能独自出现在参数列表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(a, *b, **d, c=6): print(a, b, c, d)   # Keywrod-only before **!</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1</span><br><span class="line">    def f(a, *b, **d, c=6): print(a, b, c, d)   </span><br><span class="line">                      ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line">&gt;&gt;&gt; def f(a, *b, c=6, **d): print(a, b, c, d)   # Collect args in header</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; f(1, 2, 3, x=4, y=5)                        # Default used</span><br><span class="line">1 (2, 3) 6 &#123;&apos;x&apos;: 4, &apos;y&apos;: 5&#125;</span><br><span class="line">&gt;&gt;&gt; f(1, 2, 3, x=4, y=5, c=7)                   # Override default</span><br><span class="line">1 (2, 3) 7 &#123;&apos;x&apos;: 4, &apos;y&apos;: 5&#125;</span><br><span class="line">&gt;&gt;&gt; f(1, 2, 3, c=7, x=4, y=5)                   # Anywhere in keywords</span><br><span class="line">1 (2, 3) 7 &#123;&apos;x&apos;: 4, &apos;y&apos;: 5&#125;</span><br><span class="line">&gt;&gt;&gt; def f(a, c=6, *b, **d): print(a, b, c, d)   # c is not keyword-only</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; f(1, 2, 3, x=4)</span><br><span class="line">1 (3,) 2 &#123;&apos;x&apos;: 4&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数定义</strong>中<code>keyword-only</code>参数必须编写在<code>**args</code>任意关键字形式之前,<code>*args</code>任意位置形式之后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(a, *b, c=6, **d): print(a, b, c, d)   # KW-only between * and **</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; f(1, *(2, 3), **dict(x=4, y=5))             # Unpack args at call</span><br><span class="line">1 (2, 3) 6 &#123;&apos;x&apos;: 4, &apos;y&apos;: 5&#125;</span><br><span class="line">&gt;&gt;&gt; f(1, *(2, 3), **dict(x=4, y=5), c=7)        # Keywords before **args</span><br><span class="line">1 (2, 3) 7 &#123;&apos;x&apos;: 4, &apos;y&apos;: 5&#125;</span><br><span class="line">&gt;&gt;&gt; f(1, *(2, 3), c=7, **dict(x=4, y=5))        # Override default</span><br><span class="line">1 (2, 3) 7 &#123;&apos;x&apos;: 4, &apos;y&apos;: 5&#125;</span><br><span class="line">&gt;&gt;&gt; f(1, c=7, *(2, 3), **dict(x=4, y=5))        # After or before *</span><br><span class="line">1 (2, 3) 7 &#123;&apos;x&apos;: 4, &apos;y&apos;: 5&#125;</span><br><span class="line">&gt;&gt;&gt; f(1, *(2, 3), **dict(x=4, y=5, c=7))        # Keyword-only in **</span><br><span class="line">1 (2, 3) 7 &#123;&apos;x&apos;: 4, &apos;y&apos;: 5&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数调用</strong>中<code>keyword-only</code>可以出现在<code>**args</code>之前之后或包含在<code>**args</code>之中,可以出现在<code>*args</code>之前或之后</p>
<h4 id="为何使用keyword-only参数"><a href="#为何使用keyword-only参数" class="headerlink" title="为何使用keyword-only参数"></a>为何使用keyword-only参数</h4><p><code>keyword-only</code>使得很容易允许一个函数既接受任意多个要处理的位置参数,也接受作为关键字传递的配置选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process(X, Y, Z)            # use flag&apos;s default</span><br><span class="line">process(X, Y, notify=True)  # override flag default</span><br></pre></td></tr></table></figure>

<p>没有<code>keyword-only</code>参数则只能提供默认值并验证没有传递多余的关键字</p>
<h3 id="min调用"><a href="#min调用" class="headerlink" title="min调用"></a>min调用</h3><p>编写一个函数计算任意参数集合和任意对象数据类型集合中的最小值,要求函数接受零个或多个参数,能够使用所有的Python对象类型</p>
<ul>
<li>第一个要求可以使用<code>*</code>将参数收集到一个元组中,通过简单的loop依次步进处理每一个参数</li>
<li>第二个要求可以不管类型进行简单地比较,让Python执行正确的比较</li>
</ul>
<h4 id="满分"><a href="#满分" class="headerlink" title="满分"></a>满分</h4><p>操作方法</p>
<blockquote>
<ul>
<li>第一个函数获取了第一个参数(args是一个元组),并且使用分片去掉第一个得到了剩余的参数(一个对象同自己比较是没有意义的,特别是这个对象是一个较大的结构时)</li>
<li>第二个版本让Python自动获取第一个参数以及其余的参数,因此避免了进行一次索引和分片</li>
<li>第三个版本通过对内置函数list的调用让一个元组转换为一个列表,之后调用list内置的sort方法来实现比较。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def min1(*args):</span><br><span class="line">    res = args[0]</span><br><span class="line">    for arg in args[1:]</span><br><span class="line">        if arg &lt; res:</span><br><span class="line">            res = arg</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line">def min2(first, *rsst):</span><br><span class="line">    for arg in rest:</span><br><span class="line">        if arg &lt; first:</span><br><span class="line">            first = arg</span><br><span class="line">    return first</span><br><span class="line"></span><br><span class="line">def min3(*args):</span><br><span class="line">    tmp = list(args)</span><br><span class="line">    tmp.sort()</span><br><span class="line">    return tmp[0]</span><br><span class="line"></span><br><span class="line">print(min1(3, 4, 1, 2))</span><br><span class="line">print(min2(&quot;bb&quot;, &quot;aa&quot;))</span><br><span class="line">print(min3([2, 2], [1, 1], [3, 3]))</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">aa</span><br><span class="line">[1, 1]</span><br><span class="line">[Finished in 0.2s]</span><br></pre></td></tr></table></figure>

<p>三种解决办法在运行时产生了相同效果</p>
<p>在没有参数传入时三种方法都会抛出异常</p>
<h4 id="加分点"><a href="#加分点" class="headerlink" title="加分点"></a>加分点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def minmax(test, *args):</span><br><span class="line">    res = args[0]</span><br><span class="line">    for arg in args[1:]:</span><br><span class="line">        if test(arg, res):</span><br><span class="line">            res = arg</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line">def lessthan(x, y): return x &lt; y            # See also:lambda</span><br><span class="line">def grtrthan(x, y): return x &gt; y</span><br><span class="line"></span><br><span class="line">print(minmax(lessthan, 4, 2, 1, 5, 6, 3))   # Self-test code</span><br><span class="line">print(minmax(grtrthan, 4, 2, 1, 5, 6, 3))</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">[Finished in 0.1s]</span><br></pre></td></tr></table></figure>

<p>使用当的函数计算最大值或最小值需要评估对比表达式,如内置函数<code>eval</code>,或者传入一个任意的比较函数</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><code>min</code>函数与<code>max</code>函数都是Python内置函数</p>
<hr>
<h2 id="一个更有用的例子-通用set函数"><a href="#一个更有用的例子-通用set函数" class="headerlink" title="一个更有用的例子:通用set函数"></a>一个更有用的例子:通用set函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def intersect(*args):</span><br><span class="line">    res = []</span><br><span class="line">    for x in args[0]:               # Scan first sequence</span><br><span class="line">        for other in args[1:]:      # For all other args</span><br><span class="line">            if x not in other:      # Item in each one</span><br><span class="line">                break               # No:break out of loop</span><br><span class="line">            else:                   # Yes:add items to end</span><br><span class="line">                res.append(x)</span><br><span class="line">    return res                      </span><br><span class="line"></span><br><span class="line">def union(*args):</span><br><span class="line">    res = []</span><br><span class="line">    for seq in args:                # For all args</span><br><span class="line">        for x in seq:               # For all nodes</span><br><span class="line">            if not x in res:</span><br><span class="line">                res.append(x)       # Add new items to result</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; from inter2 import intersect, union</span><br><span class="line">&gt;&gt;&gt; s1, s2, s3 = &quot;SPAM&quot;, &quot;SCAM&quot;, &quot;SLSM&quot;</span><br><span class="line">&gt;&gt;&gt; intersect(s1, s3), union(s1, s2)</span><br><span class="line">([&apos;S&apos;, &apos;A&apos;, &apos;M&apos;], [&apos;S&apos;, &apos;P&apos;, &apos;A&apos;, &apos;M&apos;, &apos;C&apos;])</span><br><span class="line">&gt;&gt;&gt; intersect([1, 2, 3], (1, 4))    # Two operands</span><br><span class="line">[1]</span><br><span class="line">&gt;&gt;&gt; intersect(s1, s2, s3)           # Mixed types</span><br><span class="line">[&apos;S&apos;, &apos;A&apos;, &apos;M&apos;]</span><br><span class="line">&gt;&gt;&gt; union(s1, s2, s3)               # Three operands</span><br><span class="line">[&apos;S&apos;, &apos;P&apos;, &apos;A&apos;, &apos;M&apos;, &apos;C&apos;, &apos;L&apos;]</span><br></pre></td></tr></table></figure>

<p>这个函数能对任意数目的序列进行公共部分挑选的函数,通过使用可变参数的匹配形式<code>*args</code>去收集传入的参数</p>
<p>参数在调用时作为元组args传入</p>
<hr>
<h2 id="模拟Python-3-0-print函数"><a href="#模拟Python-3-0-print函数" class="headerlink" title="模拟Python 3.0 print函数"></a>模拟Python 3.0 print函数</h2><p>通过<code>from __future__ import print_function</code>导入Python 3.0的<code>print</code>函数</p>
<p>使用<code>*args</code>任意位置元组以及<code>**args</code>任意关键字参数字典可以模拟Python 3.0 <code>print</code>函数所做的大多数工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">Emlate most of the 3.0 print function for use in 2.X</span><br><span class="line">call signature: print30(*args, sep=&apos; &apos;, end=&apos;\n&apos;, file=None)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def print30(*args, **kargs):</span><br><span class="line">    sep = kargs.pop(&apos;sep&apos;, &apos; &apos;)                         # Keyword are default</span><br><span class="line">    end = kargs.pop(&apos;end&apos;, &apos;\n&apos;)</span><br><span class="line">    file = kargs.pop(&apos;file&apos;, sys.stdout)</span><br><span class="line">    if kargs: raise TypeError(&apos;extra keywords: %s&apos; % kargs)</span><br><span class="line">    output = &apos;&apos;</span><br><span class="line">    first = True</span><br><span class="line">    for arg in args:</span><br><span class="line">        output += (&apos;&apos; if first else sep) + str(arg)</span><br><span class="line">        first = False</span><br><span class="line">    file.write(output + end)</span><br><span class="line"></span><br><span class="line">print30(1, 2, 3)</span><br><span class="line">print30(1, 2, 3, sep=&apos;&apos;)                                # Suppress separator</span><br><span class="line">print30(1, 2, 3, sep=&apos;...&apos;)</span><br><span class="line">print30(1, [2], (3,), sep=&apos;...&apos;)                        # Various object types</span><br><span class="line"></span><br><span class="line">print30(4, 5, 6, sep=&apos;&apos;, end=&apos;&apos;)                        # Suppress newline</span><br><span class="line">print30(7, 8, 9)</span><br><span class="line">print30()                                               # Add newline (or blank line)</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">print30(1, 2, 3, sep=&apos;??&apos;, end=&apos;.\n&apos;, file=sys.stderr)  # Redirect to file</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">1 2 3</span><br><span class="line">123</span><br><span class="line">1??2??3.</span><br><span class="line">1...2...3</span><br><span class="line">1...[2]...(3,)</span><br><span class="line">4567 8 9</span><br><span class="line"></span><br><span class="line">1??2??3.</span><br><span class="line">[Finished in 0.2s]</span><br><span class="line">&apos;&apos;&apos;</span><br></pre></td></tr></table></figure>

<h3 id="使用Keyword-Only参数"><a href="#使用Keyword-Only参数" class="headerlink" title="使用Keyword-Only参数"></a>使用Keyword-Only参数</h3><p>使用<code>keyword-only</code>参数编写可以自动验证配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Use keyword-only args</span><br><span class="line"></span><br><span class="line">def print30(*args, sep=&apos; &apos;, end=&apos;\n&apos;, file=sys.stdout):</span><br><span class="line">    output = &apos;&apos;</span><br><span class="line">    first = True</span><br><span class="line">    for arg in args:</span><br><span class="line">        output += (&apos;&apos; if first else sep) + str(arg)</span><br><span class="line">        first = False</span><br><span class="line">    file.write(output + end)</span><br></pre></td></tr></table></figure>

<p><code>keyword-only</code>参数可以简化一类既接受参数又接受选项的函数</p>
<p><code>keyword-only</code>是可选参数,但是会忽略掉额外的参数</p>
<h3 id="为什么要在意-关键字参数"><a href="#为什么要在意-关键字参数" class="headerlink" title="为什么要在意:关键字参数"></a>为什么要在意:关键字参数</h3><p>高级参数匹配模式更复杂,且完全是可选的</p>
<p>由于一些Python工具使用高级参数匹配模式,了解这些模式的常识是很重要的</p>
<hr>
<h2 id="本章习题-2"><a href="#本章习题-2" class="headerlink" title="本章习题"></a>本章习题</h2><ol>
<li><p>如下代码的输出是什么,为什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def func(a, b=4, c=5):</span><br><span class="line">...     print(a, b, c)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; func(1, 2)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的输出是<code>125</code>,因为1和2按照位置传递给了a和b,并且c在调用中被忽略了,默认为5</p>
</blockquote>
</li>
<li><p>如下代码的输出是什么,为什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def func(a, b, c=5):</span><br><span class="line">...     print(a, b, c)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; func(1, c=3, b=2)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这次的输出是<code>123</code>:1按照位置传递给a,2和3按照名称传递给b和c(当像这样使用关键字参数的时候,从左到右的顺序无关紧要)</p>
</blockquote>
</li>
<li><p>如下代码的输出是什么,为什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def func(a, *pargs):</span><br><span class="line">...     print(a, pargs)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; func(1, 2, 3)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这段代码打印出<code>1 (2,3)</code>,因为1传递给a,*pargs把其他的位置参数收集到一个新的元组对象中</p>
<p>可以用任何迭代工具来步进任何的额外的位置参数元组(例如,<code>for arg in pargs:</code>)</p>
</blockquote>
</li>
<li><p>如下代码打印出什么,为什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def func(a, **kargs):</span><br><span class="line">...     print(a, kargs)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; func(a=1, c=3, b=2)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码打印出<code>1, {&#39;c&#39;: 3,&#39;b&#39;: 2}</code>,因为1按照名称传递给a,**kargs把其他关键字参数收集到一个字典中</p>
<p>可以用任何迭代工具来步进任何额外的关键字参数字典(例如,<code>for key in kargs:</code> )</p>
</blockquote>
</li>
<li><p>最后一次运行时,如下代码的输出是什么,为什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def func(a, b, c=3, d=4): print(a, b, c, d)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; func(1, *(5, 6))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的输出是<code>1564</code>:1按照位置匹配a,5和6按照*name位置匹配b和c(6覆盖了c的默认值),并且d默认为4,因为它没有传递一个值</p>
</blockquote>
</li>
<li><p>举出三种以上函数和调用者能够交流结果的方法</p>
<blockquote>
<p>函数可以用<code>return</code>语句、修改传入的可变参数以及通过设置全局变量来返回其结果</p>
<p>全局变量一般都很少应用,因为这会让代码难以理解和使用</p>
<p><code>return</code>语句通常是最好的选择,但是在有准备的情况下,修改可变对象也是可以的</p>
<p>函数也可以和系统组件进行通信,例如文件和套接字</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="第十九章-函数的高级话题"><a href="#第十九章-函数的高级话题" class="headerlink" title="第十九章 函数的高级话题"></a>第十九章 函数的高级话题</h1><blockquote>
<ul>
<li>介绍递归函数、函数属性和注解、<code>lambda</code>表达式、<code>map</code>、<code>filter</code>、<code>reduce</code>等函数式编程工具以及通用的函数设计思想</li>
</ul>
</blockquote>
<hr>
<h2 id="函数设计概念"><a href="#函数设计概念" class="headerlink" title="函数设计概念"></a>函数设计概念</h2><p>应该竭力使函数和其他编程组件中的外部依赖性最小化,函数的自包含性越好,它越容易被理解、复用和修改</p>
<blockquote>
<ul>
<li><p>耦合性:对于输入使用参数并且对于输出使用<code>return</code>语句</p>
<p>一般来讲,需要力求让函数独立于它外部的东西,<code>参数</code>和<code>return</code>语句通常就是隔离对代码中少数醒目位置的外部的依赖关系的最好办法</p>
</li>
<li><p>耦合性:只有在真正必要的情况下使用全局变量</p>
<p>全局变量引发了依赖关系和计时的问题,会导致程序调试和修改的困难</p>
</li>
<li><p>耦合性:不要改变可变类型的参数,除非调用者希望这样做</p>
<p>函数会改变传入的可变类型对象,会导致很多调用者和被调用者之间的耦合性,这种耦合性会导致一个函数过于特殊和不友好</p>
<p>Python的类依赖于修改传入的可变对象:类的函数会自动设置传入参数<code>self</code>的属性从而修改每个对象的状态信息</p>
</li>
<li><p>聚合性:每一个函数都应该有一个单一的、统一的目标</p>
<p>在设计完美的情况下,每个函数中都应该做一件事</p>
<p>一个函数中把所有步骤都混合在一起的代码很难重用</p>
</li>
<li><p>大小:每一个函数应该相对较小</p>
<p>Python代码是以简单明了而著称,一个过长或者有着深层嵌套的函数往往就成为设计缺陷的征兆</p>
</li>
<li><p>耦合:避免直接改变在另一个模块文件中的变量</p>
<p>在文件间改变变量会导致模块文件间的耦合性,就像全局变量产生了函数间的耦合一样:模块难于理解和重用,在可能的时候使用读取函数,而不是直接进行赋值语句</p>
</li>
</ul>
</blockquote>
<hr>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>递归函数是直接或间接地调用自身以进行循环的函数</p>
<p>递归允许程序遍历拥有任意的、不可预知的形状的结构,可以替换简单循环和迭代</p>
<h3 id="用递归求和"><a href="#用递归求和" class="headerlink" title="用递归求和"></a>用递归求和</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def mysum(L):</span><br><span class="line">...     print(L)                # Trace recursive levels</span><br><span class="line">...     if not L:               # L shorter at each level</span><br><span class="line">...             return 0</span><br><span class="line">...     else:</span><br><span class="line">...             return L[0] + mysum(L[1:])</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; mysum([1, 2, 3, 4, 5])</span><br><span class="line">[1, 2, 3, 4, 5]</span><br><span class="line">[2, 3, 4, 5]</span><br><span class="line">[3, 4, 5]</span><br><span class="line">[4, 5]</span><br><span class="line">[5]</span><br><span class="line">[]</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<p>在每一层,这个函数都递归地调用自己来计算列表剩余的值的和,这个和随后加到前面的一项中,当列表变为空的时候,递归循环结束并返回0</p>
<p>使用递归的时候,对函数调用的每一个打开的层级在运行时调用堆栈上都有自己的一个函数本地作用域的副本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def mysum(L):</span><br><span class="line">...     if not L: return 0</span><br><span class="line">...     return nonempty(L)              # Call a function that calls me</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; def nonempty(L):</span><br><span class="line">...     return L[0] + mysum(L[1:])      # Indirectly recursive</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; mysum([1.1, 2.2, 3.3, 4.4])</span><br><span class="line">11.0</span><br></pre></td></tr></table></figure>

<p>递归可以是直接的也可以是间接的</p>
<h3 id="编码替代方案"><a href="#编码替代方案" class="headerlink" title="编码替代方案"></a>编码替代方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def mysum(L):</span><br><span class="line">    return 0 if not L else L[0] + mysum(L[1:])              # Use ternary expression</span><br><span class="line"></span><br><span class="line">def mysum(L):</span><br><span class="line">    return L[0] if len(L) == 1 else L[0] + mysum(L[1:])     # Any type,assume one</span><br><span class="line"></span><br><span class="line">def mysum(L):</span><br><span class="line">    first, *rest = L</span><br><span class="line">    return first if not rest else first + mysum(rest)       # Use 3.0 ext seq assign</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; mysum([1])                                              # mysum([]) fails in last 2</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; mysum([1, 2, 3, 4, 5])</span><br><span class="line">15</span><br><span class="line">&gt;&gt;&gt; mysum((&apos;s&apos;, &apos;p&apos;, &apos;a&apos;, &apos;m&apos;))                             # But various types now work</span><br><span class="line">&apos;spam&apos;</span><br><span class="line">&gt;&gt;&gt; mysum([&apos;spam&apos;, &apos;ham&apos;, &apos;eggs&apos;])</span><br><span class="line">&apos;spamhameggs&apos;</span><br></pre></td></tr></table></figure>

<p>可以使用Python的三元<code>if/else</code>表达式替代某些代码</p>
<p>可以针对任何可加和的类型一般化</p>
<p>可以使用拓展序列赋值解包</p>
<h3 id="循环语句VS递归"><a href="#循环语句VS递归" class="headerlink" title="循环语句VS递归"></a>循环语句VS递归</h3><p>循环语句不需要在调用堆栈上针对每次迭代都有一个本地作用域的副本,避免一般会与函数调用相关的速度成本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [1, 2, 3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; sum = 0</span><br><span class="line">&gt;&gt;&gt; while L:</span><br><span class="line">...     sum += L[0]</span><br><span class="line">...     L = L[1:]</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; sum</span><br><span class="line">15</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; L = [1, 2, 3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; sum = 0</span><br><span class="line">&gt;&gt;&gt; for x in L: sum += x</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; sum</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<p><code>while</code>使得事情更为具体,并且不需要定义一个支持递归调用的函数</p>
<p><code>for</code>循环自动迭代,且比递归在内存空间和执行时间方面效率更高</p>
<h3 id="处理任意结构"><a href="#处理任意结构" class="headerlink" title="处理任意结构"></a>处理任意结构</h3><p>递归(或者对等的显式的基于堆栈的算法)可以要求遍历任意形状的结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def sumtree(L):</span><br><span class="line">    tot = 0</span><br><span class="line">    for x in L:                         # For each item at this level</span><br><span class="line">        if not isinstance(x, list):</span><br><span class="line">            tot += x                    # Add numbers directly</span><br><span class="line">        else:</span><br><span class="line">            tot += sumtree(x)           # Recur for sublists</span><br><span class="line">    return tot</span><br><span class="line"></span><br><span class="line">L = [1, [2, [3, 4], 5], 6, [7, 8]]      # Arbitrary nesting</span><br><span class="line">print(sumtree(L))                       # Prints 36</span><br><span class="line"></span><br><span class="line"># Pathological cases</span><br><span class="line"></span><br><span class="line">print(sumtree([1, [2, [3, [4, [5]]]]])) # Prints 15(right-heavy)</span><br><span class="line">print(sumtree([[[[[1], 2], 3], 4], 5])) # Prints 15(left-heavy)</span><br></pre></td></tr></table></figure>

<p>简单的循环语句没有作用,因为这不是线性迭代</p>
<p>嵌套的循环语句也没有作用,因为子列表可能嵌套到任意的深度并且以任意的形式嵌套</p>
<hr>
<h2 id="函数对象-属性和注解"><a href="#函数对象-属性和注解" class="headerlink" title="函数对象:属性和注解"></a>函数对象:属性和注解</h2><p>Python函数是对象,自身全部存储在内存块中</p>
<p>函数可以跨程序自由地传递和间接调用</p>
<p>函数支持与调用无关的属性存储和注解操作</p>
<h3 id="间接函数调用"><a href="#间接函数调用" class="headerlink" title="间接函数调用"></a>间接函数调用</h3><p>函数对象可以赋值给函数名、传递给其他函数、嵌入到数据结构、从一个函数返回给另一个函数等等</p>
<p>函数可以由一个函数表达式后面的括号中的列表参数调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def echo(message):      # Name echo assigned to function object</span><br><span class="line">...     print(message)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; echo(&apos;Direct call&apos;)     # Call object through original name</span><br><span class="line">Direct call</span><br><span class="line">&gt;&gt;&gt; x = echo                # Now x references the function too</span><br><span class="line">&gt;&gt;&gt; x(&apos;Indirect call!&apos;)     # Call object through name by adding()</span><br><span class="line">Indirect call!</span><br></pre></td></tr></table></figure>

<p><code>def</code>语句将函数名赋值为一个函数对象的引用,可以把这个函数对象赋值给其他的变量名并通过变量名调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def indirect(func, arg):            # Call the passed-in object by adding ()</span><br><span class="line">...     func(arg)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; indirect(echo, &apos;Argument call!&apos;)    # Pass the function to another function</span><br><span class="line">Argument call!</span><br></pre></td></tr></table></figure>

<p>被调用者可以把函数作为参数添加到括号中并调用传入的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; schedule = [(echo, &apos;Spam!&apos;), (echo, &apos;Ham!&apos;)]</span><br><span class="line">&gt;&gt;&gt; for (func, arg) in schedule:</span><br><span class="line">...     func(arg)           # Call functions embedded in containers</span><br><span class="line">... </span><br><span class="line">Spam!</span><br><span class="line">Ham!</span><br></pre></td></tr></table></figure>

<p>可以把函数对象的内容填入到数据结构中并使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def make(label):            # Make a function but don&apos;t call it</span><br><span class="line">...     def echo(message):</span><br><span class="line">...             print(label + &apos;:&apos; + message)</span><br><span class="line">...     return echo</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; F = make(&apos;Spam&apos;)            # Label in enclosing scope is retained</span><br><span class="line">&gt;&gt;&gt; F(&apos;Ham!&apos;)                   # Call the function that make  retkr</span><br><span class="line">Spam:Ham!</span><br><span class="line">&gt;&gt;&gt; F(&apos;Eggs!&apos;)</span><br><span class="line">Spam:Eggs!</span><br></pre></td></tr></table></figure>

<p>函数可以创建并返回以便之后使用</p>
<h3 id="函数内省"><a href="#函数内省" class="headerlink" title="函数内省"></a>函数内省</h3><p>函数是对象,可以用常规的读写工具来处理函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def func(a):</span><br><span class="line">...     b = &apos;spam&apos;</span><br><span class="line">...     return b * a</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; func(8)</span><br><span class="line">&apos;spamspamspamspamspamspamspamspam&apos;</span><br><span class="line">&gt;&gt;&gt; func.__name__</span><br><span class="line">&apos;func&apos;</span><br><span class="line">&gt;&gt;&gt; dir(func)</span><br><span class="line">[&apos;__annotations__&apos;, &apos;__call__&apos;, &apos;__class__&apos;, &apos;__closure__&apos;, &apos;__code__&apos;, &apos;__defaults__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__get__&apos;, &apos;__getattribute__&apos;, &apos;__globals__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__kwdefaults__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__name__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__qualname__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;]</span><br></pre></td></tr></table></figure>

<p>调用表达式是定义在函数对象上的一个操作</p>
<p>可以通用地检查函数的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; func.__code__</span><br><span class="line">&lt;code object func at 0x1041f4930, file &quot;&lt;stdin&gt;&quot;, line 1&gt;</span><br><span class="line">&gt;&gt;&gt; dir(func.__code__)</span><br><span class="line">[&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;co_argcount&apos;, &apos;co_cellvars&apos;, &apos;co_code&apos;, &apos;co_consts&apos;, &apos;co_filename&apos;, &apos;co_firstlineno&apos;, &apos;co_flags&apos;, &apos;co_freevars&apos;, &apos;co_kwonlyargcount&apos;, &apos;co_lnotab&apos;, &apos;co_name&apos;, &apos;co_names&apos;, &apos;co_nlocals&apos;, &apos;co_stacksize&apos;, &apos;co_varnames&apos;]</span><br><span class="line">&gt;&gt;&gt; func.__code__.co_varnames</span><br><span class="line">(&apos;a&apos;, &apos;b&apos;)</span><br><span class="line">&gt;&gt;&gt; func.__code__.co_argcount</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>内省工具可以探索函数实现细节</p>
<p>函数附加的代码对象提供了函数的本地变量和参数等方面细节</p>
<h3 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def func(a):</span><br><span class="line">...     b = &apos;spam&apos;</span><br><span class="line">...     return b * a</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; func.count = 0</span><br><span class="line">&gt;&gt;&gt; func.count += 1</span><br><span class="line">&gt;&gt;&gt; func.count</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; func.handles = &apos;Button-Press&apos;</span><br><span class="line">&gt;&gt;&gt; func.handles</span><br><span class="line">&apos;Button-Press&apos;</span><br><span class="line">&gt;&gt;&gt; dir(func)</span><br><span class="line">[&apos;__annotations__&apos;, &apos;__call__&apos;, &apos;__class__&apos;, &apos;__closure__&apos;, &apos;__code__&apos;, &apos;__defaults__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__get__&apos;, &apos;__getattribute__&apos;, &apos;__globals__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__kwdefaults__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__name__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__qualname__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;count&apos;, &apos;handles&apos;]</span><br></pre></td></tr></table></figure>

<p>可以向函数附加任意的用户定义的属性,直接把状态信息附加到函数对象,而不必使用全局、非本地和类等其他技术</p>
<p>属性与对象相关而不是与作用域相关,函数退出后仍然保留</p>
<h3 id="Python-3-0中的函数注解"><a href="#Python-3-0中的函数注解" class="headerlink" title="Python 3.0中的函数注解"></a>Python 3.0中的函数注解</h3><p>Python 3.0中可以给函数对象附加注解信息,即与函数和结果相关的任意的用户定义的数据</p>
<p>声明注解信息是可选的,并且附加到函数对象的<code>__annotations__</code>属性</p>
<p>注解只在<code>def</code>语句中有效,在<code>lambda</code>表达式无效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def func(a, b, c):</span><br><span class="line">...     return a + b + c</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; func(1, 2, 3)</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def func(a: &apos;spam&apos;, b: (1, 10), c: float) -&gt; int:</span><br><span class="line">...     return a + b + c</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; func(1, 2, 3)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; func.__annotations__</span><br><span class="line">&#123;&apos;a&apos;: &apos;spam&apos;, &apos;b&apos;: (1, 10), &apos;c&apos;: &lt;class &apos;float&apos;&gt;, &apos;return&apos;: &lt;class &apos;int&apos;&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>函数注解编写在<code>def</code>头部,使函数头部语法通用化</p>
<p>对于参数,函数注解出现在紧随参数名之后的<code>:</code>之后</p>
<p>对于返回值,函数注解出现在参数列表之后的一个<code>-&gt;</code>之后</p>
<p>当注解出现的时候,Python将他们收集到注解键为参数名或<code>return</code>的字典中并且将它们附加给函数对象自身</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def func(a: &apos;spam&apos;, b, c: 99):</span><br><span class="line">...     return a + b + c</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; func(1, 2, 3)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; func.__annotations__</span><br><span class="line">&#123;&apos;a&apos;: &apos;spam&apos;, &apos;c&apos;: 99&#125;</span><br><span class="line">&gt;&gt;&gt; for arg in func.__annotations__:</span><br><span class="line">...     print(arg, &apos;=&gt;&apos;, func.__annotations__[arg])</span><br><span class="line">... </span><br><span class="line">a =&gt; spam</span><br><span class="line">c =&gt; 99</span><br></pre></td></tr></table></figure>

<p>注解是附加到一个Python对象的Python对象,可以直接处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def func(a: &apos;spam&apos; = 4, b: (1, 10) = 5, c: float = 6) -&gt; int:</span><br><span class="line">...     return a + b + c</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; func(1, 2, 3)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; func()              # 4 + 5 + 6(all default)</span><br><span class="line">15</span><br><span class="line">&gt;&gt;&gt; func(1, c=10)       # 1 + 5 + 10(keywords work normally)</span><br><span class="line">16</span><br><span class="line">&gt;&gt;&gt; func.__annotations__</span><br><span class="line">&#123;&apos;a&apos;: &apos;spam&apos;, &apos;b&apos;: (1, 10), &apos;c&apos;: &lt;class &apos;float&apos;&gt;, &apos;return&apos;: &lt;class &apos;int&apos;&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def func(a:&apos;spam&apos;=4, b:(1, 10)=5, c:float=6)-&gt;int:</span><br><span class="line">...     return a + b + c</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; func(1, 2)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; func.__annotations__</span><br><span class="line">&#123;&apos;a&apos;: &apos;spam&apos;, &apos;b&apos;: (1, 10), &apos;c&apos;: &lt;class &apos;float&apos;&gt;, &apos;return&apos;: &lt;class &apos;int&apos;&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>编写注解仍然可以使用默认值,注解出现在默认值之前</p>
<p>参数、默认值及注解之间的空格是可选的，省略可能会提高代码的可读性</p>
<hr>
<h2 id="匿名函数-lambda"><a href="#匿名函数-lambda" class="headerlink" title="匿名函数:lambda"></a>匿名函数:lambda</h2><p>Python提供了生成函数对象表达式形式<code>lambda</code>,这个表达式返回一个函数而不是赋值给一个变量名</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lambda`表达式的形式为`lambda argument1, argument2, ..., argumentN: expression using arguments</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>lambda是一个表达式, 而不是一个语句</p>
<p><code>lambda</code>能够出现在Python语法不允许<code>def</code>出现的地方,如在一个列表常量中或者函数调用的参数中</p>
<p>作为一个表达式,<code>lambda</code>返回一个函数,可以选择性地赋值给一个变量名,<code>def</code>语句总是得在头部将一个函数赋值给一个变量名,而不是将这个函数作为结果返回</p>
</li>
<li><p><code>lambda</code>的主体是一个单个的表达式,而不是一个代码块</p>
<p>这个<code>lambda</code>的主体就像放在<code>def</code>主体的<code>return</code>语句中的代码一样,简单地将结果写成一个顺畅的表达式,而不是明确的返回</p>
<p>因为仅限于表达式,<code>lambda</code>通常要比<code>def</code>功能要小,仅能够在<code>lambda</code>主体中封装有限的逻辑进去,限制了程序的嵌套</p>
</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def func(x, y, z): return x + y + z</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; func(2, 3, 4)</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f = lambda x, y, z: x +  y + z</span><br><span class="line">&gt;&gt;&gt; f(2, 3, 4)</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; x = (lambda a=&quot;fee&quot;, b=&quot;fie&quot;, c=&quot;foe&quot;: a + b + c)</span><br><span class="line">&gt;&gt;&gt; x(&quot;wee&quot;)</span><br><span class="line">&apos;weefiefoe&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def knights():</span><br><span class="line">...     title = &apos;Sir&apos;</span><br><span class="line">...     action = (lambda x: title + &apos; &apos; + x)    # Title in enclosing def</span><br><span class="line">...     return action                           # Return a function</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; act = knights()</span><br><span class="line">&gt;&gt;&gt; act(&apos;robin&apos;)</span><br><span class="line">&apos;Sir robin&apos;</span><br></pre></td></tr></table></figure>

<p><code>def</code>和<code>lambda</code>能够做同样种类的工作</p>
<p><code>lambda</code>表达式创建函数可以通过明确地将结果赋值给一个变量名后通过这个变量名调用函数</p>
<p><code>lambda</code>表达式参数中可以使用默认参数</p>
<p><code>lambda</code>主体中的代码遵循作用域查找法则,自动从上层函数中、模块中以及内置作用域中查找变量</p>
<h3 id="为什么使用lambda"><a href="#为什么使用lambda" class="headerlink" title="为什么使用lambda"></a>为什么使用lambda</h3><p><code>lambda</code>表达式允许在使用的代码内嵌入一个函数的定义,在仅需要嵌入小段可执行代码的情况下会带来一个更简洁的代码结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">L = [lambda x: x ** 2,      # Inline function definition</span><br><span class="line">    lambda x: x ** 3,</span><br><span class="line">    lambda x: x ** 4]       # A list of 3 callable functions</span><br><span class="line"></span><br><span class="line">for f in L:</span><br><span class="line">    print(f(2))             # Prints 4, 8, 16</span><br><span class="line"></span><br><span class="line">print(L[0](3))              # Prints 9</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">16</span><br><span class="line">9</span><br><span class="line">[Finished in 0.2s]</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">def f1(x): return x ** 2</span><br><span class="line">def f2(x): return x ** 3    # Define named functions</span><br><span class="line">def f3(x): return x ** 4</span><br><span class="line"></span><br><span class="line">L = [f1, f2, f3]            # Reference by name</span><br><span class="line"></span><br><span class="line">for f in L:</span><br><span class="line">    print(f(2))             # Prints 4,8,16</span><br><span class="line"></span><br><span class="line">print(L[0](3))              # Prints 9</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">16</span><br><span class="line">9</span><br><span class="line">[Finished in 0.2s]</span><br><span class="line">&apos;&apos;&apos;</span><br></pre></td></tr></table></figure>

<p><code>lambda</code>用来编写跳转表,能够按照需要执行相应的动作</p>
<p><code>lambda</code>表达式可以把小段的可执行代码编写进<code>def</code>语句从语法上不能编写进的地方</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; key = &apos;got&apos;</span><br><span class="line">&gt;&gt;&gt; &#123;&apos;already&apos;: (lambda: 2 + 2),</span><br><span class="line">... &apos;got&apos;: (lambda: 2 * 4),</span><br><span class="line">... &apos;one&apos;: (lambda: 2 ** 6)&#125;[key]()</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def f1(): return 2 + 2</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; def f2(): return 2 * 4</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; def f3(): return 2 ** 6</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; key = &apos;one&apos;</span><br><span class="line">&gt;&gt;&gt; &#123;&apos;already&apos;: f1, &apos;got&apos;: f2, &apos;one&apos;: f3&#125;[key]()</span><br><span class="line">64</span><br></pre></td></tr></table></figure>

<p>可以用Python中的字典或者其他的数据结构来构建更多种类的行为表,提供了在单个情况出现的函数</p>
<p>Python创建字典时,每个嵌套的<code>lambda</code>都生成并留下了一个在之后能够调用的函数,通过键索引来取回其中一个函数,而<code>()</code>使被取出的函数被调用</p>
<h3 id="如何-不要-让Python代码变得晦涩难懂"><a href="#如何-不要-让Python代码变得晦涩难懂" class="headerlink" title="如何(不要)让Python代码变得晦涩难懂"></a>如何(不要)让Python代码变得晦涩难懂</h3><p>在Python中可以基于表达式编写足够多的语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; lower = (lambda x, y: x if x &lt; y else y)</span><br><span class="line">&gt;&gt;&gt; lower(&apos;bb&apos;, &apos;aa&apos;)</span><br><span class="line">&apos;aa&apos;</span><br><span class="line">&gt;&gt;&gt; lower(&apos;aa&apos;, &apos;bb&apos;)</span><br><span class="line">&apos;aa&apos;</span><br></pre></td></tr></table></figure>

<p>在<code>lambda</code>中嵌套逻辑结构可以使用<code>if/else</code>三元表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; showall = lambda x: list(map(sys.stdout.write, x))</span><br><span class="line">&gt;&gt;&gt; t = showall([&apos;spam\n&apos;, &apos;toast\n&apos;, &apos;eggs\n&apos;])</span><br><span class="line">spam</span><br><span class="line">toast</span><br><span class="line">eggs</span><br><span class="line">&gt;&gt;&gt; showall = lambda x: [sys.stdout.write(line) for line in x]</span><br><span class="line">&gt;&gt;&gt; t = showall((&apos;bright\n&apos;, &apos;side\n&apos;, &apos;of\n&apos;, &apos;life\n&apos;))</span><br><span class="line">bright</span><br><span class="line">side</span><br><span class="line">of</span><br><span class="line">life</span><br></pre></td></tr></table></figure>

<p>在<code>lambda</code>中执行循环可以嵌入<code>map</code>调用或列表解析表达式</p>
<h3 id="嵌套lambda和作用域"><a href="#嵌套lambda和作用域" class="headerlink" title="嵌套lambda和作用域"></a>嵌套lambda和作用域</h3><p><code>lambda</code>可以在嵌套函数作用域中查找变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def action(x):</span><br><span class="line">...     return (lambda y: x + y)    # Make and return function.remember x</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; act = action(99)</span><br><span class="line">&gt;&gt;&gt; act</span><br><span class="line">&lt;function action.&lt;locals&gt;.&lt;lambda&gt; at 0x104708378&gt;</span><br><span class="line">&gt;&gt;&gt; act(2)                          # Call what action returned</span><br><span class="line">101</span><br></pre></td></tr></table></figure>

<p><code>lambda</code>出现在<code>def</code>中,并且在上层函数调用的时候,嵌套的<code>lambda</code>能够获取到在上层函数作用域中变量名的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; action = (lambda x: (lambda y: x + y))</span><br><span class="line">&gt;&gt;&gt; act = action(99)</span><br><span class="line">&gt;&gt;&gt; act(3)</span><br><span class="line">102</span><br><span class="line">&gt;&gt;&gt; ((lambda x: (lambda y: x + y))(99))(4)</span><br><span class="line">103</span><br></pre></td></tr></table></figure>

<p><code>lambda</code>能够获取任意上层<code>lambda</code>中的变量名</p>
<h3 id="为什么要在意-回调"><a href="#为什么要在意-回调" class="headerlink" title="为什么要在意:回调"></a>为什么要在意:回调</h3><p><code>lambda</code>为Python的tkinter GUI API定义行内的回调函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">from tkinter import Button, mainloop    # Tkinter in 2.6</span><br><span class="line">x = Button(</span><br><span class="line">        text=&apos;Press me&apos;,</span><br><span class="line">        command=(lambda:sys.stdout.write(&apos;Spam\n&apos;)))</span><br><span class="line">x.pack()</span><br><span class="line">mainloop()</span><br></pre></td></tr></table></figure>

<p>会跳出力气通过传递一个用<code>lambda</code>所产生的函数作为<code>command</code>的关键字参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MyGui:</span><br><span class="line">    def makewidgets(self):</span><br><span class="line">        Button(command=(lambda: self.onPress(&quot;spam&quot;)))</span><br><span class="line">    def onPress(self, message):</span><br><span class="line">        ...use message...</span><br></pre></td></tr></table></figure>

<p>嵌套的函数作用域法则使回调处理器可以自动查找编写时所在的函数中的变量名</p>
<hr>
<h2 id="在序列中映射函数-map"><a href="#在序列中映射函数-map" class="headerlink" title="在序列中映射函数:map"></a>在序列中映射函数:map</h2><p><code>map</code>函数会对一个序列对象中的每一个元素应用被传入的函数,并且返回一个包含了所有函数调用结果的一个可迭代对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; counters = [1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; updated = []</span><br><span class="line">&gt;&gt;&gt; for x in counters:</span><br><span class="line">...     updated.append(x + 10)              # Add 10 to each item</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; updated</span><br><span class="line">[11, 12, 13, 14]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def inc(x): return x + 10               # Function to be run</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; list(map(inc, counters))                # Collect results</span><br><span class="line">[11, 12, 13, 14]</span><br><span class="line">&gt;&gt;&gt; list(map((lambda x: x + 3), counters))  # Function expression</span><br><span class="line">[4, 5, 6, 7]</span><br></pre></td></tr></table></figure>

<p><code>map</code>函数期待一个函数,可以传入<code>lambda</code>表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def mymap(func, seq):</span><br><span class="line">...     res = []</span><br><span class="line">...     for x in seq: res.append(func(x))</span><br><span class="line">...     return res</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; def inc(x): return x + 10</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; list(map(inc, [1, 2, 3]))       # Built-in is an iterator</span><br><span class="line">[11, 12, 13]</span><br><span class="line">&gt;&gt;&gt; mymap(inc, [1, 2, 3])           # Ours builds a list</span><br><span class="line">[11, 12, 13]</span><br></pre></td></tr></table></figure>

<p>自己编写的一般映射工具</p>
<p><code>map</code>是内置函数,总是可用并总是以同样的方式工作,还有性能方面的优势</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pow(3, 4)                               # 3**4</span><br><span class="line">81</span><br><span class="line">&gt;&gt;&gt; list(map(pow, [1, 2, 3], [2, 3, 4]))    # 1**2,2**3,3**4</span><br><span class="line">[1, 8, 81]</span><br></pre></td></tr></table></figure>

<p>提供多个序列作为参数时能够并行返回分别以每个序列中的元素作为函数对应参数得到的结果的列表</p>
<p>对于多个序列,<code>map</code>期待一个N参数的函数用于N序列</p>
<hr>
<h2 id="函数式编程工具-filter和reduce"><a href="#函数式编程工具-filter和reduce" class="headerlink" title="函数式编程工具:filter和reduce"></a>函数式编程工具:filter和reduce</h2><p>函数式编程就是对序列应用一些函数的工具</p>
<p><code>filter</code>基于某一测试函数过滤元素</p>
<p><code>reduce</code>对每对元素都应用函数并运行到最后结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(-5, 5))                              # An iterator in 3.0</span><br><span class="line">[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; list(filter((lambda x: x &gt; 0), range(-5, 5)))   # An iterator in 3.0</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; res = []</span><br><span class="line">&gt;&gt;&gt; for x in range(-5, 5):</span><br><span class="line">...     if x &gt; 0:</span><br><span class="line">...             res.append(x)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; res</span><br><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<p><code>range</code>与<code>filter</code>返回可迭代对象,需要<code>list</code>调用来显示其所有结果</p>
<p><code>filter</code>函数会将返回值为真的序列元素键入到结果的列表中</p>
<p>可以用<code>for</code>循环等效替代,但是运行速度慢</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; res</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; reduce((lambda x, y:x + y), [1, 2, 3, 4])</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; reduce((lambda x, y:x * y), [1, 2, 3, 4])</span><br><span class="line">24</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; L = [1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; res = L[0]</span><br><span class="line">&gt;&gt;&gt; for x in L[1:]:</span><br><span class="line">...     res = res + x</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; res</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def myreduce(function, sequence):</span><br><span class="line">...     tally = sequence[0]</span><br><span class="line">...     for next in sequence[1:]:</span><br><span class="line">...             tally = function(tally, next)</span><br><span class="line">...     return tally</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; myreduce((lambda x, y: x + y),[1, 2, 3, 4, 5])</span><br><span class="line">15</span><br><span class="line">&gt;&gt;&gt; myreduce((lambda x, y: x * y), [1, 2, 3, 4, 5])</span><br><span class="line">120</span><br></pre></td></tr></table></figure>

<p><code>reduce</code>位于<code>functools</code>模块,接受一个迭代器来处理,但它自身不是一个迭代器,返回一个单个的结果</p>
<p><code>reduce</code>传递一个累加器以及列表的下一个元素给当前函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import operator, functools</span><br><span class="line">&gt;&gt;&gt; functools.reduce(operator.add, [2, 4, 6])       # Function-based +</span><br><span class="line">12</span><br><span class="line">&gt;&gt;&gt; functools.reduce((lambda x, y: x + y), [2, 4, 6])</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>内置的<code>operator</code>模块提供了内置表达式对应的函数</p>
<hr>
<h2 id="本章习题-3"><a href="#本章习题-3" class="headerlink" title="本章习题"></a>本章习题</h2><ol>
<li><p><code>lambda</code>表达式和<code>def</code>语句有什么关系</p>
<blockquote>
<p><code>lambda</code>和<code>def</code>都会创建函数对象,以便稍后调用</p>
<p><code>lambda</code>是表达式,可以嵌入函数定义中<code>def</code>语法上无法出现的地方</p>
<p><code>lambda</code>的使用总是可以用<code>def</code>来替代,并且通过变量名来引用函数</p>
<p>从语法上来讲,<code>lambda</code>只允许单个的返回值表达式,因为它不支持语句代码块,不适用于较大的函数</p>
</blockquote>
</li>
<li><p>使用<code>lambda</code>的要点是什么</p>
<blockquote>
<p><code>lambda</code>允许“内联”小单元延迟的可执行代码,并且以默认参数和封闭作用域变量的形式为其提供状态信息</p>
<p><code>lambda</code>可以通过编写一条def来替代它,并且用变量名来引用该函数</p>
<p><code>lambda</code>可以嵌套小段只是用一次的推迟的代码</p>
<p>通常出现在GUI这样的基于回调的程序中,并且与<code>map</code>和<code>filter</code>这些期待一个处理函数的函数工具密切相关</p>
</blockquote>
</li>
<li><p>比较和对比<code>map</code>、<code>flter</code>和<code>reduce</code></p>
<blockquote>
<p>这3个内置函数都对一个序列(可迭代)对象以及集合结果中的各项应用另一个函数</p>
<p><code>map</code>把每一项传递给函数并收集结果</p>
<p><code>filter</code>收集那些函数返回一个<code>True</code>值的项</p>
<p><code>reduce</code>通过对一个累加器和后续项应用函数来计算一个单个的值,在<code>functools</code>模块中可用</p>
</blockquote>
</li>
<li><p>什么是函数注解,如何使用它们</p>
<blockquote>
<p>函数注解是函数的参数及其结果的语法上的修饰,它会收集到分配给函数的<code>__annotations__</code>属性的一个字典中</p>
<p>Python在这些注解上没有放置语义含义,而是直接将其包装,以供其他工具潜在地使用</p>
</blockquote>
</li>
<li><p>什么是递归函数,如何使用它们</p>
<blockquote>
<p>递归函数调用本身可以直接地或间接地进行,从而实现循环</p>
<p>它们可以用来遍历任意形状的结构,也可以用来进行一般性迭代</p>
</blockquote>
</li>
<li><p>编写函数的通用设计规则是什么</p>
<blockquote>
<p>函数通常应该较小,尽可能自包含,拥有单一的、统一的用途,并且与输入参数和返回值等其他部分通信</p>
<p>如果期待修改的话,它们可以使用可变的参数来与结果通信,并且一些类型的程序暗含其他的通信机制</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="第二十章-迭代和解析-第二部分"><a href="#第二十章-迭代和解析-第二部分" class="headerlink" title="第二十章 迭代和解析,第二部分"></a>第二十章 迭代和解析,第二部分</h1><blockquote>
<ul>
<li>回顾解析和迭代概念</li>
<li>介绍内置解析和迭代工具</li>
<li>学习生成器函数以及相关的生成器表达式</li>
<li>度量了迭代替代方案的性能</li>
<li>概况目前为止所遇到的各种工具</li>
<li>回顾与函数相关的常见错误</li>
</ul>
</blockquote>
<hr>
<h2 id="回顾列表解析-函数式编程工具"><a href="#回顾列表解析-函数式编程工具" class="headerlink" title="回顾列表解析:函数式编程工具"></a>回顾列表解析:函数式编程工具</h2><p>列表解析把任意一个表达式而不是一个函数应用于一个迭代对象中的元素</p>
<p>列表解析可以成为一个比<code>map</code>和<code>filter</code>更通用的工具</p>
<h3 id="列表解析与map"><a href="#列表解析与map" class="headerlink" title="列表解析与map"></a>列表解析与map</h3><p>序列解析由<code>[]</code>封装起来,其中有一个表达式,其后跟着类似<code>for</code>循环头部的语句</p>
<p>列表解析在一个序列的值上应用一个任意表达式,将其结果收集到一个新的列表中并返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'spam'</span>:</span><br><span class="line"><span class="meta">... </span>    res.append(ord(x))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">[<span class="number">115</span>, <span class="number">112</span>, <span class="number">97</span>, <span class="number">109</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = list(map(ord, <span class="string">'spam'</span>))		<span class="comment"># Apply function to sequence</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">[<span class="number">115</span>, <span class="number">112</span>, <span class="number">97</span>, <span class="number">109</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = [ord(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'spam'</span>]		<span class="comment"># Apply expression to sequence</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">[<span class="number">115</span>, <span class="number">112</span>, <span class="number">97</span>, <span class="number">109</span>]</span><br></pre></td></tr></table></figure>

<p><code>map</code>函数把一个函数映射遍一个序列</p>
<p>序列解析把一个表达式映射遍一个序列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map((<span class="keyword">lambda</span> x: x ** <span class="number">2</span>), range(<span class="number">10</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure>

<p>列表解析在应用一个任意表达式的时候更方便</p>
<p><code>map</code>使用<code>lambda</code>在行内编写</p>
<h3 id="增加测试和嵌套循环"><a href="#增加测试和嵌套循环" class="headerlink" title="增加测试和嵌套循环"></a>增加测试和嵌套循环</h3><p><code>for</code>之后可以编写一个<code>if</code>语句来增加选择逻辑,可以当成与内置的<code>filter</code>类似的工具</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter((<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>), range(<span class="number">5</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>            res.append(x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><code>filter</code>需要创建一个<code>lambda</code>函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map((<span class="keyword">lambda</span> x: x**<span class="number">2</span>), filter((<span class="keyword">lambda</span> x: x % <span class="number">2</span> ==<span class="number">0</span>), range(<span class="number">10</span>))))</span><br><span class="line">[<span class="number">0</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>]</span><br></pre></td></tr></table></figure>

<p>列表解析中混合一个<code>if</code>分支以及任意表达式完成与<code>filter</code>和<code>map</code>相同的功效</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ expression <span class="keyword">for</span> target1 <span class="keyword">in</span> iterable1 [<span class="keyword">if</span> condition1]</span><br><span class="line">			<span class="keyword">for</span> target2 <span class="keyword">in</span> iterable2 [<span class="keyword">if</span> condition2] ...</span><br><span class="line">			<span class="keyword">for</span> targetN <span class="keyword">in</span> iterableN [<span class="keyword">if</span> conditionN] ]</span><br></pre></td></tr></table></figure>

<p>列表解析中可以编写任意数量的嵌套的<code>for</code>循环,并且每一个都有可选的关联的<code>if</code>测试</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x + y <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'spam'</span> <span class="keyword">for</span> y <span class="keyword">in</span> <span class="string">'SPAM'</span>]</span><br><span class="line">[<span class="string">'sS'</span>, <span class="string">'sP'</span>, <span class="string">'sA'</span>, <span class="string">'sM'</span>, <span class="string">'pS'</span>, <span class="string">'pP'</span>, <span class="string">'pA'</span>, <span class="string">'pM'</span>, <span class="string">'aS'</span>, <span class="string">'aP'</span>, <span class="string">'aA'</span>, <span class="string">'aM'</span>, <span class="string">'mS'</span>, <span class="string">'mP'</span>, <span class="string">'mA'</span>, <span class="string">'mM'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = [x + y <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">[<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">101</span>, <span class="number">201</span>, <span class="number">301</span>, <span class="number">102</span>, <span class="number">202</span>, <span class="number">302</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]:</span><br><span class="line"><span class="meta">... </span>            res.append(x + y)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">[<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">101</span>, <span class="number">201</span>, <span class="number">301</span>, <span class="number">102</span>, <span class="number">202</span>, <span class="number">302</span>]</span><br></pre></td></tr></table></figure>

<p>列表解析能够不使用列表的数字索引遍历字符串,并收集合并后的结果</p>
<p>列表解析中嵌套<code>for</code>分句时等效于嵌套的<code>for</code>循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>) <span class="keyword">if</span> x % <span class="number">2</span> ==<span class="number">0</span> <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">5</span>) <span class="keyword">if</span> y % <span class="number">2</span> == <span class="number">1</span>]</span><br><span class="line">[(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">4</span>, <span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>                    <span class="keyword">if</span> y % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>                            res.append((x, y))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">[(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">4</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure>

<p>嵌套的<code>for</code>从句中附加<code>if</code>分句过滤出每个序列中需要进行迭代的元素</p>
<p>将列表解析的<code>for</code>和<code>if</code>分句在其中进行嵌套可以得到等效的<code>for</code>循环语句</p>
<h3 id="列表解析和矩阵"><a href="#列表解析和矩阵" class="headerlink" title="列表解析和矩阵"></a>列表解析和矩阵</h3><p>使用Python编写矩阵的基本方法是使用嵌套的列表结构</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>M = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>N = [[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M[<span class="number">1</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M[<span class="number">1</span>][<span class="number">2</span>]</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[row[<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> M]</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[M[row][<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)]</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[M[i][i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(M))]</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[[M[row][col] * N[row][col] <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">3</span>)] <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">[[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>], [<span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>], [<span class="number">28</span>, <span class="number">32</span>, <span class="number">36</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>    tmp = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>            tmp.append(M[row][col] * N[row][col])</span><br><span class="line"><span class="meta">... </span>    res.append(tmp)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">[[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>], [<span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>], [<span class="number">28</span>, <span class="number">32</span>, <span class="number">36</span>]]</span><br></pre></td></tr></table></figure>

<p>使用通常的索引操作能够索引行,以及索引行中的列</p>
<p>列表解析自动扫描行和列,提取对角线元素</p>
<h3 id="理解列表解析"><a href="#理解列表解析" class="headerlink" title="理解列表解析"></a>理解列表解析</h3><p><code>map</code>调用比等效的<code>for</code>循环快两倍,列表解析比<code>map</code>调用稍快一些</p>
<p><code>for</code>循环让逻辑变得更清晰</p>
<p><code>map</code>和列表解析都是表达式,能够出现在<code>for</code>循环语句不能出现的地方使用</p>
<h3 id="为什么要在意-列表解析和map"><a href="#为什么要在意-列表解析和map" class="headerlink" title="为什么要在意:列表解析和map"></a>为什么要在意:列表解析和map</h3><p>列表解析运行表达式,显示出所有结果</p>
<p><code>map</code>运行函数,是一个迭代器,根据需求产生结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>open(<span class="string">'myfile'</span>).readlines()</span><br><span class="line">[<span class="string">'aaa\n'</span>, <span class="string">'bbb\n'</span>, <span class="string">'ccc\n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[line.rstrip() <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'myfile'</span>).readlines()]</span><br><span class="line">[<span class="string">'aaa'</span>, <span class="string">'bbb'</span>, <span class="string">'ccc'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[line.rstrip() <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'myfile'</span>)]</span><br><span class="line">[<span class="string">'aaa'</span>, <span class="string">'bbb'</span>, <span class="string">'ccc'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map((<span class="keyword">lambda</span> line: line.rstrip()), open(<span class="string">'myfile'</span>)))</span><br><span class="line">[<span class="string">'aaa'</span>, <span class="string">'bbb'</span>, <span class="string">'ccc'</span>]</span><br></pre></td></tr></table></figure>

<p>使用列表解析或<code>map</code>调用从所有行中去掉换行符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>listoftuple = [(<span class="string">'bob'</span>, <span class="number">35</span>, <span class="string">'mgr'</span>), (<span class="string">'mel'</span>, <span class="number">40</span>, <span class="string">'dev'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[age <span class="keyword">for</span> (name, age, job) <span class="keyword">in</span> listoftuple]</span><br><span class="line">[<span class="number">35</span>, <span class="number">40</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map((<span class="keyword">lambda</span> row: row[<span class="number">1</span>]), listoftuple))</span><br><span class="line">[<span class="number">35</span>, <span class="number">40</span>]</span><br></pre></td></tr></table></figure>

<p>列表解析作为一种列选择操作使用</p>
<hr>
<h2 id="重访迭代器-生成器"><a href="#重访迭代器-生成器" class="headerlink" title="重访迭代器:生成器"></a>重访迭代器:生成器</h2><p>Python提供了在需要时产生结果的工具</p>
<blockquote>
<ul>
<li>生成器函数:编写为常规的<code>def</code>语句,但是使用<code>yield</code>语句一次返回一个结果,在每个结果之间挂起和继续它们的状态</li>
<li>生成器表达式类似于的列表解析,但是返回按需产生结果的一个对象,而不是构建一个结果列表</li>
</ul>
</blockquote>
<h3 id="生成器函数-yield-VS-return"><a href="#生成器函数-yield-VS-return" class="headerlink" title="生成器函数:yield VS return"></a>生成器函数:yield VS return</h3><p>生成器函数是可以返回一个值并随后从退出的地方继续的函数</p>
<h4 id="状态挂起"><a href="#状态挂起" class="headerlink" title="状态挂起"></a>状态挂起</h4><p>生成器函数自动在生成值的时刻挂起并继续函数的执行,对于提前计算一系列值以及在类中手动保存和恢复状态很有用</p>
<p>生成器函数在挂起时保存的信息状态包含整个本地作用域,当函数恢复时使本地变量信息的可用</p>
<p><code>yield</code>语句挂起函数并向调用者发送回一个值,并保留足够的状态信息使得函数能够从它离开的地方继续,当继续时函数在上一个<code>yield</code>返回后立即继续执行</p>
<h4 id="迭代协议整合"><a href="#迭代协议整合" class="headerlink" title="迭代协议整合"></a>迭代协议整合</h4><p>可迭代对象定义了<code>__next__</code>方法,返回迭代中的下一项或者引发<code>StopIteration</code>异常</p>
<p>生成器函数包含<code>yield</code>语句编译为生成器,返回一个可迭代对象,该对象支持<code>__next__</code>方法,由<code>for</code>循环或其他迭代背景使用迭代协议遍历一个序列或值的生成器</p>
<p>生成器函数可能有<code>return</code>语句在<code>def</code>语句块的末尾终止值的生成,此时生成器的<code>__next__</code>方法引发一个<code>StopIteration</code>异常</p>
<p>生成器函数编写包含<code>yield</code>语句的<code>def</code>语句,自动支持迭代协议,并且由此可能用着任何迭代环境中以随时间并根据需要产生结果</p>
<h4 id="生成器函数应用"><a href="#生成器函数应用" class="headerlink" title="生成器函数应用"></a>生成器函数应用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gensquares</span><span class="params">(N)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">yield</span> i ** <span class="number">2</span>	<span class="comment"># Resume here later</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> gensquares(<span class="number">5</span>):		<span class="comment"># Resume the function</span></span><br><span class="line"><span class="meta">... </span>    print(i, end=<span class="string">' : '</span>)		<span class="comment"># Print last yielded value</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span> : <span class="number">1</span> : <span class="number">4</span> : <span class="number">9</span> : <span class="number">16</span> :</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = gensquares(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">&lt;generator object gensquares at <span class="number">0x103a30048</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(x)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(x)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(x)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(x)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(x)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>生成器函数每次都会产生一个值返还给调用者,当暂停时它的状态被保存下来并在<code>yield</code>语句之后被控制器回收,为了终止生成器,函数可以使用一个无值的返回语句</p>
<p>直接调用生成器函数得到一个生成器对象,支持迭代协议,调用<code>__next__</code>方法可以开始这个函数或从上次<code>yield</code>值后的地方恢复,并在得到最后一个值时产生<code>StopIteration</code>异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">buildsquares</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    res = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(n): res.append(i ** <span class="number">2</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> res</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> buildsquares(<span class="number">5</span>): print(x, end=<span class="string">' : '</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span> : <span class="number">1</span> : <span class="number">4</span> : <span class="number">9</span> : <span class="number">16</span> : </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [n ** <span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">5</span>)]:</span><br><span class="line"><span class="meta">... </span>    print(x, end=<span class="string">' : '</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span> : <span class="number">1</span> : <span class="number">4</span> : <span class="number">9</span> : <span class="number">16</span> :</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> map((<span class="keyword">lambda</span> n: n ** <span class="number">2</span>), range(<span class="number">5</span>)):</span><br><span class="line"><span class="meta">... </span>    print(x, end=<span class="string">' : '</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span> : <span class="number">1</span> : <span class="number">4</span> : <span class="number">9</span> : <span class="number">16</span> :</span><br></pre></td></tr></table></figure>

<p><code>for</code>循环、<code>map</code>或者列表解析可是实现相同的功能,但是生成器在内存使用和性能方面更好</p>
<p>生成器允许函数避免临时再做所有的工作,在<code>loop</code>迭代中将处理一系列值的时间分布开来,提供将类的对象保存到迭代中的状态的替代方案,能够进行自动的保存和恢复函数变量</p>
<h4 id="拓展生成器函数协议-send和next"><a href="#拓展生成器函数协议-send和next" class="headerlink" title="拓展生成器函数协议:send和next"></a>拓展生成器函数协议:send和next</h4><p><code>send</code>方法生成一系列结果的下一个元素,并提供了一种调用者与生成器之间进行通信的方法从而影响它的操作</p>
<p><code>yield</code>是一个表达式的形式,需要包含在括号中,可以返回<code>send</code>传入的值</p>
<p><code>throw(type)</code>方法将在生成器内部最后一个<code>yield</code>时产生一个终止迭代的<code>GeneratorExit</code>异常以及一个<code>close</code>方法</p>
<p><code>next(X)</code>函数调用对象的<code>X.__next__</code>方法,可以应用于所有的可迭代对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>            X = (<span class="keyword">yield</span> i + <span class="number">3</span>) * <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>            print(X)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G = gen()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(G)				<span class="comment"># Must call next() first, to start generator</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G.send(<span class="number">77</span>)			<span class="comment"># Advance, and send value to yield expression</span></span><br><span class="line"><span class="number">154</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G.send(<span class="number">88</span>)</span><br><span class="line"><span class="number">176</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(G)				<span class="comment"># next() and X.__next__() send None</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> gen</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> *: <span class="string">'NoneType'</span> <span class="keyword">and</span> <span class="string">'int'</span></span><br></pre></td></tr></table></figure>

<p>当使用拓展生成器函数协议时,值可以通过调用<code>G.send(value)</code>发送给生成器,生成器中的<code>yield</code>表达式返回传入的值,之后恢复生成器的代码,调用正常的<code>next</code>方法时<code>yield</code>返回<code>None</code></p>
<h3 id="生成器表达式-迭代器遇到列表解析"><a href="#生成器表达式-迭代器遇到列表解析" class="headerlink" title="生成器表达式:迭代器遇到列表解析"></a>生成器表达式:迭代器遇到列表解析</h3><p>生成器表达式像列表解析一样,但是是在<code>()</code>中而不是<code>[]</code>中</p>
<p>生成器表达式是对内存空间的优化,不需要一次构造出整个结果列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>)]			<span class="comment"># List comprehension:build a list</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>))			<span class="comment"># Generator expression:make an iterable</span></span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x103a320a0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>))		<span class="comment"># List comprehension equivalence</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>编写一个列表解析等同于在一个<code>list</code>内置调用中包含一个生成器表达式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>G = (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(G)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(G)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(G)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(G)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(G)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> num <span class="keyword">in</span> (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>)):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'%s, %s'</span> % (num, num / <span class="number">2.0</span>))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span>, <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>, <span class="number">0.5</span></span><br><span class="line"><span class="number">4</span>, <span class="number">2.0</span></span><br><span class="line"><span class="number">9</span>, <span class="number">4.5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>))</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted((x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>)), reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="number">9</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(math.sqrt, (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>))))</span><br><span class="line">[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br></pre></td></tr></table></figure>

<p>生成器表达式返回一个生成器对象,这个对象支持迭代协议并可以在任意的迭代语境中操作</p>
<p>生成器表达式在<code>()</code>之内,但是在函数调用中则不需要自身的<code>()</code></p>
<h3 id="生成器函数-VS-生成器表达式"><a href="#生成器函数-VS-生成器表达式" class="headerlink" title="生成器函数 VS 生成器表达式"></a>生成器函数 VS 生成器表达式</h3><p>同样的迭代可以用一个生成器函数或一个生成器表达式编写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>G = (c * <span class="number">4</span> <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'SPAM'</span>)			<span class="comment"># Generator expression</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(G)								<span class="comment"># Force generator to produce all results</span></span><br><span class="line">[<span class="string">'SSSS'</span>, <span class="string">'PPPP'</span>, <span class="string">'AAAA'</span>, <span class="string">'MMMM'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">timesfour</span><span class="params">(S)</span>:</span>					<span class="comment"># Generator function</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">yield</span> c * <span class="number">4</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G = timesfour(<span class="string">'spam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(G)								<span class="comment"># Iterate automatically</span></span><br><span class="line">[<span class="string">'ssss'</span>, <span class="string">'pppp'</span>, <span class="string">'aaaa'</span>, <span class="string">'mmmm'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G = (c * <span class="number">4</span> <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'SPAM'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I = iter(G)				<span class="comment"># Iterate manually</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I)</span><br><span class="line"><span class="string">'SSSS'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I)</span><br><span class="line"><span class="string">'PPPP'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G = timesfour(<span class="string">'spam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I = iter(G)				<span class="comment"># Iterate automatically</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I)</span><br><span class="line"><span class="string">'ssss'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I)</span><br><span class="line"><span class="string">'pppp'</span></span><br></pre></td></tr></table></figure>

<p>生成器函数能够编写更多的逻辑并使用更多的状态信息</p>
<p>表达式和函数支持自动和手动迭代,<code>list</code>函数自动调用迭代,<code>next</code>手动迭代</p>
<h3 id="生成器是单迭代器对象"><a href="#生成器是单迭代器对象" class="headerlink" title="生成器是单迭代器对象"></a>生成器是单迭代器对象</h3><p>生成器函数和生成器表达式自身都是迭代器,只支持一次活跃迭代</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">timesfour</span><span class="params">(S)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">yield</span> c * <span class="number">4</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G = timesfour(<span class="string">'spam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(G) <span class="keyword">is</span> G</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G = (c * <span class="number">4</span> <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'SPAM'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(G) <span class="keyword">is</span> G						<span class="comment"># My iterator is myself:G has __next__</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G = (c * <span class="number">4</span> <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'SPAM'</span>)			<span class="comment"># Make a new generator</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I1 = iter(G)						<span class="comment"># Iterate manually</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I1)</span><br><span class="line"><span class="string">'SSSS'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I1)</span><br><span class="line"><span class="string">'PPPP'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I2 = iter(G)						<span class="comment"># Second iterator at same position!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I2)</span><br><span class="line"><span class="string">'AAAA'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(I1)							<span class="comment"># Collect the rest of I1's items</span></span><br><span class="line">[<span class="string">'MMMM'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I2)							<span class="comment"># Other iterators exhausted too</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I3 = iter(G)						<span class="comment"># Ditto for new iterators</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I3 = iter(c * <span class="number">4</span> <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'SPAM'</span>)	<span class="comment"># New generator to start over</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I3)</span><br><span class="line"><span class="string">'SSSS'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G = timesfour(<span class="string">'spam'</span>)				<span class="comment"># Generator functions work the same way</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I1, I2 = iter(G), iter(G)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I1)</span><br><span class="line"><span class="string">'ssss'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I1)</span><br><span class="line"><span class="string">'pppp'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I2)							<span class="comment"># I2 at same position as I1</span></span><br><span class="line"><span class="string">'aaaa'</span></span><br></pre></td></tr></table></figure>

<p>一个生成器的迭代器是生成器自身</p>
<p>手动地使用多个迭代器来迭代结果流,会指向相同的位置</p>
<p>一旦任何迭代器运行到终止,所有的迭代器都将用尽,必须产生一个新的生成器重新开始</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I1, I2 = iter(L), iter(L)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I1)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I1)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I2)		<span class="comment"># Lists support multiple iterators</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> L[<span class="number">2</span>:]		<span class="comment"># Changes reflected in iterators</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I1)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>某些内置类型支持多个迭代器并且在一个活动迭代器中传递并反映他们的原处修改</p>
<h3 id="用迭代工具模拟zip和map"><a href="#用迭代工具模拟zip和map" class="headerlink" title="用迭代工具模拟zip和map"></a>用迭代工具模拟zip和map</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>S1 = <span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>S2 = <span class="string">'xyz123'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(S1, S2))						<span class="comment"># zip pairs items from iterables</span></span><br><span class="line">[(<span class="string">'a'</span>, <span class="string">'x'</span>), (<span class="string">'b'</span>, <span class="string">'y'</span>), (<span class="string">'c'</span>, <span class="string">'z'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># zip pairs items, truncates at shortest</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip([<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]))			<span class="comment"># Single sequence: 1-ary tuples</span></span><br><span class="line">[(<span class="number">-2</span>,), (<span class="number">-1</span>,), (<span class="number">0</span>,), (<span class="number">1</span>,), (<span class="number">2</span>,)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))		<span class="comment"># N sequences: N-ary tuples</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># map passes paired itenms to a function, truncates</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(abs, [<span class="number">-2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]))		<span class="comment"># Single sequence: 1-ary function </span></span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(pow, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))	<span class="comment"># N sequences: N-ary function</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure>

<p><code>zip</code>和<code>map</code>配对元素方式相同</p>
<h4 id="编写自己的map-func-…"><a href="#编写自己的map-func-…" class="headerlink" title="编写自己的map(func,…)"></a>编写自己的map(func,…)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># map(func, seqs...) workalike with zip</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mymap</span><span class="params">(func, *seqs)</span>:</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> args <span class="keyword">in</span> zip(*seqs):</span><br><span class="line">		res.append(func(*args))</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(mymap(abs, [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line">print(mymap(pow, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[2, 1, 0, 1, 2]</span></span><br><span class="line"><span class="string">[1, 8, 81]</span></span><br><span class="line"><span class="string">[Finished in 0.3s]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p><code>map</code>收集多个可迭代参数,将其作为<code>zip</code>参数迭代,使用<code>*args</code>参数传递语法解包传入函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Using a list comprehension</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mymap</span><span class="params">(func, *seqs)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> [func(*args) <span class="keyword">for</span> args <span class="keyword">in</span> zip(*seqs)]</span><br><span class="line"></span><br><span class="line">print(mymap(abs, [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line">print(mymap(pow, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[2, 1, 0, 1, 2]</span></span><br><span class="line"><span class="string">[1, 8, 81]</span></span><br><span class="line"><span class="string">[Finished in 0.2s]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>使用列表解析可以更精简并且可能运行的更快</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Using generators: yield and (...)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mymap</span><span class="params">(func, *seqs)</span>:</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> args <span class="keyword">in</span> zip(*seqs):</span><br><span class="line">		<span class="keyword">yield</span> func(*args)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mymap</span><span class="params">(func, *seqs)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> (func(*args) <span class="keyword">for</span> args <span class="keyword">in</span> zip(*seqs))</span><br><span class="line"></span><br><span class="line">print(list(mymap(abs, [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])))</span><br><span class="line">print(list(mymap(pow, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[2, 1, 0, 1, 2]</span></span><br><span class="line"><span class="string">[1, 8, 81]</span></span><br><span class="line"><span class="string">[Finished in 0.2s]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>使用生成器函数和表达式产生同样的结果,但是返回支持迭代协议的生成器</p>
<p>使用<code>list</code>强迫生成器运行</p>
<h4 id="编写自己的zip-…-和map-None-…"><a href="#编写自己的zip-…-和map-None-…" class="headerlink" title="编写自己的zip(…)和map(None,…)"></a>编写自己的zip(…)和map(None,…)</h4><p>使用迭代工具编写<code>zip</code>和Python 2.6的可以填充的<code>map</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zip(seqs...) and 2.6 map(None, seqs...) workalikes</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myzip</span><span class="params">(*seqs)</span>:</span></span><br><span class="line">	seqs = [list(S) <span class="keyword">for</span> S <span class="keyword">in</span> seqs]</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">while</span> all(seqs):</span><br><span class="line">		res.append(tuple(S.pop(<span class="number">0</span>) <span class="keyword">for</span> S <span class="keyword">in</span> seqs))</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mymapPad</span><span class="params">(*seqs, pad=None)</span>:</span></span><br><span class="line">	seqs = [list(S) <span class="keyword">for</span> S <span class="keyword">in</span> seqs]</span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">while</span> any(seqs):</span><br><span class="line">		res.append(tuple((S.pop(<span class="number">0</span>)) <span class="keyword">if</span> S <span class="keyword">else</span> pad) <span class="keyword">for</span> S <span class="keyword">in</span> seqs)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">S1, S2 = <span class="string">'abc'</span>, <span class="string">'xyz123'</span></span><br><span class="line">print(myzip(S1, S2))</span><br><span class="line">print(mymapPad(S1, S2))</span><br><span class="line">print(mymapPad(S1, S2, pad=<span class="number">99</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[('a', 'x'), ('b', 'y'), ('c', 'z')]</span></span><br><span class="line"><span class="string">[('a', 'x'), ('b', 'y'), ('c', 'z'), (None, '1'), (None, '2'), (None, '3')]</span></span><br><span class="line"><span class="string">[('a', 'x'), ('b', 'y'), ('c', 'z'), (99, '1'), (99, '2'), (99, '3')]</span></span><br><span class="line"><span class="string">[Finished in 0.3s]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>这里编写的函数可以在任何类型的可迭代对象上运行,因为通过<code>list</code>内置函数传入参数</p>
<p>一个可迭代对象中所有元素为<code>True</code>则<code>all</code>返回<code>True</code>,一个可迭代对象中任何元素为<code>True</code>则<code>any</code>为<code>True</code></p>
<p><code>keyword-only</code>参数pad指定填充对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Using generators: yield</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myzip</span><span class="params">(*seqs)</span>:</span></span><br><span class="line">	seqs = [list(S) <span class="keyword">for</span> S <span class="keyword">in</span> seqs]</span><br><span class="line">	<span class="keyword">while</span> all(seqs):</span><br><span class="line">		<span class="keyword">yield</span> tuple(S.pop(<span class="number">0</span>) <span class="keyword">for</span> S <span class="keyword">in</span> seqs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mymapPad</span><span class="params">(*seqs, pad=None)</span>:</span></span><br><span class="line">	seqs = [list(S) <span class="keyword">for</span> S <span class="keyword">in</span> seqs]</span><br><span class="line">	<span class="keyword">while</span> any(seqs):</span><br><span class="line">		<span class="keyword">yield</span> tuple((S.pop(<span class="number">0</span>) <span class="keyword">if</span> S <span class="keyword">else</span> pad) <span class="keyword">for</span> S <span class="keyword">in</span> seqs)</span><br><span class="line"></span><br><span class="line">S1, S2 = <span class="string">'abc'</span>, <span class="string">'xyz123'</span></span><br><span class="line">print(list(myzip(S1, S2)))</span><br><span class="line">print(list(mymapPad(S1, S2)))</span><br><span class="line">print(list(mymapPad(S1, S2, pad=<span class="number">99</span>)))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[('a', 'x'), ('b', 'y'), ('c', 'z')]</span></span><br><span class="line"><span class="string">[('a', 'x'), ('b', 'y'), ('c', 'z'), (None, '1'), (None, '2'), (None, '3')]</span></span><br><span class="line"><span class="string">[('a', 'x'), ('b', 'y'), ('c', 'z'), (99, '1'), (99, '2'), (99, '3')]</span></span><br><span class="line"><span class="string">[Finished in 0.5s]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>使用<code>yield</code>转换为生成器</p>
<p>使用<code>list</code>调用激活生成器和迭代器产生结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Alternate implementation with lengths</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myzip</span><span class="params">(*seqs)</span>:</span></span><br><span class="line">	minlen = min(len(S) <span class="keyword">for</span> S <span class="keyword">in</span> seqs)</span><br><span class="line">	<span class="keyword">return</span> [tuple(S[i] <span class="keyword">for</span> S <span class="keyword">in</span> seqs) <span class="keyword">for</span> i <span class="keyword">in</span> range(minlen)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mymapPad</span><span class="params">(*seqs, pad=None)</span>:</span></span><br><span class="line">	maxlen = max(len(S) <span class="keyword">for</span> S <span class="keyword">in</span> seqs)</span><br><span class="line">	index = range(maxlen)</span><br><span class="line">	<span class="keyword">return</span> [tuple((S[i] <span class="keyword">if</span> len(S) &gt; i <span class="keyword">else</span> pad) <span class="keyword">for</span> S <span class="keyword">in</span> seqs) <span class="keyword">for</span> i <span class="keyword">in</span> index]</span><br><span class="line"></span><br><span class="line">S1, S2 = <span class="string">'abc'</span>, <span class="string">'xyz123'</span></span><br><span class="line">print(myzip(S1, S2))</span><br><span class="line">print(mymapPad(S1, S2))</span><br><span class="line">print(mymapPad(S1, S2, pad=<span class="number">99</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[('a', 'x'), ('b', 'y'), ('c', 'z')]</span></span><br><span class="line"><span class="string">[('a', 'x'), ('b', 'y'), ('c', 'z'), (None, '1'), (None, '2'), (None, '3')]</span></span><br><span class="line"><span class="string">[('a', 'x'), ('b', 'y'), ('c', 'z'), (99, '1'), (99, '2'), (99, '3')]</span></span><br><span class="line"><span class="string">[Finished in 0.2s]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>通过计算最小和最大参数长度编写嵌套的列表解析来遍历参数所以范围</p>
<p>参数只能是序列或类似的而不是任意的可迭代对象</p>
<p><code>min</code>和<code>max</code>的参数是生成器表达式,<code>range</code>是一个可迭代对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Using generators:(...)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myzip</span><span class="params">(*seqs)</span>:</span></span><br><span class="line">	minlen = min(len(S) <span class="keyword">for</span> S <span class="keyword">in</span> seqs)</span><br><span class="line">	<span class="keyword">return</span> (tuple(S[i] <span class="keyword">for</span> S <span class="keyword">in</span> seqs) <span class="keyword">for</span> i <span class="keyword">in</span> range(minlen))</span><br><span class="line"></span><br><span class="line">S1, S2 = <span class="string">'abc'</span>, <span class="string">'xyz123'</span></span><br><span class="line">print(list(myzip(S1, S2)))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[('a', 'x'), ('b', 'y'), ('c', 'z')]</span></span><br><span class="line"><span class="string">[Finished in 0.1s]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>使用圆括号将列表构建器转换为生成器</p>
<p>使用<code>list</code>调用激活生成器和迭代器产生结果</p>
<h3 id="为什么你会留意-单次迭代"><a href="#为什么你会留意-单次迭代" class="headerlink" title="为什么你会留意:单次迭代"></a>为什么你会留意:单次迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myzip</span><span class="params">(*args)</span>:</span></span><br><span class="line">	iters = list(map(iter, args))</span><br><span class="line">	<span class="keyword">while</span> iters:</span><br><span class="line">		res = [next(i) <span class="keyword">for</span> i <span class="keyword">in</span> iters]</span><br><span class="line">		<span class="keyword">yield</span> tuple(res)</span><br></pre></td></tr></table></figure>

<p>使用<code>iter</code>和<code>next</code>对任何类型的可迭代对象都有效</p>
<p>一个迭代器用尽时由<code>next</code>引发<code>StopIteration</code>异常终止生成器函数,与 <code>return</code>语句有相同效果</p>
<p>在Python 3.0中,<code>map</code>返回一个单次可迭代对象,如果没有使用<code>list</code>内置函数创建一个支持多次迭代的对象,在循环中运行一次列表解析后,<code>iters</code>将会永远为空进入无限循环</p>
<h3 id="内置类型和类中的值生成"><a href="#内置类型和类中的值生成" class="headerlink" title="内置类型和类中的值生成"></a>内置类型和类中的值生成</h3><p>可以用遵守迭代协议的类实现任意的用户定义的的生成器对象,这样的类有一个<code>__iter__</code>方法,由内置的<code>iter</code>函数调用,返回一个对象,该对象有<code>__next__</code>方法,由<code>next</code>函数调用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>D = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = iter(D)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(x)</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(x)</span><br><span class="line"><span class="string">'b'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> D:</span><br><span class="line"><span class="meta">... </span>    print(key, D[key])</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">a <span class="number">1</span></span><br><span class="line">b <span class="number">2</span></span><br><span class="line">c <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>字典拥有在每次迭代中产生键的迭代器,可以手动迭代或使用<code>for</code>循环、<code>map</code>调用、列表解析以及其他环境等自动迭代工具</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'temp.txt'</span>):</span><br><span class="line"><span class="meta">... </span>    print(line, end=<span class="string">''</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Tis but</span><br><span class="line">a flesh wound.</span><br></pre></td></tr></table></figure>

<p>在文件迭代器中,载入文件的行</p>
<hr>
<h2 id="Python-3-0解析语法概况"><a href="#Python-3-0解析语法概况" class="headerlink" title="Python 3.0解析语法概况"></a>Python 3.0解析语法概况</h2><blockquote>
<ul>
<li><p>对于集合</p>
<p>新的常量形式<code>{1, 3, 2}</code>等同于<code>set([1,3,2])</code></p>
<p>新的集合解析语法<code>{f(x) for x in S if P(x)}</code>等同于生成器表达式<code>set(f(x) for x in S if P(x))</code>,其中<code>f(x)</code>是一个任意的表达式</p>
</li>
<li><p>对于字典</p>
<p>新的字典解析语法<code>{key: val for (key,val) in zip(keys, vals)}</code>等同于<code>dict(zip(keys, vals))</code></p>
<p><code>{x:f(x) for x in items}</code>像生成器表达式<code>dict((x，f(x)) for x in items)</code>一样工作</p>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]					<span class="comment"># List comprehension:builds list</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]			<span class="comment"># like list(generator expr)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))					<span class="comment"># Generator expression:produces items</span></span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1039cdfc0</span>&gt;		<span class="comment"># Parens are often optional</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)&#125;					<span class="comment"># Set comprehension, new in 3.0</span></span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">64</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">49</span>, <span class="number">81</span>, <span class="number">25</span>&#125;			<span class="comment"># &#123;x, y&#125; is a set in 3.0 too</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x:x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)&#125;				<span class="comment"># Dictionary comprehension, new in 3.0</span></span><br><span class="line">&#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">5</span>: <span class="number">25</span>, <span class="number">6</span>: <span class="number">36</span>, <span class="number">7</span>: <span class="number">49</span>, <span class="number">8</span>: <span class="number">64</span>, <span class="number">9</span>: <span class="number">81</span>&#125;</span><br></pre></td></tr></table></figure>

<p>所有解析语法</p>
<h3 id="解析集合和字典解析"><a href="#解析集合和字典解析" class="headerlink" title="解析集合和字典解析"></a>解析集合和字典解析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)&#125;				<span class="comment"># Comprehension</span></span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">64</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">49</span>, <span class="number">81</span>, <span class="number">25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set(x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))			<span class="comment"># Genereator and type name</span></span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">64</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">49</span>, <span class="number">81</span>, <span class="number">25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x: x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)&#125;</span><br><span class="line">&#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">5</span>: <span class="number">25</span>, <span class="number">6</span>: <span class="number">36</span>, <span class="number">7</span>: <span class="number">49</span>, <span class="number">8</span>: <span class="number">64</span>, <span class="number">9</span>: <span class="number">81</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict((x, x * x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line">&#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">5</span>: <span class="number">25</span>, <span class="number">6</span>: <span class="number">36</span>, <span class="number">7</span>: <span class="number">49</span>, <span class="number">8</span>: <span class="number">64</span>, <span class="number">9</span>: <span class="number">81</span>&#125;</span><br></pre></td></tr></table></figure>

<p>集合解析和字典解析是把生成器表达式传递给类型名的语法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = set()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):		<span class="comment"># Set comprehension equivalent</span></span><br><span class="line"><span class="meta">... </span>    res.add(x * x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">64</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">49</span>, <span class="number">81</span>, <span class="number">25</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):		<span class="comment"># Dict comprehension equivalent</span></span><br><span class="line"><span class="meta">... </span>    res[x] = x * x</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">&#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">5</span>: <span class="number">25</span>, <span class="number">6</span>: <span class="number">36</span>, <span class="number">7</span>: <span class="number">49</span>, <span class="number">8</span>: <span class="number">64</span>, <span class="number">9</span>: <span class="number">81</span>&#125;</span><br></pre></td></tr></table></figure>

<p>解析语法总是可以用手动代码来构建结果对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>G = ((x, x * x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(G)</span><br><span class="line">(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(G)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>集合解析和列表解析接受迭代器,但是根据需要产生结果的概念</p>
<p>根据需要产生键和值可以用生成器表达式</p>
<h3 id="针对集合和字典的拓展的解析语法"><a href="#针对集合和字典的拓展的解析语法" class="headerlink" title="针对集合和字典的拓展的解析语法"></a>针对集合和字典的拓展的解析语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]		<span class="comment"># Lists are ordered</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>&#125;		<span class="comment"># But sets are not</span></span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">64</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">16</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x: x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>&#125;		<span class="comment"># Neither are dict keys</span></span><br><span class="line">&#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">6</span>: <span class="number">36</span>, <span class="number">8</span>: <span class="number">64</span>&#125;</span><br></pre></td></tr></table></figure>

<p>集合和字典解析支持嵌套相关的<code>if</code>子句从结果中过滤掉元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x + y <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]	<span class="comment"># Lists keep duplicates</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x + y <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;	<span class="comment"># Buts sets do not</span></span><br><span class="line">&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x : y <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;	<span class="comment"># Neither do dict keys</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">6</span>, <span class="number">2</span>: <span class="number">6</span>, <span class="number">3</span>: <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<p>集合和字典解析支持嵌套的<code>for</code>循环,但是这两种类型具有<strong>无序性</strong>和<strong>互异性</strong>,导致结果看上去缺乏直接性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x + y <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'ab'</span> <span class="keyword">for</span> y <span class="keyword">in</span> <span class="string">'cd'</span>&#125;</span><br><span class="line">&#123;<span class="string">'bc'</span>, <span class="string">'ad'</span>, <span class="string">'bd'</span>, <span class="string">'ac'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x + y: (ord(x), ord(y)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'ab'</span> <span class="keyword">for</span> y <span class="keyword">in</span> <span class="string">'cd'</span>&#125;</span><br><span class="line">&#123;<span class="string">'ac'</span>: (<span class="number">97</span>, <span class="number">99</span>), <span class="string">'ad'</span>: (<span class="number">97</span>, <span class="number">100</span>), <span class="string">'bc'</span>: (<span class="number">98</span>, <span class="number">99</span>), <span class="string">'bd'</span>: (<span class="number">98</span>, <span class="number">100</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;k * <span class="number">2</span> <span class="keyword">for</span> k <span class="keyword">in</span> [<span class="string">'spam'</span>, <span class="string">'ham'</span>, <span class="string">'sausage'</span>] <span class="keyword">if</span> k[<span class="number">0</span>] == <span class="string">'s'</span>&#125;</span><br><span class="line">&#123;<span class="string">'sausagesausage'</span>, <span class="string">'spamspam'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;k.upper(): k * <span class="number">2</span> <span class="keyword">for</span> k <span class="keyword">in</span> [<span class="string">'spam'</span>, <span class="string">'ham'</span>, <span class="string">'sausage'</span>] <span class="keyword">if</span> k[<span class="number">0</span>] == <span class="string">'s'</span>&#125;</span><br><span class="line">&#123;<span class="string">'SPAM'</span>: <span class="string">'spamspam'</span>, <span class="string">'SAUSAGE'</span>: <span class="string">'sausagesausage'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>集合和字典解析可以在任何类型的可迭代对象上迭代</p>
<hr>
<h2 id="对迭代的各种方法进行计时"><a href="#对迭代的各种方法进行计时" class="headerlink" title="对迭代的各种方法进行计时"></a>对迭代的各种方法进行计时</h2><p>列表解析要比<code>for</code>循环语句有速度方面的性能优势</p>
<p><code>map</code>会依据调用方法的不同表现出更好或更差的性能</p>
<h3 id="对模块计时"><a href="#对模块计时" class="headerlink" title="对模块计时"></a>对模块计时</h3><p>解释器优化是内部化的问题,无法猜测哪种方案会执行的最好,最好在自己的计算机上用自己的Python版本对自己的代码计时</p>
<p>性能不应是编写Python代码首要关心问题,应该在可读性和简单性的基础上编写代码,在需要的时候性能优化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File mytimer.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">reps = <span class="number">1000</span></span><br><span class="line">repslist = range(reps)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func, *pargs, **kargs)</span>:</span></span><br><span class="line">	start = time.clock()</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> repslist:</span><br><span class="line">		ret = func(*pargs, **kargs)</span><br><span class="line">	elapsed = time.clock() - start</span><br><span class="line">	<span class="keyword">return</span> (elapsed, ret)</span><br></pre></td></tr></table></figure>

<p>这个模块通过获取开始时间、调用函数固定的次数并且用开始时间减去停止时间,从而对使用任何位置和关键字参数调用任意函数进行计时,完成后调用的总时间与被计时的函数的最终返回值作为一个元组返回</p>
<blockquote>
<ul>
<li>Python的<code>time</code>模块允许访问当前时间,精度随着每个平台而有所不同</li>
<li><code>range</code>调用放到了计时循环之外,它的构建成本不会计算到计时函数中</li>
<li><code>reps</code>计数是一个全局变量,可以修改:mytimer.reps = N</li>
</ul>
</blockquote>
<h3 id="计时脚本"><a href="#计时脚本" class="headerlink" title="计时脚本"></a>计时脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, mytimer</span><br><span class="line">reps = <span class="number">10000</span></span><br><span class="line">repslist = range(reps)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forLoop</span><span class="params">()</span>:</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> repslist:</span><br><span class="line">		res.append(abs(x))</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listComp</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> [abs(x) <span class="keyword">for</span> x <span class="keyword">in</span> repslist]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapCall</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> list(map(abs, repslist))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genExpr</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> list(abs(x) <span class="keyword">for</span> x <span class="keyword">in</span> repslist)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genFunc</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> repslist:</span><br><span class="line">			<span class="keyword">yield</span> abs(x)</span><br><span class="line">	<span class="keyword">return</span> list(gen())</span><br><span class="line"></span><br><span class="line">print(sys.version)</span><br><span class="line"><span class="keyword">for</span> test <span class="keyword">in</span> (forLoop, listComp, mapCall, genExpr, genFunc):</span><br><span class="line">	elapsed , result = mytimer.timer(test)</span><br><span class="line">	print(<span class="string">'-'</span> * <span class="number">33</span>)</span><br><span class="line">	print(<span class="string">'%-9s: %.5f =&gt; [%s...%s]'</span> % (test.__name__, elapsed, result[<span class="number">0</span>], result[<span class="number">-1</span>]))</span><br><span class="line">    </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">3.6.4 (v3.6.4:d48ecebad5, Dec 18 2017, 21:07:28) </span></span><br><span class="line"><span class="string">[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)]</span></span><br><span class="line"><span class="string">---------------------------------</span></span><br><span class="line"><span class="string">forLoop  : 2.11010 =&gt; [0...9999]</span></span><br><span class="line"><span class="string">---------------------------------</span></span><br><span class="line"><span class="string">listComp : 1.23212 =&gt; [0...9999]</span></span><br><span class="line"><span class="string">---------------------------------</span></span><br><span class="line"><span class="string">mapCall  : 0.65460 =&gt; [0...9999]</span></span><br><span class="line"><span class="string">---------------------------------</span></span><br><span class="line"><span class="string">genExpr  : 1.67717 =&gt; [0...9999]</span></span><br><span class="line"><span class="string">---------------------------------</span></span><br><span class="line"><span class="string">genFunc  : 1.66981 =&gt; [0...9999]</span></span><br><span class="line"><span class="string">[Finished in 7.6s]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>这段脚本测试了五种构建结果列表的替代方法</p>
<p>必须通过内置<code>list</code>调用来运行生成器表达式、生成器函数与<code>map</code>,迫使他们产生所有值,否则可能得到没有真正工作的生成器</p>
<p>内置属性<code>__name__</code>给出函数的名称</p>
<h3 id="计时结果"><a href="#计时结果" class="headerlink" title="计时结果"></a>计时结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">3.6.4 (v3.6.4:d48ecebad5, Dec 18 2017, 21:07:28) </span><br><span class="line">[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)]</span><br><span class="line">---------------------------------</span><br><span class="line">forLoop  : 2.11010 =&gt; [0...9999]</span><br><span class="line">---------------------------------</span><br><span class="line">listComp : 1.23212 =&gt; [0...9999]</span><br><span class="line">---------------------------------</span><br><span class="line">mapCall  : 0.65460 =&gt; [0...9999]</span><br><span class="line">---------------------------------</span><br><span class="line">genExpr  : 1.67717 =&gt; [0...9999]</span><br><span class="line">---------------------------------</span><br><span class="line">genFunc  : 1.66981 =&gt; [0...9999]</span><br><span class="line">[Finished in 7.6s]</span><br></pre></td></tr></table></figure>

<p><code>map</code>比列表解析略快一点,且都比<code>for</code>循环快很多</p>
<p>生成器表达式比列表解析运行的慢,尽管把一个生成器表达式包装到一个<code>list</code>调用中,使得其功能等同于一个带有方括号的列表解析,两种表达式的内部实现看上去有所不同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, mytimer</span><br><span class="line">reps = <span class="number">10000</span></span><br><span class="line">repslist = range(reps)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forLoop</span><span class="params">()</span>:</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> repslist:</span><br><span class="line">		res.append(x + <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listComp</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> [x + <span class="number">10</span> <span class="keyword">for</span> x <span class="keyword">in</span> repslist]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapCall</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> list(map(<span class="keyword">lambda</span> x: x + <span class="number">10</span>, repslist))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genExpr</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> list(x + <span class="number">10</span> <span class="keyword">for</span> x <span class="keyword">in</span> repslist)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genFunc</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> repslist:</span><br><span class="line">			<span class="keyword">yield</span> x + <span class="number">10</span></span><br><span class="line">	<span class="keyword">return</span> list(gen())</span><br><span class="line"></span><br><span class="line">print(sys.version)</span><br><span class="line"><span class="keyword">for</span> test <span class="keyword">in</span> (forLoop, listComp, mapCall, genExpr, genFunc):</span><br><span class="line">	elapsed , result = mytimer.timer(test)</span><br><span class="line">	print(<span class="string">'-'</span> * <span class="number">33</span>)</span><br><span class="line">	print(<span class="string">'%-9s: %.5f =&gt; [%s...%s]'</span> % (test.__name__, elapsed, result[<span class="number">0</span>], result[<span class="number">-1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">3.6.4 (v3.6.4:d48ecebad5, Dec 18 2017, 21:07:28) </span></span><br><span class="line"><span class="string">[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)]</span></span><br><span class="line"><span class="string">---------------------------------</span></span><br><span class="line"><span class="string">forLoop  : 1.93515 =&gt; [10...10009]</span></span><br><span class="line"><span class="string">---------------------------------</span></span><br><span class="line"><span class="string">listComp : 1.05818 =&gt; [10...10009]</span></span><br><span class="line"><span class="string">---------------------------------</span></span><br><span class="line"><span class="string">mapCall  : 1.97749 =&gt; [10...10009]</span></span><br><span class="line"><span class="string">---------------------------------</span></span><br><span class="line"><span class="string">genExpr  : 1.41341 =&gt; [10...10009]</span></span><br><span class="line"><span class="string">---------------------------------</span></span><br><span class="line"><span class="string">genFunc  : 1.44341 =&gt; [10...10009]</span></span><br><span class="line"><span class="string">[Finished in 8.3s]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>将<code>abs</code>换成真正的加法操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">3.6.4 (v3.6.4:d48ecebad5, Dec 18 2017, 21:07:28) </span><br><span class="line">[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)]</span><br><span class="line">---------------------------------</span><br><span class="line">forLoop  : 1.93515 =&gt; [10...10009]</span><br><span class="line">---------------------------------</span><br><span class="line">listComp : 1.05818 =&gt; [10...10009]</span><br><span class="line">---------------------------------</span><br><span class="line">mapCall  : 1.97749 =&gt; [10...10009]</span><br><span class="line">---------------------------------</span><br><span class="line">genExpr  : 1.41341 =&gt; [10...10009]</span><br><span class="line">---------------------------------</span><br><span class="line">genFunc  : 1.44341 =&gt; [10...10009]</span><br><span class="line">[Finished in 8.3s]</span><br></pre></td></tr></table></figure>

<p><code>map</code>调用一个用户定义的函数比<code>for</code>循环语句慢</p>
<p>列表解析运行最快</p>
<h3 id="计时模块替代方案"><a href="#计时模块替代方案" class="headerlink" title="计时模块替代方案"></a>计时模块替代方案</h3><p>计时模块的不足</p>
<blockquote>
<ul>
<li>使用<code>time.clock</code>调用计时代码在Windows上是最好的,但是<code>time.time</code>在某些UNIX平台上可能提供更好的解析</li>
<li>调整重复的次数需要修改模块级别的全局变量,如果要使用timer函数并且有多个导入者共享的话,这是不太理想的安排</li>
<li>计时器必须通过运行测试函数很多次才能工作,要考虑随机的系统载入的波动,在所有的测试中选择最好的时间,而不是总的时间,可能会更好</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File mytimer.py</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">timer(spam, 1, 2, a=3, b=4, _reps=1000) calls and times spam(1, 2, a=3) _reps times, and returns total time for all runs, with final result;</span></span><br><span class="line"><span class="string">best(spam, 1, 2, a=3, b=4, _reps=50) runs best-of-N timer to filter oyt any system load variation, and returns best time among _reps tests;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time, sys</span><br><span class="line"><span class="keyword">if</span> sys.platform[:<span class="number">3</span>] == <span class="string">'win'</span>:</span><br><span class="line">	timefunc = time.clock				<span class="comment"># Use time.clock on Windows</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	timefunc = time.time				<span class="comment"># Better resolution on some Unix platforms</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(*args)</span>:</span> <span class="keyword">pass</span>					<span class="comment"># Or:print args</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func, *pargs, **kargs)</span>:</span></span><br><span class="line">	_reps = kargs.pop(<span class="string">'_reps'</span>, <span class="number">1000</span>)	<span class="comment"># Passed-in or default reps</span></span><br><span class="line">	trace(func, pargs, kargs, _reps)</span><br><span class="line">	repslist = range(_reps)				<span class="comment"># Hoist range out for 2.6 lists</span></span><br><span class="line">	start = timefunc()</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> repslist:</span><br><span class="line">		ret = func(*pargs, **kargs)</span><br><span class="line">	elapsed = timefunc() - start</span><br><span class="line">	<span class="keyword">return</span> (elapsed, ret)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best</span><span class="params">(func, *pargs, **kargs)</span>:</span></span><br><span class="line">	_reps = kargs.pop(<span class="string">'_reps'</span>, <span class="number">50</span>)</span><br><span class="line">	best = <span class="number">2</span> ** <span class="number">32</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(_reps):</span><br><span class="line">		(time, ret) = timer(func, *pargs, _reps=<span class="number">1</span>, **kargs)</span><br><span class="line">		<span class="keyword">if</span> time &lt; best: best = time</span><br><span class="line">	<span class="keyword">return</span> (best, ret)</span><br></pre></td></tr></table></figure>

<p>文件顶部的文档字符串描述了模块的目标和用途</p>
<p>使用字典的<code>pop</code>操作从用于测试的参数中删除<code>_reps</code>参数并为其提供一个默认值</p>
<p><code>trace</code>函数修改为<code>print</code>可以在开发过程中分总参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, mytimer</span><br><span class="line">reps = <span class="number">10000</span></span><br><span class="line">repslist = range(reps)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forLoop</span><span class="params">()</span>:</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> repslist:</span><br><span class="line">		res.append(x + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listComp</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> [x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> repslist]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapCall</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> list(map(<span class="keyword">lambda</span> x: x + <span class="number">1</span>, repslist))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genExpr</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> list(x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> repslist)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genFunc</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> repslist:</span><br><span class="line">			<span class="keyword">yield</span> x + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> list(gen())</span><br><span class="line"></span><br><span class="line">print(sys.version)</span><br><span class="line"><span class="keyword">for</span> tester <span class="keyword">in</span> (mytimer.timer, mytimer.best):</span><br><span class="line">	print(<span class="string">'&lt;%s&gt;'</span> % tester.__name__)</span><br><span class="line">	<span class="keyword">for</span> test <span class="keyword">in</span> (forLoop, listComp, mapCall, genExpr, genFunc):</span><br><span class="line">		elapsed , result = tester(test)</span><br><span class="line">		print(<span class="string">'-'</span> * <span class="number">35</span>)</span><br><span class="line">		print(<span class="string">'%-9s: %.5f =&gt; [%s...%s]'</span> % (test.__name__, elapsed, result[<span class="number">0</span>], result[<span class="number">-1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">3.6.4 (v3.6.4:d48ecebad5, Dec 18 2017, 21:07:28) </span></span><br><span class="line"><span class="string">[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)]</span></span><br><span class="line"><span class="string">&lt;timer&gt;</span></span><br><span class="line"><span class="string">-----------------------------------</span></span><br><span class="line"><span class="string">forLoop  : 2.07234 =&gt; [1...10000]</span></span><br><span class="line"><span class="string">-----------------------------------</span></span><br><span class="line"><span class="string">listComp : 1.11021 =&gt; [1...10000]</span></span><br><span class="line"><span class="string">-----------------------------------</span></span><br><span class="line"><span class="string">mapCall  : 1.95846 =&gt; [1...10000]</span></span><br><span class="line"><span class="string">-----------------------------------</span></span><br><span class="line"><span class="string">genExpr  : 1.40802 =&gt; [1...10000]</span></span><br><span class="line"><span class="string">-----------------------------------</span></span><br><span class="line"><span class="string">genFunc  : 1.41008 =&gt; [1...10000]</span></span><br><span class="line"><span class="string">&lt;best&gt;</span></span><br><span class="line"><span class="string">-----------------------------------</span></span><br><span class="line"><span class="string">forLoop  : 0.00157 =&gt; [1...10000]</span></span><br><span class="line"><span class="string">-----------------------------------</span></span><br><span class="line"><span class="string">listComp : 0.00081 =&gt; [1...10000]</span></span><br><span class="line"><span class="string">-----------------------------------</span></span><br><span class="line"><span class="string">mapCall  : 0.00167 =&gt; [1...10000]</span></span><br><span class="line"><span class="string">-----------------------------------</span></span><br><span class="line"><span class="string">genExpr  : 0.00120 =&gt; [1...10000]</span></span><br><span class="line"><span class="string">-----------------------------------</span></span><br><span class="line"><span class="string">genFunc  : 0.00120 =&gt; [1...10000]</span></span><br><span class="line"><span class="string">[Finished in 8.6s]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>多次运行测试可以过滤掉系统载入波动</p>
<p>列表解析在大多数情况下表现很好,使用内置函数时<code>map</code>表现更好</p>
<h4 id="在Python-3-0中使用keyword-only参数"><a href="#在Python-3-0中使用keyword-only参数" class="headerlink" title="在Python 3.0中使用keyword-only参数"></a>在Python 3.0中使用keyword-only参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File mytimer.py(3.X only)</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Use 3.0 keyword-only default arguments, instead of ** and dict pops.</span></span><br><span class="line"><span class="string">No need to hoist range() out of test in 3.0:a generator, not a list</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time, sys</span><br><span class="line">trace = <span class="keyword">lambda</span> *rags: <span class="literal">None</span>	<span class="comment"># or print</span></span><br><span class="line">timefunc = time.clock <span class="keyword">if</span> sys.platform == <span class="string">'win32'</span> <span class="keyword">else</span> time.time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func, *pargs, _reps=<span class="number">1000</span>, **kargs)</span>:</span></span><br><span class="line">	trace(func, pargs, kargs, _reps)</span><br><span class="line">	start = timefunc()</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(_reps):</span><br><span class="line">		ret = func(*pargs, **kargs)</span><br><span class="line">	elapsed = timefunc() - start</span><br><span class="line">	<span class="keyword">return</span> (elapsed, ret)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best</span><span class="params">(func, *pargs, _reps=<span class="number">50</span>, **kargs)</span>:</span></span><br><span class="line">	best = <span class="number">2</span> ** <span class="number">32</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(_reps):</span><br><span class="line">		(time, ret) = timer(func, *pargs, _reps=<span class="number">1</span>, **kargs)</span><br><span class="line">		<span class="keyword">if</span> time &lt; best: best = time</span><br><span class="line">	<span class="keyword">return</span> (best, ret)</span><br></pre></td></tr></table></figure>

<p>使用<code>keyword-only</code>参数可以简化计时器模块代码</p>
<p>这个版本与前面的版本以同样的方式使用并产生相同的结果</p>
<h4 id="交互提示模式"><a href="#交互提示模式" class="headerlink" title="交互提示模式"></a>交互提示模式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> mytimer <span class="keyword">import</span> timer, best</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(X, Y)</span>:</span> <span class="keyword">return</span> X ** Y			<span class="comment"># Test function</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timer(power, <span class="number">2</span>, <span class="number">32</span>)						<span class="comment"># Total time,last result</span></span><br><span class="line">(<span class="number">0.0013279914855957031</span>, <span class="number">4294967296</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timer(power, <span class="number">2</span>, <span class="number">32</span>, _reps=<span class="number">1000000</span>)		<span class="comment"># Override default reps</span></span><br><span class="line">(<span class="number">0.6220171451568604</span>, <span class="number">4294967296</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timer(power, <span class="number">2</span>, <span class="number">100000</span>)[<span class="number">0</span>]				<span class="comment"># 2 ** 100,000 tot time @1,000 reps</span></span><br><span class="line"><span class="number">0.48587584495544434</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>best(power, <span class="number">2</span>, <span class="number">32</span>)						<span class="comment"># Best time, last result</span></span><br><span class="line">(<span class="number">1.6689300537109375e-06</span>, <span class="number">4294967296</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>best(power, <span class="number">2</span>, <span class="number">100000</span>)[<span class="number">0</span>]				<span class="comment"># 2 ** 100,000 best time</span></span><br><span class="line"><span class="number">0.0004100799560546875</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>best(power, <span class="number">2</span>, <span class="number">100000</span>, _reps=<span class="number">500</span>)[<span class="number">0</span>]	<span class="comment"># Override default reps</span></span><br><span class="line"><span class="number">0.00040984153747558594</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timer(power, <span class="number">2</span>, <span class="number">1000000</span>, _reps=<span class="number">1</span>)[<span class="number">0</span>]	<span class="comment"># 2 ** 1,000,000:total time</span></span><br><span class="line"><span class="number">0.01019287109375</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timer(power, <span class="number">2</span>, <span class="number">1000000</span>, _reps=<span class="number">10</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="number">0.06375718116760254</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>best(power, <span class="number">2</span>, <span class="number">1000000</span>, _reps=<span class="number">1</span>)[<span class="number">0</span>]		<span class="comment"># 2 ** 1,000,000:best time</span></span><br><span class="line"><span class="number">0.009803056716918945</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>best(power, <span class="number">2</span>, <span class="number">1000000</span>, _reps=<span class="number">10</span>)[<span class="number">0</span>]	<span class="comment"># 10 is sometimes as good as 50</span></span><br><span class="line"><span class="number">0.0054590702056884766</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>best(power, <span class="number">2</span>, <span class="number">1000000</span>, _reps=<span class="number">50</span>)[<span class="number">0</span>]	<span class="comment"># Best resolution</span></span><br><span class="line"><span class="number">0.005347728729248047</span></span><br></pre></td></tr></table></figure>

<p>可以从交互提示模式测试计时脚本</p>
<p>对于小函数,计时器的代码成本与被计时的函数一样显著,计时器可以帮助判断代码替代方案的相对速度而不应该绝对地取计时器结果</p>
<h3 id="其他建议"><a href="#其他建议" class="headerlink" title="其他建议"></a>其他建议</h3><p>Python标准库中<code>timeit</code>模块自动对代码计时,支持命令行使用模式,并且解决了一些特定于平台的问题</p>
<p>可以使用<code>str.format</code>方法代替<code>%</code>格式化表达式</p>
<hr>
<h2 id="函数陷阱"><a href="#函数陷阱" class="headerlink" title="函数陷阱"></a>函数陷阱</h2><h3 id="本地变量是静态检测的"><a href="#本地变量是静态检测的" class="headerlink" title="本地变量是静态检测的"></a>本地变量是静态检测的</h3><p>Python定义的在一个函数中进行分配的变量名默认为本地变量,存在于函数的作用域并值在函数运行时存在</p>
<p>Python是静态检测Python的本地变量的,通过在<code>def</code>语句运行时检测赋值语句判断是否为本地变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = <span class="number">99</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">selector</span><span class="params">()</span>:</span>		<span class="comment"># X used but not assigned</span></span><br><span class="line"><span class="meta">... </span>    print(X)		<span class="comment"># X found in global scope</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>selector()</span><br><span class="line"><span class="number">99</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">selector</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(X)		<span class="comment"># Does not yet exist!</span></span><br><span class="line"><span class="meta">... </span>    X = <span class="number">88</span>			<span class="comment"># X classified as a local name(everywhere)</span></span><br><span class="line"><span class="meta">... </span>					<span class="comment"># Can also happen for "import X","def X"...</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>selector()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> selector</span><br><span class="line">UnboundLocalError: local variable <span class="string">'X'</span> referenced before assignment</span><br></pre></td></tr></table></figure>

<p>没有在函数中赋值的变量名会在整个模块文件中查找</p>
<p>在函数编译时,Python检测到X的赋值语句,将X作为本地变量名,但是函数实际运行时还没被赋值就使用了,从而得到一个未定义变量名的错误</p>
<p>任何在函数体内的赋值都将会使其成为一个本地变量名,<code>import</code>、<code>=</code>、嵌套<code>def</code>、嵌套类等都会受到这种行为的影响</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">X = <span class="number">99</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">selector</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">global</span> X		<span class="comment"># Force X to be global(everywhere)</span></span><br><span class="line"><span class="meta">... </span>    print(X)</span><br><span class="line"><span class="meta">... </span>    X = <span class="number">88</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>selector()</span><br><span class="line"><span class="number">99</span></span><br><span class="line"></span><br><span class="line">X = <span class="number">99</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">selector</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">import</span> __main__</span><br><span class="line"><span class="meta">... </span>    print(__main__.X)</span><br><span class="line"><span class="meta">... </span>    X = <span class="number">88</span></span><br><span class="line"><span class="meta">... </span>    print(X)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>selector()</span><br><span class="line"><span class="number">88</span></span><br><span class="line"><span class="number">88</span></span><br></pre></td></tr></table></figure>

<p>使用<code>global</code>语句强制作为全局变量,在函数内的赋值同时会改变全局变量</p>
<p>为了使用相同变量名的本地变量,可以导入上层模块并使用模块的属性标记获得全局变量,<code>.</code>运算从命名空间对象中获取变量的值,交互模式下的命名空间为<code>__main__</code></p>
<h3 id="默认和可变对象"><a href="#默认和可变对象" class="headerlink" title="默认和可变对象"></a>默认和可变对象</h3><p>默认参数在<code>def</code>语句运行时而不是函数调用时评估并保存,Python将默认参数保存成一个对象,附加在函数本身</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">saver</span><span class="params">(x=[])</span>:</span>	<span class="comment"># Saces away a list object</span></span><br><span class="line"><span class="meta">... </span>    x.append(<span class="number">1</span>)		<span class="comment"># Changes same object each time!</span></span><br><span class="line"><span class="meta">... </span>    print(x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>saver([<span class="number">2</span>])			<span class="comment"># Default not used</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>saver()				<span class="comment"># Default used</span></span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>saver()				<span class="comment"># Grows on each call!</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>saver()</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>函数在调用之间保存了同一个默认参数的对象,这个对象是<code>def</code>语句执行时被创建的,修改可变的默认参数要十分小心</p>
<p>可变的默认参数工作起来像全局变量,但是变量名对于函数来说是本地变量而不会与程序中的其他变量名发生冲突</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">saver</span><span class="params">(x=None)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> x <span class="keyword">is</span> <span class="literal">None</span>:		<span class="comment"># None argument passed?</span></span><br><span class="line"><span class="meta">... </span>            x = []		<span class="comment"># Run code to make a new list</span></span><br><span class="line"><span class="meta">... </span>    x.append(<span class="number">1</span>)			<span class="comment"># Changes new list object</span></span><br><span class="line"><span class="meta">... </span>    print(x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>saver([<span class="number">2</span>])</span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>saver()					<span class="comment"># Doesn't grow here</span></span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>saver()</span><br><span class="line">[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>可以在函数主体的开始对默认参数进行简单的拷贝或者将默认参数值的表达式移至函数体内部</p>
<p><code>if</code>语句可以用<code>x = x or  []</code>代替,如果没有参数传入x将会默认为None,<code>or</code>返回右边的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">saver</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    saver.x.appen(<span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span>    print(saver.x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">saver</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    saver.x.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span>    print(saver.x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>saver.x = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>saver()</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>saver()</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>saver()</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>通过函数属性可以实现可变默认值</p>
<h3 id="没有return语句的函数"><a href="#没有return语句的函数" class="headerlink" title="没有return语句的函数"></a>没有return语句的函数</h3><p>在Python函数中,<code>return</code>语句是可选的,当没有返回值时函数在控制权从函数主体脱离时推出,函数返回<code>None</code>对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">proc</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(x)		<span class="comment"># No return is a None return</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = proc(<span class="string">'testing 123...'</span>)</span><br><span class="line">testing <span class="number">123.</span>..</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(x)</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = list.append(<span class="number">4</span>)	<span class="comment"># append is a "procedure"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list)				<span class="comment"># append changes list in-place</span></span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>赋值为一个没有返回值的函数时不会导致错误而是得到<code>None</code></p>
<h3 id="嵌套作用域的循环变量"><a href="#嵌套作用域的循环变量" class="headerlink" title="嵌套作用域的循环变量"></a>嵌套作用域的循环变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">makeActions</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    acts = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):						<span class="comment"># Tries to remember each i</span></span><br><span class="line"><span class="meta">... </span>            acts.append(<span class="keyword">lambda</span> x: i ** x)	<span class="comment"># All remember same last i</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> acts</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acts = makeActions()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acts[<span class="number">0</span>]</span><br><span class="line">&lt;function makeActions.&lt;locals&gt;.&lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x104205950</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acts[<span class="number">0</span>](<span class="number">2</span>)									<span class="comment"># All are 4 ** 2,value of last i</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acts[<span class="number">2</span>](<span class="number">2</span>)									<span class="comment"># This should be 2 ** 2</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acts[<span class="number">4</span>](<span class="number">2</span>)									<span class="comment"># This should be 4 ** 2</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">makeActions</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    acts = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):								<span class="comment"># Use defaults instead</span></span><br><span class="line"><span class="meta">... </span>            acts.append(<span class="keyword">lambda</span> x, i=i: i ** x)		<span class="comment"># Remember current i</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> acts</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acts = makeActions()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acts[<span class="number">0</span>](<span class="number">2</span>)											<span class="comment"># 0 ** 2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acts[<span class="number">2</span>](<span class="number">2</span>)											<span class="comment"># 2 ** 2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acts[<span class="number">4</span>](<span class="number">2</span>)											<span class="comment"># 4 ** 2</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>嵌套作用域中的变量在嵌套的函数被调用时才进行查找,所以它们实际上是最后一次循环迭代中循环变量的值</p>
<p>因为默认参数是在嵌套函数创建时评估的,必须使用默认参数把当前的值传递给嵌套作用域的变量,每一个函数记住自己的变量的值</p>
<hr>
<h2 id="本章习题-4"><a href="#本章习题-4" class="headerlink" title="本章习题"></a>本章习题</h2><ol>
<li><p>列表解析放在方括号和圆括号中有什么区别</p>
<blockquote>
<p><code>[]</code>的列表解析会一次在内存中产生结果列表<br><code>()</code>实际上是生成器表达式:不会一次产生结果列表,而是会返回一个生成器对象,用在迭代环境中时,一次产生结果中的一个元素</p>
</blockquote>
</li>
<li><p>生成器和迭代器有什么关系</p>
<blockquote>
<p>生成器是支持迭代协议的对象:它们有<code>__ next__</code> 方法,重复前进到系列结果中的下个元素,以及到系列尾端时引发异常</p>
<p>在Python中,我们可以用<code>def</code>、加<code>()</code>的列表解析的生成器表达式以及以类定义特殊方法<code>__ iter__</code>来创建生成器对象,通过它们来编写生成器函数</p>
</blockquote>
</li>
<li><p>如何分辨函数是否为生成器函数</p>
<blockquote>
<p>生成器函数在其代码中的某处会有一个<code>yield</code>语句<br>除此之外,生成器函数和普通函数语法上相同,但是,它们由Python特别编译,以便在调用的时候返回一个可迭代的对象</p>
</blockquote>
</li>
<li><p>yield语句是做什么的</p>
<blockquote>
<p>当有了<code>yield</code>语句时,这个语句会让Python把函数特定的编译成生成器;当调用时,会返回生成器对象,支持迭代协议</p>
<p>当<code>yield</code>语句运行时,会把结果返回给调用者,让函数的状态挂起，当调用者再调用<code>__next__</code>方法时,这个函数就可以重新在上次<code>yield</code>语句后继续运行</p>
<p>生成器也可以有<code>return</code>语句,用来终止生成器</p>
</blockquote>
</li>
<li><p>map调用和列表解析有什么关系?比较并对比两者</p>
<blockquote>
<p><code>map</code>调用类似于列表解析,两者都会收集对序列或其他可迭代对象中每个元素应用运算后的结果(一次一个项目),从而创建新列表</p>
<p>其主要差异在于,map会对每个元素应用函数,而列表解析则是应用任意的表达式,<code>map</code>需要一个<code>lambda</code>函数才能应用其他种类的表达式,因此列表解析更通用一些</p>
<p>列表解析也支持扩展语法,例如,嵌套<code>for</code>循环和<code>if</code>分句从而可以包含内置函数<code>filter</code>的功能</p>
</blockquote>
</li>
</ol>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="http://abcdefghijklmnopqrst.xyz">骑麦兜看落日</a>
            <p>原文链接：<a href="http://abcdefghijklmnopqrst.xyz/2018/08/05/Code_Python学习手册_4/">http://abcdefghijklmnopqrst.xyz/2018/08/05/Code_Python学习手册_4/</a>
            <p>发表日期：<a href="http://abcdefghijklmnopqrst.xyz/2018/08/05/Code_Python学习手册_4/">August 5th 2018, 9:00:00 am</a>
            <p>更新日期：<a href="http://abcdefghijklmnopqrst.xyz/2018/08/05/Code_Python学习手册_4/">August 5th 2018, 9:00:00 am</a>
            <p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2018/08/10/Code_Python学习手册_5/" title= "[Code]Python学习手册_第五部分_模块">
                    <div class="nextTitle">[Code]Python学习手册_第五部分_模块</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2018/08/05/Binary_Heap/" title= "[Binary]Heap">
                    <div class="prevTitle">[Binary]Heap</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

    <div id="lv-container" data-id="city" data-uid= MTAyMC8zNzY1OS8xNDE5MA==>
        <script type="text/javascript">
            (function (d, s) {
                var j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') { return; }
                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:qimaidoukanluori@gmail.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/qimaidoukanluori" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">到访的小伙伴: <span id="busuanzi_value_site_pv"></span>只 </span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:30vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第十六章-函数基础"><span class="toc-number">1.</span> <span class="toc-text">第十六章_函数基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#为何使用函数"><span class="toc-number">1.1.</span> <span class="toc-text">为何使用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编写函数"><span class="toc-number">1.2.</span> <span class="toc-text">编写函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#def语句"><span class="toc-number">1.2.1.</span> <span class="toc-text">def语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#def语句是实时执行的"><span class="toc-number">1.2.2.</span> <span class="toc-text">def语句是实时执行的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第一个例子-定义和调用"><span class="toc-number">1.3.</span> <span class="toc-text">第一个例子:定义和调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义"><span class="toc-number">1.3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用"><span class="toc-number">1.3.2.</span> <span class="toc-text">调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python中的多态"><span class="toc-number">1.3.3.</span> <span class="toc-text">Python中的多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二个例子-寻找序列的交集"><span class="toc-number">1.4.</span> <span class="toc-text">第二个例子:寻找序列的交集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重访多态"><span class="toc-number">1.4.3.</span> <span class="toc-text">重访多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#本地变量"><span class="toc-number">1.4.4.</span> <span class="toc-text">本地变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章习题"><span class="toc-number">1.5.</span> <span class="toc-text">本章习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十七章-作用域"><span class="toc-number">2.</span> <span class="toc-text">第十七章 作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python作用域基础"><span class="toc-number">2.1.</span> <span class="toc-text">Python作用域基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域法则"><span class="toc-number">2.1.1.</span> <span class="toc-text">作用域法则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量名解析-LEGB原则"><span class="toc-number">2.1.2.</span> <span class="toc-text">变量名解析:LEGB原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域实例"><span class="toc-number">2.1.3.</span> <span class="toc-text">作用域实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内置作用域"><span class="toc-number">2.1.4.</span> <span class="toc-text">内置作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在Python-2-6中违反通用性"><span class="toc-number">2.1.5.</span> <span class="toc-text">在Python 2.6中违反通用性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#global语句"><span class="toc-number">2.2.</span> <span class="toc-text">global语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#最小化全局变量"><span class="toc-number">2.2.1.</span> <span class="toc-text">最小化全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小化文件间的修改"><span class="toc-number">2.2.2.</span> <span class="toc-text">最小化文件间的修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他访问全局变量的方法"><span class="toc-number">2.2.3.</span> <span class="toc-text">其他访问全局变量的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作用域和嵌套函数"><span class="toc-number">2.3.</span> <span class="toc-text">作用域和嵌套函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套作用域的细节"><span class="toc-number">2.3.1.</span> <span class="toc-text">嵌套作用域的细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套作用域举例"><span class="toc-number">2.3.2.</span> <span class="toc-text">嵌套作用域举例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#工厂函数"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">工厂函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用默认参数来保留嵌套作用域的状态"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">使用默认参数来保留嵌套作用域的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#嵌套作用域和lambda"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">嵌套作用域和lambda</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#作用域与带有循环变量的默认参数相比较"><span class="toc-number">2.3.2.4.</span> <span class="toc-text">作用域与带有循环变量的默认参数相比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#任意作用域的嵌套"><span class="toc-number">2.3.2.5.</span> <span class="toc-text">任意作用域的嵌套</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nonlocal语句"><span class="toc-number">2.4.</span> <span class="toc-text">nonlocal语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nonlocal基础"><span class="toc-number">2.4.1.</span> <span class="toc-text">nonlocal基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nonlocal应用"><span class="toc-number">2.4.2.</span> <span class="toc-text">nonlocal应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用nonlocal进行修改"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">使用nonlocal进行修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#边界情况"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">边界情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么使用nonlocal"><span class="toc-number">2.4.3.</span> <span class="toc-text">为什么使用nonlocal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#与全局共享状态"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">与全局共享状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用类的状态-预览"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">使用类的状态(预览)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用函数属性的状态"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">使用函数属性的状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章习题-1"><span class="toc-number">2.5.</span> <span class="toc-text">本章习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十八章-参数"><span class="toc-number">3.</span> <span class="toc-text">第十八章 参数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#传递参数"><span class="toc-number">3.1.</span> <span class="toc-text">传递参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#参数和共享引用"><span class="toc-number">3.1.1.</span> <span class="toc-text">参数和共享引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#避免可变参数的修改"><span class="toc-number">3.1.2.</span> <span class="toc-text">避免可变参数的修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对参数输出进行模拟"><span class="toc-number">3.1.3.</span> <span class="toc-text">对参数输出进行模拟</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特定的参数匹配模型"><span class="toc-number">3.2.</span> <span class="toc-text">特定的参数匹配模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基础知识"><span class="toc-number">3.2.1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匹配语法"><span class="toc-number">3.2.2.</span> <span class="toc-text">匹配语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#细节"><span class="toc-number">3.2.3.</span> <span class="toc-text">细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关键字参数和默认参数的实例"><span class="toc-number">3.2.4.</span> <span class="toc-text">关键字参数和默认参数的实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关键字参数"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">关键字参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#默认参数"><span class="toc-number">3.2.4.2.</span> <span class="toc-text">默认参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关键字参数和默认参数的混合"><span class="toc-number">3.2.4.3.</span> <span class="toc-text">关键字参数和默认参数的混合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#任意参数的实例"><span class="toc-number">3.2.5.</span> <span class="toc-text">任意参数的实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#收集参数"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">收集参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解包参数"><span class="toc-number">3.2.5.2.</span> <span class="toc-text">解包参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#应用函数通用性"><span class="toc-number">3.2.5.3.</span> <span class="toc-text">应用函数通用性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#废弃的apply内置函数-Python-2-6"><span class="toc-number">3.2.5.4.</span> <span class="toc-text">废弃的apply内置函数(Python 2.6)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-3-0-keyword-Only参数"><span class="toc-number">3.2.6.</span> <span class="toc-text">Python 3.0 keyword-Only参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#排序规则"><span class="toc-number">3.2.6.1.</span> <span class="toc-text">排序规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为何使用keyword-only参数"><span class="toc-number">3.2.6.2.</span> <span class="toc-text">为何使用keyword-only参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#min调用"><span class="toc-number">3.2.7.</span> <span class="toc-text">min调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#满分"><span class="toc-number">3.2.7.1.</span> <span class="toc-text">满分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加分点"><span class="toc-number">3.2.7.2.</span> <span class="toc-text">加分点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结论"><span class="toc-number">3.2.7.3.</span> <span class="toc-text">结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一个更有用的例子-通用set函数"><span class="toc-number">3.3.</span> <span class="toc-text">一个更有用的例子:通用set函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟Python-3-0-print函数"><span class="toc-number">3.4.</span> <span class="toc-text">模拟Python 3.0 print函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Keyword-Only参数"><span class="toc-number">3.4.1.</span> <span class="toc-text">使用Keyword-Only参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要在意-关键字参数"><span class="toc-number">3.4.2.</span> <span class="toc-text">为什么要在意:关键字参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章习题-2"><span class="toc-number">3.5.</span> <span class="toc-text">本章习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十九章-函数的高级话题"><span class="toc-number">4.</span> <span class="toc-text">第十九章 函数的高级话题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数设计概念"><span class="toc-number">4.1.</span> <span class="toc-text">函数设计概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归函数"><span class="toc-number">4.2.</span> <span class="toc-text">递归函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用递归求和"><span class="toc-number">4.2.1.</span> <span class="toc-text">用递归求和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编码替代方案"><span class="toc-number">4.2.2.</span> <span class="toc-text">编码替代方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环语句VS递归"><span class="toc-number">4.2.3.</span> <span class="toc-text">循环语句VS递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理任意结构"><span class="toc-number">4.2.4.</span> <span class="toc-text">处理任意结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数对象-属性和注解"><span class="toc-number">4.3.</span> <span class="toc-text">函数对象:属性和注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#间接函数调用"><span class="toc-number">4.3.1.</span> <span class="toc-text">间接函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数内省"><span class="toc-number">4.3.2.</span> <span class="toc-text">函数内省</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数属性"><span class="toc-number">4.3.3.</span> <span class="toc-text">函数属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-3-0中的函数注解"><span class="toc-number">4.3.4.</span> <span class="toc-text">Python 3.0中的函数注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#匿名函数-lambda"><span class="toc-number">4.4.</span> <span class="toc-text">匿名函数:lambda</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda表达式"><span class="toc-number">4.4.1.</span> <span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么使用lambda"><span class="toc-number">4.4.2.</span> <span class="toc-text">为什么使用lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何-不要-让Python代码变得晦涩难懂"><span class="toc-number">4.4.3.</span> <span class="toc-text">如何(不要)让Python代码变得晦涩难懂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套lambda和作用域"><span class="toc-number">4.4.4.</span> <span class="toc-text">嵌套lambda和作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要在意-回调"><span class="toc-number">4.4.5.</span> <span class="toc-text">为什么要在意:回调</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在序列中映射函数-map"><span class="toc-number">4.5.</span> <span class="toc-text">在序列中映射函数:map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数式编程工具-filter和reduce"><span class="toc-number">4.6.</span> <span class="toc-text">函数式编程工具:filter和reduce</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章习题-3"><span class="toc-number">4.7.</span> <span class="toc-text">本章习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二十章-迭代和解析-第二部分"><span class="toc-number">5.</span> <span class="toc-text">第二十章 迭代和解析,第二部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#回顾列表解析-函数式编程工具"><span class="toc-number">5.1.</span> <span class="toc-text">回顾列表解析:函数式编程工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#列表解析与map"><span class="toc-number">5.1.1.</span> <span class="toc-text">列表解析与map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增加测试和嵌套循环"><span class="toc-number">5.1.2.</span> <span class="toc-text">增加测试和嵌套循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#列表解析和矩阵"><span class="toc-number">5.1.3.</span> <span class="toc-text">列表解析和矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理解列表解析"><span class="toc-number">5.1.4.</span> <span class="toc-text">理解列表解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要在意-列表解析和map"><span class="toc-number">5.1.5.</span> <span class="toc-text">为什么要在意:列表解析和map</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重访迭代器-生成器"><span class="toc-number">5.2.</span> <span class="toc-text">重访迭代器:生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生成器函数-yield-VS-return"><span class="toc-number">5.2.1.</span> <span class="toc-text">生成器函数:yield VS return</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#状态挂起"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">状态挂起</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代协议整合"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">迭代协议整合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生成器函数应用"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">生成器函数应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#拓展生成器函数协议-send和next"><span class="toc-number">5.2.1.4.</span> <span class="toc-text">拓展生成器函数协议:send和next</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成器表达式-迭代器遇到列表解析"><span class="toc-number">5.2.2.</span> <span class="toc-text">生成器表达式:迭代器遇到列表解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成器函数-VS-生成器表达式"><span class="toc-number">5.2.3.</span> <span class="toc-text">生成器函数 VS 生成器表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成器是单迭代器对象"><span class="toc-number">5.2.4.</span> <span class="toc-text">生成器是单迭代器对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用迭代工具模拟zip和map"><span class="toc-number">5.2.5.</span> <span class="toc-text">用迭代工具模拟zip和map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#编写自己的map-func-…"><span class="toc-number">5.2.5.1.</span> <span class="toc-text">编写自己的map(func,…)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编写自己的zip-…-和map-None-…"><span class="toc-number">5.2.5.2.</span> <span class="toc-text">编写自己的zip(…)和map(None,…)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么你会留意-单次迭代"><span class="toc-number">5.2.6.</span> <span class="toc-text">为什么你会留意:单次迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内置类型和类中的值生成"><span class="toc-number">5.2.7.</span> <span class="toc-text">内置类型和类中的值生成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-3-0解析语法概况"><span class="toc-number">5.3.</span> <span class="toc-text">Python 3.0解析语法概况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解析集合和字典解析"><span class="toc-number">5.3.1.</span> <span class="toc-text">解析集合和字典解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#针对集合和字典的拓展的解析语法"><span class="toc-number">5.3.2.</span> <span class="toc-text">针对集合和字典的拓展的解析语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对迭代的各种方法进行计时"><span class="toc-number">5.4.</span> <span class="toc-text">对迭代的各种方法进行计时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对模块计时"><span class="toc-number">5.4.1.</span> <span class="toc-text">对模块计时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计时脚本"><span class="toc-number">5.4.2.</span> <span class="toc-text">计时脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计时结果"><span class="toc-number">5.4.3.</span> <span class="toc-text">计时结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计时模块替代方案"><span class="toc-number">5.4.4.</span> <span class="toc-text">计时模块替代方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#在Python-3-0中使用keyword-only参数"><span class="toc-number">5.4.4.1.</span> <span class="toc-text">在Python 3.0中使用keyword-only参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#交互提示模式"><span class="toc-number">5.4.4.2.</span> <span class="toc-text">交互提示模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他建议"><span class="toc-number">5.4.5.</span> <span class="toc-text">其他建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数陷阱"><span class="toc-number">5.5.</span> <span class="toc-text">函数陷阱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#本地变量是静态检测的"><span class="toc-number">5.5.1.</span> <span class="toc-text">本地变量是静态检测的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#默认和可变对象"><span class="toc-number">5.5.2.</span> <span class="toc-text">默认和可变对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#没有return语句的函数"><span class="toc-number">5.5.3.</span> <span class="toc-text">没有return语句的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套作用域的循环变量"><span class="toc-number">5.5.4.</span> <span class="toc-text">嵌套作用域的循环变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章习题-4"><span class="toc-number">5.6.</span> <span class="toc-text">本章习题</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 48
        </div>
        <!-- search  -->
        
            <div class="site-search popup-trigger">
                <span class="iconfont-archer search-icon">&#xe627;</span>
            </div>
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2019/09/10/WP_2019ByteCTF/" >[WriteUp]2019ByteCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/26</span><a class="archive-post-title" href= "/2019/08/26/WP_2019OGeek/" >[WriteUp]2019OGeek</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/31</span><a class="archive-post-title" href= "/2019/07/31/WP_2019CISCN final/" >[WriteUp]2019CISCN final</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/07</span><a class="archive-post-title" href= "/2019/07/07/WP_2019WCTF/" >[WriteUp]2019WCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/02</span><a class="archive-post-title" href= "/2019/07/02/Asm_WASM格式化字符串攻击尝试/" >[Asm]WASM格式化字符串攻击尝试</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/22</span><a class="archive-post-title" href= "/2019/01/22/Code_Python可变类型的一些问题/" >[Code]Python可变类型的一些问题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/13</span><a class="archive-post-title" href= "/2019/01/13/Asm_WASM初步/" >[Asm]WASM初步</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/20</span><a class="archive-post-title" href= "/2018/12/20/Binary_通过a的leak/" >[Binary]通过%a的leak</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/07</span><a class="archive-post-title" href= "/2018/12/07/WP_hxpCTF/" >[WriteUp]hxpCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/27</span><a class="archive-post-title" href= "/2018/11/27/WP_2018BCTF/" >[WriteUp]2018BCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/14</span><a class="archive-post-title" href= "/2018/11/14/Binary_IO_FILE源码分析/" >[Binary]IO_FILE</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/05</span><a class="archive-post-title" href= "/2018/11/05/Binary_ArmPwn/" >[Asm]ARMPwn</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/04</span><a class="archive-post-title" href= "/2018/11/04/WP_上海杯/" >[WriteUp]上海杯</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/27</span><a class="archive-post-title" href= "/2018/10/27/WP_HCTF/" >[WriteUp]HCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/27</span><a class="archive-post-title" href= "/2018/10/27/WP_湖湘杯/" >[WriteUp]湖湘杯</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/27</span><a class="archive-post-title" href= "/2018/10/27/WP_SECCONCTF/" >[WriteUp]SECCONCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href= "/2018/10/24/Binary_Tcache/" >[Binary]Tcache</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/17</span><a class="archive-post-title" href= "/2018/10/17/Asm_RealmodeAsm/" >[Asm]RealmodeAsm</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/13</span><a class="archive-post-title" href= "/2018/10/13/WP_2018护网杯/" >[WriteUp]护网杯</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/06</span><a class="archive-post-title" href= "/2018/10/06/Binary_IDADynamic/" >[Binary]IDADynamic</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2018/10/05/Linux_pwn环境搭建/" >[Linux]pwn环境搭建</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2018/10/05/WP_DragonCTF/" >[WriteUp]DefCampCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2018/10/05/WP_InCTF/" >[WriteUp]InCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span><a class="archive-post-title" href= "/2018/09/28/Binary_PDF/" >[Binary]PDF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/27</span><a class="archive-post-title" href= "/2018/09/27/Linux_GDB的python调试/" >[Linux]GDB的Python调试</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/27</span><a class="archive-post-title" href= "/2018/09/27/Linux_GDB/" >[Linux]GDB</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/25</span><a class="archive-post-title" href= "/2018/09/25/WP_DefCampCTF/" >[WriteUp]DefCampCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/18</span><a class="archive-post-title" href= "/2018/09/18/Android_JNI/" >[Android]JNI</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/18</span><a class="archive-post-title" href= "/2018/09/18/BInary_HeapExploit/" >[Binary]HeapExploit</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/13</span><a class="archive-post-title" href= "/2018/09/13/Binary_IO_FILE/" >[Binary]IO_FILE</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2018/09/10/Linux_GDB的源码调试/" >[Linux]GDB源码调试</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/01</span><a class="archive-post-title" href= "/2018/09/01/Binary_ptmalloc源码分析/" >[Binary]ptmalloc源码分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/25</span><a class="archive-post-title" href= "/2018/08/25/WP_pwnable.tw/" >[WriteUp]pwnable.tw</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/21</span><a class="archive-post-title" href= "/2018/08/21/Code_Python学习手册_7/" >[Code]Python学习手册_第七部分_异常和工具</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/21</span><a class="archive-post-title" href= "/2018/08/21/WP_网鼎杯/" >[WriteUp]网鼎杯</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/14</span><a class="archive-post-title" href= "/2018/08/14/Code_Python学习手册_6/" >[Code]Python学习手册_第六部分_类和OOP</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/13</span><a class="archive-post-title" href= "/2018/08/13/WP_JarvisOJ/" >[WriteUp]JarvisOJ</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/10</span><a class="archive-post-title" href= "/2018/08/10/Code_Python学习手册_5/" >[Code]Python学习手册_第五部分_模块</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/05</span><a class="archive-post-title" href= "/2018/08/05/Code_Python学习手册_4/" >[Code]Python学习手册_第四部分_函数</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/05</span><a class="archive-post-title" href= "/2018/08/05/Binary_Heap/" >[Binary]Heap</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/30</span><a class="archive-post-title" href= "/2018/07/30/Linux_INT80/" >[Linux]int 80</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/30</span><a class="archive-post-title" href= "/2018/07/30/Code_Python学习手册_3/" >[Code]Python学习手册_第三部分_语句和语法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/25</span><a class="archive-post-title" href= "/2018/07/25/Binary_Canary/" >[Binary]Canary</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/24</span><a class="archive-post-title" href= "/2018/07/24/Code_Python学习手册_2/" >[Code]Python学习手册_第二部分_类型和运算</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/22</span><a class="archive-post-title" href= "/2018/07/22/Binary_fmt/" >[Binary]FormatString</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/21</span><a class="archive-post-title" href= "/2018/07/21/Code_Python学习手册_1/" >[Code]Python学习手册_第一部分_使用入门</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/21</span><a class="archive-post-title" href= "/2018/07/21/WP_巅峰极客/" >[WriteUp]巅峰极客</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/22</span><a class="archive-post-title" href= "/2018/01/22/Code_Python的C拓展/" >[Code]Python的C拓展</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="Note"><span class="iconfont-archer">&#xe606;</span>Note</span>
    
        <span class="sidebar-tag-name" data-tags="Assembly"><span class="iconfont-archer">&#xe606;</span>Assembly</span>
    
        <span class="sidebar-tag-name" data-tags="WASM"><span class="iconfont-archer">&#xe606;</span>WASM</span>
    
        <span class="sidebar-tag-name" data-tags="Binary"><span class="iconfont-archer">&#xe606;</span>Binary</span>
    
        <span class="sidebar-tag-name" data-tags="Pwn"><span class="iconfont-archer">&#xe606;</span>Pwn</span>
    
        <span class="sidebar-tag-name" data-tags="Canary"><span class="iconfont-archer">&#xe606;</span>Canary</span>
    
        <span class="sidebar-tag-name" data-tags="Heap"><span class="iconfont-archer">&#xe606;</span>Heap</span>
    
        <span class="sidebar-tag-name" data-tags="IDA"><span class="iconfont-archer">&#xe606;</span>IDA</span>
    
        <span class="sidebar-tag-name" data-tags="Linux"><span class="iconfont-archer">&#xe606;</span>Linux</span>
    
        <span class="sidebar-tag-name" data-tags="Asm"><span class="iconfont-archer">&#xe606;</span>Asm</span>
    
        <span class="sidebar-tag-name" data-tags="Android"><span class="iconfont-archer">&#xe606;</span>Android</span>
    
        <span class="sidebar-tag-name" data-tags="PDF"><span class="iconfont-archer">&#xe606;</span>PDF</span>
    
        <span class="sidebar-tag-name" data-tags="Tcache"><span class="iconfont-archer">&#xe606;</span>Tcache</span>
    
        <span class="sidebar-tag-name" data-tags="Code"><span class="iconfont-archer">&#xe606;</span>Code</span>
    
        <span class="sidebar-tag-name" data-tags="Python"><span class="iconfont-archer">&#xe606;</span>Python</span>
    
        <span class="sidebar-tag-name" data-tags="GDB"><span class="iconfont-archer">&#xe606;</span>GDB</span>
    
        <span class="sidebar-tag-name" data-tags="Gdb"><span class="iconfont-archer">&#xe606;</span>Gdb</span>
    
        <span class="sidebar-tag-name" data-tags="Pwntools"><span class="iconfont-archer">&#xe606;</span>Pwntools</span>
    
        <span class="sidebar-tag-name" data-tags="Qemu"><span class="iconfont-archer">&#xe606;</span>Qemu</span>
    
        <span class="sidebar-tag-name" data-tags="CTF"><span class="iconfont-archer">&#xe606;</span>CTF</span>
    
        <span class="sidebar-tag-name" data-tags="WriteUp"><span class="iconfont-archer">&#xe606;</span>WriteUp</span>
    
        <span class="sidebar-tag-name" data-tags="Re"><span class="iconfont-archer">&#xe606;</span>Re</span>
    
        <span class="sidebar-tag-name" data-tags="CTFtime"><span class="iconfont-archer">&#xe606;</span>CTFtime</span>
    
        <span class="sidebar-tag-name" data-tags="IO_FILE"><span class="iconfont-archer">&#xe606;</span>IO_FILE</span>
    
        <span class="sidebar-tag-name" data-tags="Arm"><span class="iconfont-archer">&#xe606;</span>Arm</span>
    
        <span class="sidebar-tag-name" data-tags="Cpp"><span class="iconfont-archer">&#xe606;</span>Cpp</span>
    
        <span class="sidebar-tag-name" data-tags="StackOverflow"><span class="iconfont-archer">&#xe606;</span>StackOverflow</span>
    
        <span class="sidebar-tag-name" data-tags="Java"><span class="iconfont-archer">&#xe606;</span>Java</span>
    
        <span class="sidebar-tag-name" data-tags="JNI"><span class="iconfont-archer">&#xe606;</span>JNI</span>
    
        <span class="sidebar-tag-name" data-tags="Fmt"><span class="iconfont-archer">&#xe606;</span>Fmt</span>
    
        <span class="sidebar-tag-name" data-tags="IntegerOverflow"><span class="iconfont-archer">&#xe606;</span>IntegerOverflow</span>
    
        <span class="sidebar-tag-name" data-tags="Cfunc"><span class="iconfont-archer">&#xe606;</span>Cfunc</span>
    
        <span class="sidebar-tag-name" data-tags="HouseOfRoman"><span class="iconfont-archer">&#xe606;</span>HouseOfRoman</span>
    
        <span class="sidebar-tag-name" data-tags="ShellCode"><span class="iconfont-archer">&#xe606;</span>ShellCode</span>
    
        <span class="sidebar-tag-name" data-tags="FastbinAttack"><span class="iconfont-archer">&#xe606;</span>FastbinAttack</span>
    
        <span class="sidebar-tag-name" data-tags="HeapOverflow"><span class="iconfont-archer">&#xe606;</span>HeapOverflow</span>
    
        <span class="sidebar-tag-name" data-tags="StackOvrtflow"><span class="iconfont-archer">&#xe606;</span>StackOvrtflow</span>
    
        <span class="sidebar-tag-name" data-tags="wargame"><span class="iconfont-archer">&#xe606;</span>wargame</span>
    
        <span class="sidebar-tag-name" data-tags="SystemCall"><span class="iconfont-archer">&#xe606;</span>SystemCall</span>
    
        <span class="sidebar-tag-name" data-tags="XCTF"><span class="iconfont-archer">&#xe606;</span>XCTF</span>
    
        <span class="sidebar-tag-name" data-tags="Fastbin"><span class="iconfont-archer">&#xe606;</span>Fastbin</span>
    
        <span class="sidebar-tag-name" data-tags="FormatString"><span class="iconfont-archer">&#xe606;</span>FormatString</span>
    
        <span class="sidebar-tag-name" data-tags="prctl"><span class="iconfont-archer">&#xe606;</span>prctl</span>
    
        <span class="sidebar-tag-name" data-tags="global_max_fast"><span class="iconfont-archer">&#xe606;</span>global_max_fast</span>
    
        <span class="sidebar-tag-name" data-tags="read"><span class="iconfont-archer">&#xe606;</span>read</span>
    
        <span class="sidebar-tag-name" data-tags="UAF"><span class="iconfont-archer">&#xe606;</span>UAF</span>
    
        <span class="sidebar-tag-name" data-tags="OJ"><span class="iconfont-archer">&#xe606;</span>OJ</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="Assembly"><span class="iconfont-archer">&#xe60a;</span>Assembly</span>
    
        <span class="sidebar-category-name" data-categories="Binary"><span class="iconfont-archer">&#xe60a;</span>Binary</span>
    
        <span class="sidebar-category-name" data-categories="Code"><span class="iconfont-archer">&#xe60a;</span>Code</span>
    
        <span class="sidebar-category-name" data-categories="Linux"><span class="iconfont-archer">&#xe60a;</span>Linux</span>
    
        <span class="sidebar-category-name" data-categories="WriteUp"><span class="iconfont-archer">&#xe60a;</span>WriteUp</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "骑麦兜看落日"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
        <div class="site-search">
  <div class="algolia-popup popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="iconfont-archer">&#xe609;</i>
    </span>
  </div>
</div>
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.8.0/dist/instantsearch.min.js" defer></script>
        <script src="/scripts/search.js" defer></script>
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


