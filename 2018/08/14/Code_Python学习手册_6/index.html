<!DOCTYPE html>
<html lang="">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="骑麦兜看落日">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="骑麦兜看落日">
    
    <meta name="keywords" content="骑麦兜看落日,骑麦兜看落日">
    
    <meta name="description" content>
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>[Code]Python学习手册_第六部分_类和OOP · 骑麦兜看落日&#39;s Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
        <!-- algolia -->
        <script>
            
            var hits = JSON.parse('{"per_page":10}')
            var labels = JSON.parse('{"input_placeholder":"Search for Posts","hits_empty":"We did not find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}')

            var algolia = {
                applicationID: '5D5KDIMZEQ',
                apiKey: 'b4ec67c101aa9269e65e640e2e469343',
                indexName: 'my_index',
                hits: hits,
                labels: labels
            }
        </script>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >骑麦兜看落日</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">[Code]Python学习手册_第六部分_类和OOP</a>
            </div>
    </div>
    
    <a class="home-link" href=/>骑麦兜看落日</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:30vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            [Code]Python学习手册_第六部分_类和OOP
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "Note">Note</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "Code">Code</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "Python">Python</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">32k</span>阅读时长: <span class="post-count reading-time">133 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2018/08/14</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="第二十五章-OOP-宏伟蓝图"><a href="#第二十五章-OOP-宏伟蓝图" class="headerlink" title="第二十五章 OOP:宏伟蓝图"></a>第二十五章 OOP:宏伟蓝图</h1><blockquote>
<ul>
<li>本章对类和OOP进行了抽象的学习</li>
</ul>
</blockquote>
<p>要让代码真正归类于面向对象(00)，那么对象一般也需要参与到所谓的继承层次中。</p>
<p>本章要开始我们对Python类的探索:类是在Python实现支持继承的新种类的对象的部件。类是Python面向对象程序设计(OOP)的主要工具，而本书这一-部分内容中，我们将会一直讨论OOP的基础内容。OOP提供了一种不同寻常而往往更有效的检查程序的方式，利用这种设计方法，我们分解代码，把代码的冗余度降至最低，并且通过定制现有的代码来编写新的程序，而不是在原处进行修改。</p>
<p>在Python中，类的建立使用了一条新的语句: class语句。正如你将看到的那样，通过class定义的对象，看起来很像本书之前研究过的内置类型。事实上，类其实是只运用并扩展了我们谈到过的一些想法。概括地讲，类就是一些函数的包，这些函数大量使用并处理内置对象类型。不过，类的设计是为了创建和管理新的对象，并且它们也支持继承。</p>
<p>然而，阅读本书这一.部分你会得知，类是Python所提供的最有用的工具之一。合理使<br>用时，类实际，上可以大量减少开发的时间</p>
<hr>
<h2 id="为何使用类"><a href="#为何使用类" class="headerlink" title="为何使用类"></a>为何使用类</h2><p>类是一种定义新种类的东西的方式,反映了在程序领域中的真实对象</p>
<p>通过类可以建立实际结构和关系的模型</p>
<blockquote>
<ul>
<li><p>继承</p>
<p>一种代码定制和复用的机制</p>
<p>类可以继承其他拥有通用属性的类</p>
</li>
<li><p>组合</p>
<p>类是一些组件的集合,这些组件以团队的形式共同工作</p>
<p>每个组件都可以写成类,定义自己的行为以及关系</p>
<p>类是一个组合的实例,它包含其他对象,这些对象来运作完成相应的指令</p>
</li>
</ul>
</blockquote>
<p>继承和组合等一般性OOP概念适用于能够分解成一组对象的任何应用程序</p>
<p>类与函数和模块一样是Python的程序组成单元,类是封装逻辑和数据的另一种方式,类会定义新的命名空间</p>
<blockquote>
<ul>
<li><p>多重实例</p>
<p>类基本上就是产生对象的工厂</p>
<p>每次调用一个类,就会产生一个有独立命名空间的新对象</p>
<p>每个由类产生的对象都能读取类的属性,并获得自己的命名空间来储存数据,这些数据对于每个对象来说都不同</p>
</li>
<li><p>通过继承进行定制</p>
<p>类也支持OOP的继承的概念</p>
<p>我们可以在类的外部重新定义其属性从而扩充这个类</p>
<p>更通用的是,类可以建立命名空间的层次结构,而这种层次结构可以定义该结构中类创建的对象所使用的变量名</p>
</li>
<li><p>运算符重载</p>
<p>通过提供特定的协议方法,类可以定义对象来响应在内置类型上的几种运算</p>
<p>例如,通过类创建的对象可以进行切片、级联和索引等运算</p>
<p>Python提供了一些可以由类使用的钩子,从而能够中断并实现任何的内置类型运算</p>
</li>
</ul>
</blockquote>
<hr>
<h2 id="概览OOP"><a href="#概览OOP" class="headerlink" title="概览OOP"></a>概览OOP</h2><h3 id="属性继承搜索"><a href="#属性继承搜索" class="headerlink" title="属性继承搜索"></a>属性继承搜索</h3><p>Python中大多数OOP的表达式为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.attribut</span><br></pre></td></tr></table></figure>

<p>当对<code>class</code>语句产生的对象使用这一表达式时会在Python中启动搜索,搜索对象连接的树来寻找<code>attribute</code>首次出现的地方,先搜索<code>object</code>,然后就是该对象之上的所有类</p>
<p>这种搜索程序是继承,树中位置较低的对象继承了树中位置较高的对象拥有的属性,当从下至上进行搜索时,连接至树中的对象就是树中所有上层对象所定义的所有属性的集合体,直到树的最顶端</p>
<blockquote>
<ul>
<li><p>类</p>
<p>类是实例工厂</p>
<p>类的属性提供了行为(数据以及函数),所有从类产生的实例都继承该类的属性</p>
</li>
<li><p>实例</p>
<p>代表程序领域中具体的元素,<br>实例属性记录数据,而每个特定对象的数据都不同</p>
</li>
</ul>
</blockquote>
<p>就搜索树来看,实例从它的类继承属性,而类是从搜索树中所有比它更上层的类中继承属性</p>
<p>通常把树中位置较高的类称为超类(基类),树中位置较低的类称为子类(派生类),超类提供所有子类共享的行为,但是由于搜索是由下而上,子类可能会在书中较低位置重新定义超类的变量名从而覆盖超类定义的行为</p>
<h3 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h3><p>在Python模型中,类和实例是两种不同的对象类型</p>
<p>在搜索树中,类和实例的主要用途都是用来作为另一种命名空间(变量的封装)</p>
<p>类和实例与模块一样有对其他命名空间对象的自动搜索连接,但类对应的是语句而不是整个文件</p>
<p>类和实例的主要差异在于实例由类中产生</p>
<p>内存中特定模块只有一个实例,而类制作多少实例都可以</p>
<p>从操作的角度来说类通常都有函数,而实例有其他基本的数据项,类的函数中使用了这些数据</p>
<h3 id="类方法调用"><a href="#类方法调用" class="headerlink" title="类方法调用"></a>类方法调用</h3><p>调用附属于类的函数时,总会隐含着这个类的实例,运算执行时总是有个主体对象,这个隐含的主体或环境就是将其称之为面向对象模型的一部分</p>
<p>Python把隐含的实例传进方法中的第一个特殊的参数,习惯上将其称为<code>self</code></p>
<h3 id="编写类树"><a href="#编写类树" class="headerlink" title="编写类树"></a>编写类树</h3><p>通过<code>class</code>语句和类调用可以构造一些树和对象</p>
<blockquote>
<ul>
<li>每个<code>class</code>语句会生成一个新的类对象</li>
<li>每次类调用时,就会生成一个新的实例对象</li>
<li>实例自动连接至创建了这些实例的类</li>
<li>类连接至其超类的方式是将超类列在类头部的括号内,其从左至右的顺序会决定树中的次序</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span>:</span> ...			<span class="comment"># Make class objects(ovals)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3</span>:</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span><span class="params">(C2, C3)</span>:</span>...	<span class="comment"># Linked to superclasses</span></span><br><span class="line"></span><br><span class="line">I1 = C1()				<span class="comment"># Make instance objects(rectangles)</span></span><br><span class="line">I2 = C1()				<span class="comment"># Linked to their classes</span></span><br></pre></td></tr></table></figure>

<p>运行三个<code>class</code>语句创建了三个类对象,然后通过两次调用C1创建两个实例对象</p>
<p>实例记住了他们来自哪个类,类C1也记住了它所列出的超类</p>
<p>这个例子使用了多重继承,在类树中,类有一个以上的超类<code>class</code>语句中小括号内超类由左至右的次序决定超类搜索的顺序</p>
<p>由于继承搜索的方式,属性附加的对象决定了变量名的作用域,附加在实例上的属性只属于实例,但附加在类上的属性由所有子例及其实例共享</p>
<p>属性附加在类和实例对象的代码</p>
<blockquote>
<ul>
<li>属性通常是在<code>class</code>语句中通过赋值语句添加在类中,而不是嵌入在函数的<code>def</code>语句内</li>
<li>属性通常是在类内,对传给函数的特殊参数(也就是<code>self</code>)做赋值运算添加在实例中的</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span><span class="params">(C2, C3)</span>:</span>			<span class="comment"># Make and link class C1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setname</span><span class="params">(self, who)</span>:</span>	<span class="comment"># Assign name: C1.setname</span></span><br><span class="line">        self.name = who		<span class="comment"># Self is either I1 or I2</span></span><br><span class="line"></span><br><span class="line">I1 = C1()					<span class="comment"># Make two instances</span></span><br><span class="line">I2 = C1()</span><br><span class="line">I1.setname(<span class="string">'bob'</span>)			<span class="comment"># Sets I1.name to 'bob'</span></span><br><span class="line">I2.setname(<span class="string">'mel'</span>)			<span class="comment"># Sets I2.name to 'mel'</span></span><br><span class="line">print(I1.name)				<span class="comment"># Prints 'bob'</span></span><br></pre></td></tr></table></figure>

<p>类通过函数为实例提供行为,由于<code>def</code>会在类中对变量名进行赋值,实际效果就是把属性添加在了类对象中,从而可以由所有实例和子类继承</p>
<p><code>def</code>出现在这种类的内部通常称为方法,而且会自动接收第一个特殊参数<code>self</code>,这个参数提供了被处理的实例的参照值</p>
<p>类可以生产多个实例,每当需要取出或设定正由某个方法调用所处理的特定的实例的属性时,那些方法通常都会通过这个自动传入的参数<code>self</code>,在之前的代码中,<code>self</code>是用来储存两个实例之一的内部变量名的</p>
<h3 id="OOP是为了代码重用"><a href="#OOP是为了代码重用" class="headerlink" title="OOP是为了代码重用"></a>OOP是为了代码重用</h3><hr>
<h2 id="本章习题"><a href="#本章习题" class="headerlink" title="本章习题"></a>本章习题</h2><ol>
<li><p>Python的OOP的重要的意义是什么</p>
<blockquote>
<p>OOP就是代码的重用:分解代码、最小化代码的冗余以及对现存的代码进行定制来编写程序,而不是实地修改代码,或者从头开始</p>
</blockquote>
</li>
<li><p>继承搜索在哪里查找属性</p>
<blockquote>
<p>继承搜索会先在实例对象中寻找属性,然后才是创建实例的类,之后是所有较高的超类,由对象树底端到顶端,并且从左侧至右侧(默认)</p>
<p>当属性首次找到时,搜索就会停止</p>
<p>因为在此过程中变量名的最低的版本会获胜,类的层次自然而然地支持了通过扩展进行代码的定制,</p>
</blockquote>
</li>
<li><p>类对象和实例对象有什么不同</p>
<blockquote>
<p>类和实例对象都是命名空间( 由作为属性的变量的包)</p>
<p>两者间主要差别是,类是建立多个实例的工厂</p>
<p>类也支持运算符重载方法,由实例继承,而且把其中的任何函数视为处理实例的特殊的方法</p>
</blockquote>
</li>
<li><p>为什么类方法函数中的第-一个参数特殊</p>
<blockquote>
<p>类方法函数中的第一个参数之所以特殊,是因为它总是接受将方法调用视为隐含主体的实例对象</p>
<p>按惯例,通常称为<code>self</code></p>
<p>因为方法函数默认总是有这个隐含的主体对象环境,所以我们说这是<code>面向对象</code>,也就是设计用来处理或修改对象的</p>
</blockquote>
</li>
<li><p><code>__init__</code>方法是做什么用的</p>
<blockquote>
<p>如果类中编写了或继承了<code>__ init__</code>方法, 每次类实例创建时,Python会自动调用它</p>
<p>这也称为构造函数</p>
<p>除了明确传入类的名称的任何参数外,还会隐性的传入新实例</p>
<p>这也是最常见的运算符重载方法</p>
<p>如果没有<code>__init__</code> 方法.实例刚创建时就是一个简单的空的命名空间</p>
</blockquote>
</li>
<li><p>怎样创建类实例</p>
<blockquote>
<p>你可以调用类名称(就好像函数一样)来创建类实例</p>
<p>任何传给类名称的参数都要出现在<code>__ init__</code> 构造函数中第二和其后的参数</p>
<p>新的实例会记得创建它的类,从而可以实现继承目的</p>
</blockquote>
</li>
<li><p>怎样创建类</p>
<blockquote>
<p>你可以运行class语句来创建类</p>
<p>就像函数定义一样,这些语句在所在的模块文件导人时,一般就会运行</p>
</blockquote>
</li>
<li><p>怎样定义类的超类</p>
<blockquote>
<p>定义一个类的超类是通过在<code>class</code>语句的圆括号中将其列出,也就是在新的类名称后</p>
<p>类在圆括号中由左至右列出的顺序,会决定其在类树中由左至右的搜索的顺序</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="第二十六章-类代码编写基础"><a href="#第二十六章-类代码编写基础" class="headerlink" title="第二十六章 类代码编写基础"></a>第二十六章 类代码编写基础</h1><blockquote>
<ul>
<li>本章分析一些实际应用中的基本的类从而详细探讨OOP</li>
<li>研究<code>class</code>语句的语法,了解它是如何用于创建类的继承树的</li>
<li>研究Python如何自动添加方法函数内的第一个参数</li>
<li>研究属性如何通过简单赋值语句把属性加到类树中的对象</li>
<li>研究特殊名称运算符重载方法如何替实例截获并实现内置运算</li>
</ul>
</blockquote>
<hr>
<h2 id="类产生多个实例对象"><a href="#类产生多个实例对象" class="headerlink" title="类产生多个实例对象"></a>类产生多个实例对象</h2><p>类对象提供默认行为,是实例对象的工厂</p>
<p>实例对象是程序处理的实际对象,各自有独立的命名空间,但是继承创建该实例的类中的变量名</p>
<p>类对象来自于语句,实例对象来自于调用</p>
<h3 id="类对象提供默认行为"><a href="#类对象提供默认行为" class="headerlink" title="类对象提供默认行为"></a>类对象提供默认行为</h3><p>Python类主要特性</p>
<blockquote>
<ul>
<li><p><code>class</code>语句创建类对象并将其赋值给变量名</p>
<p>就像函数<code>def</code>语句,Python <code>class</code>语句也是可执行语句,执行时会产生新的类对象,并将其赋值给<code>class</code>头部的变量名</p>
<p>就像<code>def</code>应用,<code>class</code>语句一般是在其所在文件导入时执行的</p>
</li>
<li><p><code>class</code>语句内的赋值语句会创建类的属性</p>
<p>就像模块文件一样,<code>class</code>语句内的顶层的赋值语句会产生类对象中的属性</p>
<p>从技术角度来讲<code>class</code>语句的作用域会变成类对象属性的命名空间,就像模块的全局作用域一样</p>
<p>执行<code>class</code>语句后,类的属性可由变量名点号运算获取<code>object.name</code></p>
</li>
<li><p>类属性提供对象的状态和行为</p>
<p>类对象的属性记录状态信息和行为,由这个类所创建的所有实例共享</p>
<p>位于类中的函数<code>def</code>语句会生成方法,方法将会处理实例</p>
</li>
</ul>
</blockquote>
<h3 id="实例对象是具体的元素"><a href="#实例对象是具体的元素" class="headerlink" title="实例对象是具体的元素"></a>实例对象是具体的元素</h3><p>类的实例</p>
<blockquote>
<ul>
<li><p>像函数那样调用类对象会创建新的实例对象</p>
<p>每次类调用时,都会建立并返回新的实例对象,实例代表了程序领域中的具体元素</p>
</li>
<li><p>每个实例对象继承类的属性并获得了自己的命名空间</p>
<p>由类所创建的实例对象是新命名空间,一开始是空的,但是会继承创建该实例的类对象内的属性</p>
</li>
<li><p>在方法内对<code>self</code>属性做赋值运算会产生每个实例自己的属性</p>
<p>在类方法函数内,第一个参数<code>self</code>会引用当前调用的实例对象</p>
<p>对<code>self</code>的属性做赋值运算会创建或修改实例内的数据,而不是类的数据</p>
</li>
</ul>
</blockquote>
<h3 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">FirstClass</span>:</span>				<span class="comment"># Define a class object</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">setdata</span><span class="params">(self, value)</span>:</span>	<span class="comment"># Define class methods</span></span><br><span class="line"><span class="meta">... </span>            self.data = value	<span class="comment"># self is the instance</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            print(self.data)	<span class="comment"># self.data:per instance</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>与<code>def</code>建立函数相同,<code>class</code>语句在执行时创建类对象</p>
<p><code>class</code>语句首行列出类的名称,<code>:</code>后接一个或多个内嵌语句的主体</p>
<p><code>class</code>语句内所有位于顶层的赋值语句会产生附加在类上的属性,<code>def</code>语句是赋值运算,位于类中的函数称为<code>方法</code></p>
<p>在方法函数中,调用时第一个参数自动接收隐含的实例对象即调用的主体</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = FirstClass()			<span class="comment"># Make twi instances</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = FirstClass()			<span class="comment"># Each is a new namespace</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.setdata(<span class="string">"King arthur"</span>)	<span class="comment"># Call methods:self is x</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y.setdata(<span class="number">3.14159</span>)			<span class="comment"># Runs:FitstClass.setdata(3.14159)</span></span><br></pre></td></tr></table></figure>

<p>调用类产生的实例对象可以读取类属性的命名空间,类和实例是类树中通过继承搜索的相连的命名空间</p>
<p>继承是在对对象<code>.</code>运算时发生的,只与查找相连各个对象内的变量名有关,对实例以及类对象内的属性名称进行<code>.</code>运算可以通过继承搜索从实例或类中取得变量名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.display()		<span class="comment"># self.data differs in each instance</span></span><br><span class="line">King arthur</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y.display()</span><br><span class="line"><span class="number">3.14159</span></span><br></pre></td></tr></table></figure>

<p>在方法中,<code>self</code>自动引用正在处理的实例,赋值语句会把值储存在实例的命名空间而不是类的命名空间</p>
<p>不同实例的<code>self.data</code>值不同,但<code>display</code>方法相同,都继承自类</p>
<p>实例属性(成员)在首次赋值后存在,接受任何对象类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.data = <span class="string">"New value"</span>	<span class="comment"># Can get/set attributes</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.display()				<span class="comment"># Oytside the class too</span></span><br><span class="line">New value</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.anothername = <span class="string">"spam"</span>	<span class="comment"># Can set new attributes here too!</span></span><br></pre></td></tr></table></figure>

<p>可以在方法内对<code>self</code>赋值运算修改实例属性,或者在类外通过对实例对象赋值运算修改属实例性</p>
<p>可以在实例命名空间内产生全新的属性,实例对象的任何类方法都可以使用该对象</p>
<p>类通过<code>self</code>参数进行赋值运算建立实例的所有属性</p>
<hr>
<h2 id="类通过继承进行定制"><a href="#类通过继承进行定制" class="headerlink" title="类通过继承进行定制"></a>类通过继承进行定制</h2><p>类可以引入<code>子类</code>来进行修改,而不对现有组件进行原地的修改</p>
<p>编写类<strong>层次</strong>结构可以通过让类继承其他类实现,在阶层较低的地方覆盖现有的属性,让行为特定化</p>
<p>属性继承机制</p>
<blockquote>
<ul>
<li><p>超类列在了类开头的括号中</p>
<p>要继承另一个类的属性需要把该类列在<code>class</code>语句开头的括号中</p>
<p>含有继承的类称为<code>子类</code>,而子类所继承的类就是其<code>超类</code></p>
</li>
<li><p>类从其超类中继承属性</p>
<p>就像实例继承其类中所定义的属性名一样,类也会继承其超类中定义的所有属性名称</p>
<p>当读取属性时,如果属性不存在于子类中,Python会自动搜索父类中的这个属性</p>
</li>
<li><p>实例会继承所有可读取类的属性</p>
<p>每个实例会从创建它的类及该类的超类中获取变量名</p>
<p>寻找变量名时,Python会检查实例,然后是它的类,最后是所有超类</p>
</li>
<li><p>每个<code>object.attribute</code>都会开启新的独立搜索</p>
<p>Python会对每个属性取出表达式进行对类树的独立搜索,包括在<code>class</code>语句外对实例和类的引用(例如,X.attr)</p>
<p>方法中的每个<code>self.attr</code>表达式都会开启对<code>self</code>及其上层中类的<code>attr</code>属性的搜索</p>
</li>
<li><p>逻辑的修改是通过创建子类,而不是修改超类</p>
<p>在树中层次较低的子类中重新定义超类的变量名,子类就可取代并定制所继承的行为</p>
</li>
</ul>
</blockquote>
<p>类树搜索是由于类支持程序的分解和定制,且可以把程序的冗余度降到最低</p>
<h3 id="第二个例子"><a href="#第二个例子" class="headerlink" title="第二个例子"></a>第二个例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">FirstClass</span>:</span>				<span class="comment"># Define a class object</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">setdata</span><span class="params">(self, value)</span>:</span>	<span class="comment"># Define class methods</span></span><br><span class="line"><span class="meta">... </span>            self.data = value	<span class="comment"># self is the instance</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            print(self.data)	<span class="comment"># self.data:per instance</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">SecondClass</span><span class="params">(FirstClass)</span>:</span>	<span class="comment"># Inherits setdata</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span>			<span class="comment"># Changes display</span></span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'Current value = "%s"'</span> % self.data)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在树中较低处发生的重新定义的、取代属性的动作称为<code>重载</code>,类树搜索中同名的属性会在树中较低位置处首先被找到,所以会覆盖父类中的同名属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = FirstClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.data = <span class="string">"New value"</span>	<span class="comment"># Can get/set attributes</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = SecondClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z.setdata(<span class="number">42</span>)			<span class="comment"># Finds setdata in FirstClass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z.display()				<span class="comment"># Finds overridden method in SecondClass</span></span><br><span class="line">Current value = <span class="string">"42"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.display()				<span class="comment"># x is still a FirstClass  instance</span></span><br><span class="line">New value</span><br></pre></td></tr></table></figure>

<p>子类及其实例会继承父类的非同名属性</p>
<p>子类属性的专有化是在父类外部完成的,不会影响到父类对象</p>
<h3 id="类是模块内的属性"><a href="#类是模块内的属性" class="headerlink" title="类是模块内的属性"></a>类是模块内的属性</h3><p><code>class</code>语句执行时将类对象赋值给类名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> modulename <span class="keyword">import</span> FirstClass			<span class="comment"># Copy name into my scope</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondClass</span><span class="params">(FirstClass)</span>:</span>				<span class="comment"># Use class name directly</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> modulename							<span class="comment"># Access the whole module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondClass</span><span class="params">(modulename.FirstClass)</span>:</span>	<span class="comment"># Qualify to reference</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span> ...</span><br></pre></td></tr></table></figure>

<p>类对象可以用任何普通表达式引用,可以在交互模式下输入或写在文件中将其导入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># food.py</span></span><br><span class="line">var = <span class="number">1</span>				<span class="comment"># food.var</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span>			<span class="comment"># food.func</span></span><br><span class="line">	...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">spam</span>:</span>			<span class="comment"># food.spam</span></span><br><span class="line">	...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ham</span>:</span>			<span class="comment"># food.ham</span></span><br><span class="line">	...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">eggs</span>:</span>			<span class="comment"># food.eggs</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>类存在于模块,遵循模块相关的规则</p>
<blockquote>
<ul>
<li>单一模块文件内可以有一个以上的类</li>
<li>在<code>class</code>语句导入时执行,类名会变成独立的模块属性</li>
<li>每个模块可以任意混合任意数量的变量、函数以及类,而模块内的所有变量名的行为都相同</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span>:</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">% python</span><br><span class="line"><span class="keyword">import</span> person				<span class="comment"># import module</span></span><br><span class="line">x = person.person()			<span class="comment"># Class within module</span></span><br><span class="line"><span class="keyword">from</span> person <span class="keyword">import</span> person	<span class="comment"># Get class from module</span></span><br><span class="line">x = person()				<span class="comment"># Use class name</span></span><br></pre></td></tr></table></figure>

<p>模块名与类名相同时以同样方式导入</p>
<p>Python通用惯例指出,类名应该以一个大写字母开头使得它们更为清晰</p>
<hr>
<h2 id="类可以截获Python运算符"><a href="#类可以截获Python运算符" class="headerlink" title="类可以截获Python运算符"></a>类可以截获Python运算符</h2><p><code>运算符重载</code>就是让用类写成的对象可截获并响应用在内置类型上的运算,包括加法、切片、打印和点号运算</p>
<p>运算符重载是<strong>表达式</strong>对<strong>方法</strong>的自动分发机制,表达式和其他内置运算流程要经过类的实现来控制,可以自己在类对象中以任何方式解释运算符</p>
<p>运算符重载是可选的功能,主要应用于开发Python工具</p>
<blockquote>
<ul>
<li><p>以双下划线命名的方法<code>__X__</code></p>
<p>Python运算符重载的实现是提供特殊命名的方法来拦截内置运算</p>
<p>Python语言替每种运算和特殊命名的方法之间定义了固定不变的映射关系,如<code>+</code>对应类的<code>__add__</code>方法</p>
</li>
<li><p>当实例出现在内置运算时,这类方法会自动调用</p>
<p>例如,如果实例对象继承了<code>__add__</code>方法,当对象出现在<code>+</code>表达式内时,该方法就会自动调用,该方法的返回值会变成相应<code>+</code>表达式的结果</p>
</li>
<li><p>类可覆盖多数内置类型运算</p>
<p>有几十种特殊运算符重载的方法的名称,几乎可截获并实现内置类型的所有运算,它不仅包括了表达式,而且像打印和对象建立这类基本运算也包括在内</p>
</li>
<li><p>运算符覆盖方法没有默认值,而且也不需要</p>
<p>如果类没有定义或继承运算符重载方法,相应的运算在类实例中并不支持</p>
<p>例如,如果类中没有<code>__add__</code>, <code>+</code>表达式对对象运算就会引发异常</p>
</li>
<li><p>运算符可让类与Python的对象模型相集成</p>
<p>重载类型运算使以类实现的用户定义对象的行为会像内置对象一样,提供了对象接口一致性以及与预期接口的兼容性</p>
</li>
</ul>
</blockquote>
<h3 id="第三个例子"><a href="#第三个例子" class="headerlink" title="第三个例子"></a>第三个例子</h3><p>定义类<code>ThirdClass</code>实现三个特殊名称的属性</p>
<blockquote>
<ul>
<li>当新的实例构造时,会调用<code>__ init__</code></li>
<li>当<code>ThirdClass</code>实例出现在<code>+</code>表达式中时会调用<code>__add__</code></li>
<li>当打印一个对象的时候会运行<code>__str__</code></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">FirstClass</span>:</span>				<span class="comment"># Define a class object</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">setdata</span><span class="params">(self, value)</span>:</span>	<span class="comment"># Define class methods</span></span><br><span class="line"><span class="meta">... </span>            self.data = value	<span class="comment"># self is the instance</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            print(self.data)	<span class="comment"># self.data:per instance</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">SecondClass</span><span class="params">(FirstClass)</span>:</span>	<span class="comment"># Inherits setdata</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span>			<span class="comment"># Changes display</span></span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'Current value = "%s"'</span> % self.data)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ThirdClass</span><span class="params">(SecondClass)</span>:</span>				<span class="comment">#Inherit from SecondClass</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span>				<span class="comment"># On "ThirdClass(value)"</span></span><br><span class="line"><span class="meta">... </span>            self.data = value</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span>				<span class="comment"># On "self + other"</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span>  ThirdClass(self.data + other)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>						<span class="comment"># On "print(self)", "str()"</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> <span class="string">'[ThirdClass: %s]'</span> % self.data</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(self, other)</span>:</span>					<span class="comment"># In-place change:named</span></span><br><span class="line"><span class="meta">... </span>            self.data *= other</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = ThirdClass(<span class="string">'abc'</span>)						<span class="comment"># __init__ called</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.display()									<span class="comment"># Inherited method called</span></span><br><span class="line">Current value = <span class="string">"abc"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)									<span class="comment"># __str__:returns display string</span></span><br><span class="line">[ThirdClass: abc]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a + <span class="string">'xyz'</span>								<span class="comment"># __add__:makes a new instance</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.display()									<span class="comment"># b has all ThirdClass methods</span></span><br><span class="line">Current value = <span class="string">"abcxyz"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(b)									<span class="comment"># __str__:returns display string</span></span><br><span class="line">[ThirdClass: abcxyz]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.mul(<span class="number">3</span>)									<span class="comment"># mul:changes instance in-place</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)</span><br><span class="line">[ThirdClass: abcabcabc]</span><br></pre></td></tr></table></figure>

<p><code>__init__</code>运算符重载方法也称为<code>构造函数</code>方法,实例化类时传递的参数会传给<code>__init__</code>构造函数内的<code>value</code>参数,用于初始化对象的状态</p>
<p><code>+</code>操作会把左侧的实例对象传给<code>__add__</code>中的<code>self</code>参数,把右边的值传给<code>other</code>,返回的值作为<code>+</code>表达式的结果,返回时会创建这个类新的实例对象</p>
<p><code>print</code>中要打印的对象会被传递给<code>__str__</code>中的<code>self</code>,返回的字符串作为对象的打印字符串</p>
<p><code>__init__</code>、<code>__add__</code>和<code>__str__</code>等特殊命名的方法与其他变量名一样会由子类和实例继承</p>
<p>运算符重载方法的名称不是内置变量或保留字,只是当对象出现在不同的环境时Python会去搜索的属性,Python会自动调用或可以由程序代码调用</p>
<h3 id="为什么要使用运算符重载"><a href="#为什么要使用运算符重载" class="headerlink" title="为什么要使用运算符重载"></a>为什么要使用运算符重载</h3><p>如果省略运算符重载方法且不从超类中继承该方法,实例就不支持相应的运算,会抛出异常</p>
<p>只有在实现本质为数学的对象时才会用到许多运算符重载方法</p>
<p>需要传递用户定义的对象给预期的内置类型(例如,列表或字典)一个可用的运算符的函数,可能需要使用运算符重载.在类中实现同一组运算符,可以保证对象会支持相同的预期的对象接口从而与这个函数兼容</p>
<p>每一个实际的类都会出现一个重载方法<code>__init__</code>构造函数,可以让类立即在其新建的实例内添加属性</p>
<hr>
<h2 id="世界上最简单的Python类"><a href="#世界上最简单的Python类" class="headerlink" title="世界上最简单的Python类"></a>世界上最简单的Python类</h2><p>类的基本继承模型就是在连接的对象树中搜索属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">rec</span>:</span> <span class="keyword">pass</span>		<span class="comment"># Empty namespace object</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec.name = <span class="string">'Bob'</span>	<span class="comment"># Just objects with attributes</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec.age = <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = rec()			<span class="comment"># Instances inherit class names</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = rec()			<span class="comment"># name is stored on the class only</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.name, y.name</span><br><span class="line">(<span class="string">'Bob'</span>, <span class="string">'Bob'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.name = <span class="string">'Sue'</span>		<span class="comment"># But assignment changes x only</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec.name, x.name, y.name</span><br><span class="line">(<span class="string">'Bob'</span>, <span class="string">'Sue'</span>, <span class="string">'Bob'</span>)</span><br></pre></td></tr></table></figure>

<p>建立的类可以没有附加的属性,需要添加<code>pass</code>语句</p>
<p>建立类后可以通过赋值变量名直接为<strong>类</strong>增加属性而不需要实例化类,因为类本身也是对象,有独立完备的命名空间,可以在任何时刻设定或修改其属性</p>
<p>实例化类时实例是空的命名空间对象,可以继承并获取附加在类上的属性,但是实例本身没有属性</p>
<p>如果把一个属性赋值给一个实例,就会在该实例对象内创建或修改该属性,但不会因属性的引用而启动继承搜索,因为属性赋值运算只会影响属性赋值所在的类或实例对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec.__dict__.keys()</span><br><span class="line">dict_keys([<span class="string">'__module__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'__doc__'</span>, <span class="string">'name'</span>, <span class="string">'age'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(x.__dict__.keys())</span><br><span class="line">[<span class="string">'name'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(y.__dict__.keys())</span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">rec</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">rec</span>.<span class="title">__bases__</span></span></span><br><span class="line"><span class="class"><span class="params">(&lt;class <span class="string">'object'</span>&gt;,)</span></span></span><br></pre></td></tr></table></figure>

<p>命名空间对象的属性通常是以字典的形式实现的,而继承树只是连接至其他字典的字典</p>
<p><code>__dict__</code>属性是大多数基于类的对象的命名空间字典(一些类也可能在<code>__slots__</code>中定义属性)</p>
<p>通过 <code>__class__</code>属性可以查看实例继承的类,<code>__base__</code>属性显示类的超类的元组,这两个属性是Python在内存中类树常量的表示方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">upperName</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> self.name.upper()	<span class="comment"># Still needs a self</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>upperName(x)					<span class="comment"># Call as a simple fucntion</span></span><br><span class="line"><span class="string">'SUE'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec.method = upperName</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.method()						<span class="comment"># Run method to process x</span></span><br><span class="line"><span class="string">'SUE'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y.method()						<span class="comment"># Same, but pass y to self</span></span><br><span class="line"><span class="string">'BOB'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec.method(x)					<span class="comment"># Can call through instance or class</span></span><br><span class="line"><span class="string">'SUE'</span></span><br></pre></td></tr></table></figure>

<p>Python的类模型相当动态,类和实例只是命名空间对象,能引用树中任何一个对象的任意位置处都可以通过通过赋值语句动态建立属性</p>
<p>函数也可以独立地在任意类的外部创建类的属性</p>
<p>将类外部的函数赋值为类的属性,就会变成方法,可以由任何实例调用</p>
<p>通常情况下,类是由<code>class</code>语句填充,而实例的属性则通过在类的方法函数内对<code>self</code>属性进行赋值运算创建</p>
<p>Python中的OOP实际上是在已连接命名空间对象内寻找属性</p>
<h3 id="类与字典的关系"><a href="#类与字典的关系" class="headerlink" title="类与字典的关系"></a>类与字典的关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec[<span class="string">'name'</span>] = <span class="string">'mel'</span>		<span class="comment"># Dictionary-based record</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec[<span class="string">'age'</span>] = <span class="number">45</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec[<span class="string">'job'</span>] = <span class="string">'trainer/writer'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(rec[<span class="string">'name'</span>])</span><br><span class="line">mel</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">rec</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec.name = <span class="string">'mel'</span>		<span class="comment"># Class-based record</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec.age = <span class="number">45</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec.job = <span class="string">'trainer/writer'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(rec.age)</span><br><span class="line"><span class="number">45</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">rec</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pers1 = rec()			<span class="comment"># Instance-based records</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pers1.name = <span class="string">'mel'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pers1.job = <span class="string">'trainer'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pers1.age = <span class="number">40</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pers2 = rec()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pers2.name = <span class="string">'vls'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pers2.job = <span class="string">'developer'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pers1.name, pers2.name</span><br><span class="line">(<span class="string">'mel'</span>, <span class="string">'vls'</span>)</span><br></pre></td></tr></table></figure>

<p>字典可以记录程序中实体的属性</p>
<p>类可以像字典一样打包信息,使用键来记录属性,对类属性赋值来填充它</p>
<p>对于每一条不同的记录,我们可以实例化空的类,对实例的属性赋值来填充记录,不同的实例有不同的名称空间所以有不同的属性字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job)</span>:</span>			<span class="comment"># Class = Data + Logic</span></span><br><span class="line"><span class="meta">... </span>            self.name = name</span><br><span class="line"><span class="meta">... </span>            self.job = job</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> (self.name, self.job)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec1 = Person(<span class="string">'mel'</span>, <span class="string">'trainer'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec2 = Person(<span class="string">'vls'</span>, <span class="string">'developer'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec1.job, rec2.info()</span><br><span class="line">(<span class="string">'trainer'</span>, (<span class="string">'vls'</span>, <span class="string">'developer'</span>))</span><br></pre></td></tr></table></figure>

<p>也可以以方法的形式绑定处理逻辑,在构建的时候初始化实例并把属性收集到一个元组中</p>
<hr>
<h2 id="本章习题-1"><a href="#本章习题-1" class="headerlink" title="本章习题"></a>本章习题</h2><ol>
<li><p>类和模块之间有什么关系</p>
<blockquote>
<p><code>类</code>总是位于<code>模块</code>中,类是模块对象的属性</p>
<p><code>类</code>和<code>模块</code>都是命名空间</p>
<p>类对应于语句而不是整个文件,而且支持多个实例、继承以及运算符重载这些OOP概念</p>
<p>模块就像是单个的实例类,没有继承,而且模块对应于整个文件的代码。</p>
</blockquote>
</li>
<li><p>实例和类是如何创建的</p>
<blockquote>
<p>类是通过运行<code>class</code>语句创建的</p>
<p>实例是像函数那样调用类来创建的</p>
</blockquote>
</li>
<li><p>类属性是在哪里创建的,是怎样创建的</p>
<blockquote>
<p><code>类属性</code>的创建是通过把属性赋值给类对象实现的</p>
<p>类属性通常是由<code>class</code>语句中的顶层赋值语句而产生的,<code>class</code>语句的作用域会变成类对象属性的命名空间<br>可以在任何引用类对象的地方(<code>class</code>语句外)对其属性赋值从而创建类属性</p>
</blockquote>
</li>
<li><p>实例属性是在哪里创建的,是怎样创建的</p>
<blockquote>
<p><code>实例属性</code>是通过对实例对象赋值属性来创建的</p>
<p>实例属性一般是在<code>class</code>语句中的类方法函数中对<code>self</code>参数赋值属性而创建的</p>
<p>可以在任何引用了实例的地方通过赋值语句来创建属性,包括<code>class</code>语句外</p>
<p>一般来说,所有实例属性都是在<code>__ init__</code>构造函数中初始化的,这样的话,之后的方法调用都可假设属性已经存在</p>
</blockquote>
</li>
<li><p>Python类中的<code>self</code>有什么意义</p>
<blockquote>
<p><code>self</code>通常是类方法函数中第一个参数的名称,Python会自动为其填入实例对象(也就是方法调用的隐含主体)</p>
<p>这个参数不一定叫<code>self</code>,其位置才是重点</p>
</blockquote>
</li>
<li><p>Python类中如何编写运算符重载</p>
<blockquote>
<p>Python类中的<code>运算符重载</code>是用特定名称的方法写成的,这些方法的开头和结尾都是双下划线,但不是内置函数或保留字</p>
<p>当实例出现在相应的<code>运算</code>中时,Python就会自动执行特定名称的方法</p>
<p>Python为这些运算和特殊方法的名称定义了对应关系</p>
</blockquote>
</li>
<li><p>什么时候可能在类中支持运算符重载</p>
<blockquote>
<p>运算符重载可用于实现模拟内置类型的对象(例如,序列或像矩阵这样的数值对象),以及模拟代码中所预期的内置类型接口</p>
<p>模拟内置类型的接口可让你传入具有状态信息(也就是记住操作调用之间数据的属性)的类实例</p>
<p>当简单命名的方法就够用时,不应该使用运算符重载</p>
</blockquote>
</li>
<li><p>哪个运算符重载方法是最常用的</p>
<blockquote>
<p><code>__init__</code>构造函数是最常用的</p>
<p>几乎每个类都使用这个方法为实例属性进行初始化,以及执行其他的启动任务</p>
</blockquote>
</li>
<li><p>Python OOP程序代码中最重要的两个概念是什么</p>
<blockquote>
<p>方法函数中的特殊<code>self</code>参数和<code>__init__</code>构造函数是Python中OOP的两个基石</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="第二十七章-更多实例"><a href="#第二十七章-更多实例" class="headerlink" title="第二十七章 更多实例"></a>第二十七章 更多实例</h1><blockquote>
<ul>
<li>展示关于类的一些更加实际的例子</li>
<li>介绍Python类和OOP的所有基础知识的实际应用</li>
<li>提供关于Python面向对象程序设计的教程</li>
<li>介绍多种减少冗余性和最小化维护代价的构建代码的方式</li>
<li>简单地介绍了使用GUI和数据库这样的应用程序工具来拓展代码的方式</li>
</ul>
</blockquote>
<hr>
<h2 id="步骤1-创建实例"><a href="#步骤1-创建实例" class="headerlink" title="步骤1:创建实例"></a>步骤1:创建实例</h2><p>编写主类Person</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File person.py(start)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br></pre></td></tr></table></figure>

<p>在Python中,按照惯例,模块名使用小写字母,而类名使用一个大写字母开通</p>
<p>在Python中的单个模块文件可以编写任意多个函数和类</p>
<p>当模块拥有一个单一、一致的用途时工作得更好</p>
<h3 id="编写构造函数"><a href="#编写构造函数" class="headerlink" title="编写构造函数"></a>编写构造函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add record field initialization</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job, pay)</span>:</span>		<span class="comment"># Constructor takes 3 arguments</span></span><br><span class="line">		self.name = name				<span class="comment"># Fill out fields when created</span></span><br><span class="line">		self.job = job					<span class="comment"># self is the nw instance object</span></span><br><span class="line">		self.pay = pay</span><br></pre></td></tr></table></figure>

<p>通常通过给类方法函数中的<code>self</code>属性赋值来<code>实例</code>对象属性</p>
<p>赋给实例属性<strong>第一个值</strong>的通常方法是在<code>__init__</code>构造函数方法中将它们赋值给<code>self</code></p>
<p>创建实例时传入的参数会作为构造函数方法的参数,可以将参数赋值给<code>self</code>对应的属性,<code>self</code>就是新创建的实例对象,传入的参数称为状态信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add defaults for constructor arguments</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span>	<span class="comment"># Normal function args</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.job = job</span><br><span class="line">		self.pay = pay</span><br></pre></td></tr></table></figure>

<p>构造函数方法<code>__init__</code>是一个常规的函数,支持所有的函数特性,可以为参数提供默认值</p>
<p>在产生一个实例时会自动调用构造函数,它包含了每次创建一个实例的时候Python会自动运行的代码</p>
<h3 id="在进行中测试"><a href="#在进行中测试" class="headerlink" title="在进行中测试"></a>在进行中测试</h3><p>Python编程是一种<code>增量原型</code>,可以编写一些代码、测试它编写更多代码、再次测试,以此类推</p>
<p>Python交互式会话可以在进行中多次测试代码,但是每次新的测试会话都需要重新导入模块和重新输入测试实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add incremental self-test  code</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.job = job</span><br><span class="line">		self.pay = pay</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">'Bob Smith'</span>)							Test the <span class="class"><span class="keyword">class</span></span></span><br><span class="line">sue = Person('Sue Jones', job='dev', pay=100000)	# Runs __init__ automatically</span><br><span class="line">print(bob.name, bob.pay)							<span class="comment"># Fetch attached attributes</span></span><br><span class="line">print(sue.name, sue.pay)							<span class="comment"># sue's and bob's attrs differ</span></span><br></pre></td></tr></table></figure>

<p>可以在包含测试对象文件的底部编写代码来进行更多的大量测试且更容易再次运行</p>
<p>关键字参数可以根据位置或关键字传递参数,关键字参数可以用来提醒数据的作用且没有顺序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% python person.py</span><br><span class="line">Bob Smith <span class="number">0</span></span><br><span class="line">Sue Jones <span class="number">100000</span></span><br></pre></td></tr></table></figure>

<p>测试结果证明每一个实例都是一个命令空间对象,拥有各自类所创建的状态信息的独立副本</p>
<p>类的每一个实例都有自己的一组<code>self</code>属性,类通过这种方式记录多个对象的信息</p>
<h3 id="以两种方式使用代码"><a href="#以两种方式使用代码" class="headerlink" title="以两种方式使用代码"></a>以两种方式使用代码</h3><p>在其他地方导入该类使用它时仍会看到其测试代码的输出</p>
<p>可以把测试代码分割到不同的文件中,但是与被测试项目相同的文件中编写代码更加方便</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Allow this file to be imported as wel as run/tested</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.job = job</span><br><span class="line">		self.pay = pay</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:		<span class="comment"># When run for testing only</span></span><br><span class="line">	<span class="comment"># self-test code</span></span><br><span class="line">	bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">	sue = Person(<span class="string">'Sue Jones'</span>, <span class="string">'dev'</span>, <span class="number">100000</span>)</span><br><span class="line">	print(bob.name, bob.pay)</span><br><span class="line">	print(sue.name, sue.pay)</span><br></pre></td></tr></table></figure>

<p><code>__name__</code>检查模块可以在文件运行时而非导入时运行测试语句</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% python person.py</span><br><span class="line">Bob Smith <span class="number">0</span></span><br><span class="line">Sue Jones <span class="number">100000</span></span><br><span class="line"></span><br><span class="line">% python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> person</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>导入时,文件定义了类,但是没有使用它</p>
<p>直接运行时,文件创建了类的两个实例并打印属性</p>
<hr>
<h2 id="步骤2-添加行为方法"><a href="#步骤2-添加行为方法" class="headerlink" title="步骤2:添加行为方法"></a>步骤2:添加行为方法</h2><p>尽管类添加了结构的一个额外的层级,但最终还是通过嵌入和处理列表及字符串这样的基本<strong>核心数据类型</strong>来完成大部分工作,类是最小的结构性拓展</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Process embedded built-in types: strings, mutability</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.job = job</span><br><span class="line">		self.pay = pay</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">	sue = Person(<span class="string">'Sue Jones'</span>, <span class="string">'dev'</span>, <span class="number">100000</span>)</span><br><span class="line">	print(bob.name, bob.pay)</span><br><span class="line">	print(sue.name, sue.pay)</span><br><span class="line">	print(bob.name.split()[<span class="number">-1</span>])		<span class="comment"># Extract object's last name</span></span><br><span class="line">	sue.pay *= <span class="number">1.10</span></span><br><span class="line">	print(sue.pay)</span><br></pre></td></tr></table></figure>

<p>可以对实例对象的属性应用对Python核心对象的基本操作,但是目标对象和类结构中的属性联系起来了</p>
<p>像这样在类<strong>之外</strong>的硬编码操作可能会导致未来的维护问题</p>
<h3 id="编写方法"><a href="#编写方法" class="headerlink" title="编写方法"></a>编写方法</h3><p>封装的思想是把操作逻辑包装到界面之后,这样每种操作在程序里只编码一次,需要修改时只需要修改一处且修改时不会影响到使用它的代码</p>
<p>我们需要操作对象的代码位于类方法中而不是分散在整个程序中,可以构造代码以删除冗余并优化维护,把操作放入方法中还会使得这些操作应用于类的任何实例</p>
<p>方法只是附加给类并旨在处理那些类的实例的常规函数,实例是方法调用的主体,并且会自动传递给方法<code>self</code>参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add methods to encapsulate operations for maintainability</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.job = job</span><br><span class="line">		self.pay = pay</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span>								<span class="comment"># Behavior methods</span></span><br><span class="line">		<span class="keyword">return</span> self.name.split()[<span class="number">-1</span>]				<span class="comment"># self is implied subject</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self,percent)</span>:</span></span><br><span class="line">		self.pay = int(self.pay * (<span class="number">1</span> + percent))	<span class="comment"># Must change here only</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">	sue = Person(<span class="string">'Sue Jones'</span>, <span class="string">'dev'</span>, <span class="number">100000</span>)</span><br><span class="line">	print(bob.name, bob.pay)</span><br><span class="line">	print(sue.name, sue.pay)</span><br><span class="line">	print(bob.lastName(), sue.lastName())			<span class="comment"># Use the new methods</span></span><br><span class="line">	sue.giveRaise(<span class="number">.10</span>)								<span class="comment"># instead of hardcoding</span></span><br><span class="line">	print(sue.pay)</span><br></pre></td></tr></table></figure>

<p>对于舍入问题,可以在方法中调用内置的<code>int</code>函数把结果转换为整数,使用内置的<code>round(N,2)</code>来舍入并保留分币,使用<code>decimal</code>类型来修改精度或存储为一个完整的浮点数并使用<code>%.2f</code>或<code>{0:.2f}</code>格式化字符串显示</p>
<p>Python自动把实例传递给第一个参数,从而告诉一个方法应该处理哪个实例,通常这个参数叫做<code>self</code></p>
<hr>
<h2 id="步骤3-运算符重载"><a href="#步骤3-运算符重载" class="headerlink" title="步骤3:运算符重载"></a>步骤3:运算符重载</h2><p>实例对象的默认显示格式为对象的类名及其在内存中的地址,必须手动地接受和打单个的属性</p>
<h3 id="提供打印显示"><a href="#提供打印显示" class="headerlink" title="提供打印显示"></a>提供打印显示</h3><p>通过运算符重载,编写一个在类的实例运行时将其截获并处理内置的操作的方法</p>
<p><code>__str__</code>方法在实例转换为其可打印字符串的时候自动运行,打印一个对象会显示对象的<code>__str__</code>方法所返回的内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add __str__ overload method for printing object</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.job = job</span><br><span class="line">		self.pay = pay</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.name.split()[<span class="number">-1</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self,percent)</span>:</span></span><br><span class="line">		self.pay = int(self.pay * (<span class="number">1</span> + percent))</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">'[Person: %s, %s]'</span> % (self.name, self.pay)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">	sue = Person(<span class="string">'Sue Jones'</span>, <span class="string">'dev'</span>, <span class="number">100000</span>)</span><br><span class="line">	print(bob)</span><br><span class="line">	print(sue)</span><br><span class="line">	print(bob.lastName(), sue.lastName())</span><br><span class="line">	sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line">	print(sue)</span><br></pre></td></tr></table></figure>

<p>在<code>__str__</code>中使用<code>%</code>格式构建字符串,类使用这样的内置类型对象和操作来完成任务</p>
<p>所有内置类型函数的内容都适用于基于类的代码,类很大程度上只是添加了额外的一层结构把函数和数据包装在一起并且支持拓展</p>
<hr>
<h2 id="步骤4-通过子类定制行为"><a href="#步骤4-通过子类定制行为" class="headerlink" title="步骤4:通过子类定制行为"></a>步骤4:通过子类定制行为</h2><p>之前编写的类有效地把数据和逻辑一起包装到一个单个的、自包含的结构中,使得将来能够很容易地定位代码并很直接地修改代码</p>
<p>继承是基于已完成的工作的定制来促进一种编码模式,可以显著地缩减开发时间</p>
<h3 id="编写子类"><a href="#编写子类" class="headerlink" title="编写子类"></a>编写子类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span>		<span class="comment"># Define a subclass of Person</span></span><br></pre></td></tr></table></figure>

<p>通过创建一个类继承超类,并且可以添加一些定制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span>							<span class="comment"># Inherit  Person attrs</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span>	<span class="comment"># Redefine to customize</span></span><br></pre></td></tr></table></figure>

<p>通过重新定义方法有效地替代了该方法,从而定制了该操作</p>
<h3 id="拓展方法-不好的方式"><a href="#拓展方法-不好的方式" class="headerlink" title="拓展方法:不好的方式"></a>拓展方法:不好的方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span></span><br><span class="line">		self.pay = int(self.pay * (<span class="number">1</span> + percent + bonus))	<span class="comment"># Bad:cut-and-paste</span></span><br></pre></td></tr></table></figure>

<p>不好的编写定制方法的方式是复制和粘贴超类的代码,然后进行修改</p>
<p>复制粘贴会使未来的维护工作倍增,当需要修改代码时必须修改两个地方的代码</p>
<h3 id="拓展方法-好的方式"><a href="#拓展方法-好的方式" class="headerlink" title="拓展方法:好的方式"></a>拓展方法:好的方式</h3><p>类方法总是可以在一个实例中调用或者通过类来调用,通过类调用需要手动地传递实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance.method(args...)</span><br></pre></td></tr></table></figure>

<p>自动地转换为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>.<span class="title">method</span><span class="params">(instance, args...)</span></span></span><br></pre></td></tr></table></figure>

<p>包含要运行的方法的类,由该方法的继承搜索规则确定</p>
<p>可以在脚本中以任何一种形式编写,通过类名调用的方式需要自己给<code>self</code>发送一个实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span></span><br><span class="line">		Person.giveRaise(self, percent + bonus)		<span class="comment"># Good:augment original</span></span><br></pre></td></tr></table></figure>

<p>通过使用拓展的参数来直接调用其超类的版本来拓展方法</p>
<p>通过类直接调用有效地扰乱了继承,并且把调用沿着类树向上传递一运行一个特定的版本</p>
<p>这样对未来的代码维护意义重大</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add customization of one behavior in a subclass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.job = job</span><br><span class="line">		self.pay = pay</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.name.split()[<span class="number">-1</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self,percent)</span>:</span></span><br><span class="line">		self.pay = int(self.pay * (<span class="number">1</span> + percent))</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">'[Person: %s, %s]'</span> % (self.name, self.pay)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span>		<span class="comment"># Redefine at this level</span></span><br><span class="line">		Person.giveRaise(self, percent + bonus)		<span class="comment"># Call Person's version</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">	sue = Person(<span class="string">'Sue Jones'</span>, <span class="string">'dev'</span>, <span class="number">100000</span>)</span><br><span class="line">	print(bob)</span><br><span class="line">	print(sue)</span><br><span class="line">	print(bob.lastName(), sue.lastName())</span><br><span class="line">	sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line">	print(sue)</span><br><span class="line">    tom = Manager(<span class="string">'Tom Jones'</span>, <span class="string">'mgr'</span>, <span class="number">50000</span>)		<span class="comment"># Make a Manager:__init__</span></span><br><span class="line">    tom.giveRaise(<span class="number">.10</span>)								<span class="comment"># Runs custom version</span></span><br><span class="line">    print(tom.lastName())							<span class="comment"># Runs inherited method</span></span><br><span class="line">    print(tom)										<span class="comment"># Runs inherited __str__</span></span><br></pre></td></tr></table></figure>

<p>子类继承了超类的<code>__str__</code>和<code>__init__</code>方法</p>
<h3 id="多态的作用"><a href="#多态的作用" class="headerlink" title="多态的作用"></a>多态的作用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	bob = person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">	sue = person(<span class="string">'Sue Jones'</span>, <span class="string">'dev'</span>, <span class="number">100000</span>)</span><br><span class="line">	print(bob)</span><br><span class="line">	print(sue)</span><br><span class="line">	print(bob.lastName(), sue.lastName())</span><br><span class="line">	sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line">	print(sue)</span><br><span class="line">	tom = Manager(<span class="string">'Tom Jones'</span>, <span class="string">'mgr'</span>, <span class="number">50000</span>)</span><br><span class="line">	tom.giveRaise(<span class="number">.10</span>)</span><br><span class="line">	print(tom.lastName())</span><br><span class="line">	print(tom)</span><br><span class="line">	print(<span class="string">'--All three--'</span>)</span><br><span class="line">	<span class="keyword">for</span> object <span class="keyword">in</span> (bob, sue, tom):		<span class="comment"># Process objects generically</span></span><br><span class="line">		object.giveRaise(<span class="number">.10</span>)			<span class="comment"># Run this object's giveRaise</span></span><br><span class="line">		print(object)					<span class="comment"># RUn the common __str__</span></span><br></pre></td></tr></table></figure>

<p>根据所传递的对象的类型自动运行相应的版本就是<code>多态</code></p>
<h3 id="继承、定制和扩展"><a href="#继承、定制和扩展" class="headerlink" title="继承、定制和扩展"></a>继承、定制和扩展</h3><p>类可以继承、定制和扩展超类中已有的代码</p>
<p>可以在子类中添加一个独特的、超类中没有的方法进行扩展,这样的扩展只能在子类中使用</p>
<h3 id="OOP-大思路"><a href="#OOP-大思路" class="headerlink" title="OOP:大思路"></a>OOP:大思路</h3><p>在OOP中可以通过定制来编程而不是复制和修改已有的代码</p>
<p>类所隐藏的编程风格会显著地减少开发时间</p>
<p>可以用类来构建可定制层级,为随时间而发展的软件提供更好的解决方案</p>
<blockquote>
<ul>
<li><strong>从头编写</strong>全新的、独立的类需要重新实现原来类中相同的行为</li>
<li>直接原处<strong>修改</strong>已有的类可能会使需要原来的操作的地方无法满足</li>
<li>在子类中<strong>复制</strong>父类的代码会引入代码冗余性,使未来维护的工作量倍增</li>
</ul>
</blockquote>
<hr>
<h2 id="步骤5-定制构造函数"><a href="#步骤5-定制构造函数" class="headerlink" title="步骤5:定制构造函数"></a>步骤5:定制构造函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add __str__ overload method for printing object</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.job = job</span><br><span class="line">		self.pay = pay</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.name.split()[<span class="number">-1</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self,percent)</span>:</span></span><br><span class="line">		self.pay = int(self.pay * (<span class="number">1</span> + percent))</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">'[Person: %s, %s]'</span> % (self.name, self.pay)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, pay)</span>:</span>					<span class="comment"># Redefine constructor</span></span><br><span class="line">		Person.__init__(self, name, <span class="string">'mgr'</span>, pay)		<span class="comment"># Run otiginal with 'mgr'</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span></span><br><span class="line">		Person.giveRaise(self, percent + bonus)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">	sue = Person(<span class="string">'Sue Jones'</span>, <span class="string">'dev'</span>, <span class="number">100000</span>)</span><br><span class="line">	print(bob)</span><br><span class="line">	print(sue)</span><br><span class="line">	print(bob.lastName(), sue.lastName())</span><br><span class="line">	sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line">	print(sue)</span><br><span class="line">	tom = Manager(<span class="string">'Tom Jones'</span>, <span class="number">50000</span>)				<span class="comment"># Job name not needed:</span></span><br><span class="line">	tom.giveRaise(<span class="number">.10</span>)								<span class="comment"># Implied/set by class</span></span><br><span class="line">	print(tom.lastName())</span><br><span class="line">	print(tom)</span><br></pre></td></tr></table></figure>

<p>通过类名直接调用并显式地传递<code>self</code>实例运行超类的版本来扩展<code>__init__</code>构造函数</p>
<p>在构造的时候,Python自身使用类树来查找并调用唯一的也是最低的一个<code>__init__</code>方法,必须通过超类的名称手动调用来运行更高的<code>__init__</code>方法</p>
<h3 id="OOP比我们认为的要简单"><a href="#OOP比我们认为的要简单" class="headerlink" title="OOP比我们认为的要简单"></a>OOP比我们认为的要简单</h3><p>Python的OOP机制中的概念</p>
<blockquote>
<ul>
<li>实例创建–填充实例属性</li>
<li>行为方法—在类方法中封装逻辑</li>
<li>运算符重载–为打印这样的内置操作提供行为</li>
<li>定制行为–重新定义子类中的方法以使其特殊化</li>
<li>定制构造函数—为超类步骤添加初始化逻辑</li>
</ul>
</blockquote>
<p>这些概念基于3个简单的思路:在对象树中继承,查找属性、方法中特殊的<code>self</code>参数以及运算符重载对方法的自动派发</p>
<p>通过这种方法可以使自己的代码在未来易于修改,通过定制方法减少冗余</p>
<h3 id="组合类的其他方法"><a href="#组合类的其他方法" class="headerlink" title="组合类的其他方法"></a>组合类的其他方法</h3><p>Python中的OOP基本机制很简单,但较大的程序中的一些技术在于组合类的方式</p>
<p>组合类的方式可以是继承,可以是把对象彼此嵌套以组成<code>复合对象</code></p>
<p>当嵌入的对象比直接定制隐藏需要与容器之间有更多有限的交互时,<code>对象嵌入</code>以及基于其的设计模式还是很合适的</p>
<p>对象嵌入适用于想要跟踪或验证对另一个对象方法的调用的控制器,或可以聚合其他对象当做一个集合对待的类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Embedding-based Manager alternative</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.job = job</span><br><span class="line">		self.pay = pay</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.name.split()[<span class="number">-1</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self,percent)</span>:</span></span><br><span class="line">		self.pay = int(self.pay * (<span class="number">1</span> + percent))</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">'[Person: %s, %s]'</span> % (self.name, self.pay)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, pay)</span>:</span></span><br><span class="line">		self.person = Person(name, <span class="string">'mgr'</span>, pay)		<span class="comment"># Embed a Person object</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span></span><br><span class="line">		self.person.giveRaise(percent + bonus)		<span class="comment"># Intercept and delegate</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> getattr(self.person, attr)			<span class="comment"># Delegate all other attrs</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> str(self.person)						<span class="comment"># Must overload again</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">	sue = Person(<span class="string">'Sue Jones'</span>, <span class="string">'dev'</span>, <span class="number">100000</span>)</span><br><span class="line">	print(bob)</span><br><span class="line">	print(sue)</span><br><span class="line">	print(bob.lastName(), sue.lastName())</span><br><span class="line">	sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line">	print(sue)</span><br><span class="line">	tom = Manager(<span class="string">'Tom Jones'</span>, <span class="number">50000</span>)</span><br><span class="line">	tom.giveRaise(<span class="number">.10</span>)</span><br><span class="line">	print(tom.lastName())</span><br><span class="line">	print(tom)</span><br></pre></td></tr></table></figure>

<p>使用<code>__getattr__</code>运算符重载来拦截未定义属性的访问,并将它们<code>委托</code>给嵌入的对象</p>
<p><code>委托</code>是一种基于复合的结构,它管理一个包装的对象并且把方法调用传递给对象</p>
<p><code>__str__</code>这样的运算符重载方法必须重新定义</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add __str__ overload method for printing object</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.job = job</span><br><span class="line">		self.pay = pay</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.name.split()[<span class="number">-1</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self,percent)</span>:</span></span><br><span class="line">		self.pay = int(self.pay * (<span class="number">1</span> + percent))</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">'[Person: %s, %s]'</span> % (self.name, self.pay)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, pay)</span>:</span></span><br><span class="line">		self.person = Person(name, <span class="string">'mgr'</span>, pay)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span></span><br><span class="line">		self.person.giveRaise(percent + bonus)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> getattr(self.person, attr)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> str(self.person)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">	sue = Person(<span class="string">'Sue Jones'</span>, <span class="string">'dev'</span>, <span class="number">100000</span>)</span><br><span class="line">	print(bob)</span><br><span class="line">	print(sue)</span><br><span class="line">	print(bob.lastName(), sue.lastName())</span><br><span class="line">	sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line">	print(sue)</span><br><span class="line">	tom = Manager(<span class="string">'Tom Jones'</span>, <span class="number">50000</span>)</span><br><span class="line">	tom.giveRaise(<span class="number">.10</span>)</span><br><span class="line">	print(tom.lastName())</span><br><span class="line">	print(tom)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">		self.members = list(args)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">addMember</span><span class="params">(self, person)</span>:</span></span><br><span class="line">		self.members.append(person)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent)</span>:</span></span><br><span class="line">		<span class="keyword">for</span> person <span class="keyword">in</span> self.members:</span><br><span class="line">			person.giveRaise(percent)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">showAll</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">for</span> person <span class="keyword">in</span> self.members:</span><br><span class="line">			print(person)</span><br><span class="line"></span><br><span class="line">development = Department(bob, sue)	<span class="comment"># Embed objects in a composite</span></span><br><span class="line">development.addMember(tom)</span><br><span class="line">development.giveRaise(<span class="number">.10</span>)			<span class="comment"># Runs embedded objects' giveRaise</span></span><br><span class="line">development.showAll()				<span class="comment"># Runs embedded objects' __str__s</span></span><br></pre></td></tr></table></figure>

<p>这里的代码使用了继承和复合,<code>Department</code>是嵌入并控制其他对象的聚合的一个复合体,但是嵌入的<code>Person</code>和<code>Manager</code>对象自身使用继承来定制</p>
<h3 id="在Python-3-0中捕获内置属性"><a href="#在Python-3-0中捕获内置属性" class="headerlink" title="在Python 3.0中捕获内置属性"></a>在Python 3.0中捕获内置属性</h3><p>基于委托的类无法截取并委托像<code>__str__</code>这样的运算符重载方法属性</p>
<p>通用的属性管理器<code>__getattr__</code>与<code>__getattribute__</code>无法截获被隐式调用的<code>__str__</code>等运算符重载方法</p>
<hr>
<h2 id="步骤6-使用内省工具"><a href="#步骤6-使用内省工具" class="headerlink" title="步骤6:使用内省工具"></a>步骤6:使用内省工具</h2><p>编写的类存在的两个问题</p>
<blockquote>
<ul>
<li>打印一个实例对象会显示继承树中顶层的类的名称,然而尽可能地用最低层的类来显示对象可能会更准确些</li>
<li>当前的显示格式只是显示了包含在<code>__str__</code>中的属性而非全部属性,没有考虑未来的目标,未来在代码中引入冗余性时必须做潜在的额外工作</li>
</ul>
</blockquote>
<h3 id="特殊类属性"><a href="#特殊类属性" class="headerlink" title="特殊类属性"></a>特殊类属性</h3><p>Python的内省工具是特殊的属性和函数,允许访问对象实现的一些内部工具</p>
<blockquote>
<ul>
<li><p>内置的<code>instance.__class__</code>属性提供了一个从实例到创建它的类的链接</p>
<p>类有<code>__name__</code>属性提供类的名称,<code>__bases__</code>序列提供了超类的访问,可以使用这些来打印创建一个实例的类的名字,而不是通过硬编码来做到</p>
</li>
<li><p>内置的<code>object.__dict__</code> 属性提供了一个字典,带有一个<code>键/值对</code>,以便每个属性都附加到一个命名空间对象(包括模块、类和实例)</p>
<p>由于它是字典,因此可以获取键的列表、按照键来索引、迭代其键等从而广泛地处理所有的属性,使用这些来打印出任何实例的每个属性,而不是在定制显示中硬编码</p>
</li>
</ul>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> person <span class="keyword">import</span> Person</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(bob)									<span class="comment"># Show bob's __str__</span></span><br><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob.__class__								<span class="comment"># Show bob's class and its name</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">person</span>.<span class="title">Person</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">bob</span>.<span class="title">__class__</span>.<span class="title">__name__</span></span></span><br><span class="line"><span class="class">'<span class="title">Person</span>'</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">list</span><span class="params">(bob.__dict__.keys<span class="params">()</span>)</span>					# <span class="title">Attributes</span> <span class="title">are</span> <span class="title">really</span> <span class="title">dict</span> <span class="title">keys</span></span></span><br><span class="line">['name', 'job', 'pay']							# Use list to force list in 3.0</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> bob.__dict__:</span><br><span class="line"><span class="meta">... </span>    print(key, <span class="string">'=&gt;'</span>, bob.__dict__[key])		<span class="comment"># Index manually</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">name =&gt; Bob Smith</span><br><span class="line">job =&gt; None</span><br><span class="line">pay =&gt; 0</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> bob.__dict__:</span><br><span class="line"><span class="meta">... </span>    print(key, <span class="string">'=&gt;'</span>, getattr(bob, key))		<span class="comment"># obj.attr but attr is a var</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">name =&gt; Bob Smith</span><br><span class="line">job =&gt; None</span><br><span class="line">pay =&gt; 0</span><br></pre></td></tr></table></figure>

<p>如果实例的类定义了<code>__slots__</code>而实例没有存储在<code>__dict__</code>字典中,实例的一些属性也是可以访问的,因为属性存储在<code>__slots__</code></p>
<h3 id="一种通用显示工具"><a href="#一种通用显示工具" class="headerlink" title="一种通用显示工具"></a>一种通用显示工具</h3><p>在超类中把接口投入使用,以显示准确的类名并格式化显示任何实例的所有属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File classtools.py</span></span><br><span class="line"><span class="string">"Assorted class utilities and tools"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AttrDisplay</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Provides an inheritable print overload method that displays</span></span><br><span class="line"><span class="string">	instances with their class names and a name=value pair for </span></span><br><span class="line"><span class="string">	each attribute stored on the instance itself (but not attrs</span></span><br><span class="line"><span class="string">	inherited from its classes). Can be mixed into any class,</span></span><br><span class="line"><span class="string">	and will work on any instance.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">gatherAttrs</span><span class="params">(self)</span>:</span></span><br><span class="line">		attrs = []</span><br><span class="line">		<span class="keyword">for</span> key <span class="keyword">in</span> sorted(self.__dict__):</span><br><span class="line">			attrs.append(<span class="string">'%s=%s'</span> % (key, getattr(self, key)))</span><br><span class="line">		<span class="keyword">return</span> <span class="string">', '</span>.join(attrs)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">'[%s: %s]'</span> % (self.__class__.__name__, self.gatherAttrs())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">TopTest</span><span class="params">(AttrDisplay)</span>:</span></span><br><span class="line">		count = <span class="number">0</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">			self.attr1 = TopTest.count</span><br><span class="line">			self.attr2 = TopTest.count+<span class="number">1</span></span><br><span class="line">			TopTest.count += <span class="number">2</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">SubTest</span><span class="params">(TopTest)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">	X, Y = TopTest(), SubTest()</span><br><span class="line">	print(X)		<span class="comment"># Show all instance attrs</span></span><br><span class="line">	print(Y)		<span class="comment"># Show lowest class name</span></span><br></pre></td></tr></table></figure>

<p>文档字符串可以放在简单函数和模块的顶部,也可以防止类及其方法的开始处供<code>help</code>函数和<code>PyDoc</code>工具提取和显示</p>
<p>由于<code>__str__</code>,<code>print</code>重载用于通用的内省工具,对任何实例有效,不管实例的属性集合是什么</p>
<p>由于这是一个类,可以自动变成一个公用的工具,得益于继承,可以混合到想要使用它显示格式的任何类中</p>
<p>如果想要改变实例的显示,只需要修改这个类,继承其<code>__str__</code>的每一个类都将自动选择新的格式</p>
<h3 id="实例与类属性的关系"><a href="#实例与类属性的关系" class="headerlink" title="实例与类属性的关系"></a>实例与类属性的关系</h3><p><code>self</code>的<code>__dict__</code>中包含了附加到继承树底部<code>self</code>对象中的属性,而没有包含继承的类的属性</p>
<p>继承的类属性只是附加到了类,而没有向下复制到实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> person <span class="keyword">import</span> Person</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(bob.__dict__.keys())</span><br><span class="line">[<span class="string">'name'</span>, <span class="string">'job'</span>, <span class="string">'pay'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(bob.__class__.__dict__.keys())</span><br><span class="line">[<span class="string">'__module__'</span>, <span class="string">'__init__'</span>, <span class="string">'lastName'</span>, <span class="string">'giveRaise'</span>, <span class="string">'__str__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'__doc__'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(bob)</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'giveRaise'</span>, <span class="string">'job'</span>, <span class="string">'lastName'</span>, <span class="string">'name'</span>, <span class="string">'pay'</span>]</span><br></pre></td></tr></table></figure>

<p>若想包含继承属性,可以通过<code>__class__</code>链接爬升到实例的类,使用这里的<code>__dict__</code>去获取类属性,然后迭代类的<code>__bases__</code>属性爬升到更高的超类</p>
<p>在实例上运行内置的<code>dir</code>调用有同样的效果,因为<code>dir</code>结果在排序的结果列表中包含了继承的名称</p>
<p>Python 3.0的<code>dict.keys</code>不是一个列表,需要<code>list</code>调用</p>
<p>Python 3.0的<code>dir</code>返回的更多关于运算符重载的名称</p>
<h3 id="工具类的命名考虑"><a href="#工具类的命名考虑" class="headerlink" title="工具类的命名考虑"></a>工具类的命名考虑</h3><p>通用性工具的类必须注意与客户类潜在的无意的命名冲突</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopTest</span><span class="params">(AttrDisplay)</span>:</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.attr1 = TopTest.count</span><br><span class="line">		self.attr2 = TopTest.count+<span class="number">1</span></span><br><span class="line">		TopTest.count += <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gatherAttrs</span><span class="params">(self)</span>:</span>		<span class="comment"># Replaces method in AttrDisplay!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Spam'</span></span><br></pre></td></tr></table></figure>

<p>若子类定义了相同名称的类可能会覆盖当前的类</p>
<p>为了减少像这样名称冲突的机会,对于不想做其他用途的方法可以添加一个<strong>单个下划线</strong>的前缀</p>
<p>在方法名前使用<strong>两个下划线</strong>符号会被自动拓展为包含类的名称,称为<code>伪私有类属性</code></p>
<h3 id="类的最终形式"><a href="#类的最终形式" class="headerlink" title="类的最终形式"></a>类的最终形式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File person.py (final)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> classtools <span class="keyword">import</span> AttrDisplay			<span class="comment"># Use generic display tool</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(AttrDisplay)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Create and process person records</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.job = job</span><br><span class="line">		self.pay = pay</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span>						<span class="comment"># Assumes last is last</span></span><br><span class="line">		<span class="keyword">return</span> self.name.split()[<span class="number">-1</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self,percent)</span>:</span>			<span class="comment"># Percent must be 0..1</span></span><br><span class="line">		self.pay = int(self.pay * (<span class="number">1</span> + percent))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	A customized Person with special requirments</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, pay)</span>:</span></span><br><span class="line">		Person.__init__(self, name, <span class="string">'mgr'</span>, pay)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span></span><br><span class="line">		Person.giveRaise(self, percent + bonus)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">	sue = Person(<span class="string">'Sue Jones'</span>, <span class="string">'dev'</span>, <span class="number">100000</span>)</span><br><span class="line">	print(bob)</span><br><span class="line">	print(sue)</span><br><span class="line">	print(bob.lastName(), sue.lastName())</span><br><span class="line">	sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line">	print(sue)</span><br><span class="line">	tom = Manager(<span class="string">'Tom Jones'</span>, <span class="number">50000</span>)</span><br><span class="line">	tom.giveRaise(<span class="number">.10</span>)</span><br><span class="line">	print(tom.lastName())</span><br><span class="line">	print(tom)</span><br></pre></td></tr></table></figure>

<p>从模块中导入通用工具以使用它,使用继承将其混合到顶层类中,并删除<code>__str__</code>方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% python person.py</span><br><span class="line">[Person: job=<span class="literal">None</span>, name=Bob Smith, pay=<span class="number">0</span>]</span><br><span class="line">[Person: job=dev, name=Sue Jones, pay=<span class="number">100000</span>]</span><br><span class="line">Smith Jones</span><br><span class="line">[Person: job=dev, name=Sue Jones, pay=<span class="number">110000</span>]</span><br><span class="line">Jones</span><br><span class="line">[Manager: job=mgr, name=Tom Jones, pay=<span class="number">60000</span>]</span><br></pre></td></tr></table></figure>

<p>通用工具将显示对象的所有属性</p>
<p>每个对象都显示其类树中最低的类的名称</p>
<hr>
<h2 id="步骤7-最后一步-把对象存储到数据库中"><a href="#步骤7-最后一步-把对象存储到数据库中" class="headerlink" title="步骤7(最后一步):把对象存储到数据库中"></a>步骤7(最后一步):把对象存储到数据库中</h2><p>创建的对象并不是真正的数据库记录而是内存中的临时性对象,关闭Python后实例将消失</p>
<p>使用Python一项叫做<code>对象持久化</code>的功能可以让对象在创建他们的程序退出后依然存在</p>
<h3 id="PIckle和Shelve"><a href="#PIckle和Shelve" class="headerlink" title="PIckle和Shelve"></a>PIckle和Shelve</h3><p>对象持久化通过3个标准的库模块来实现</p>
<blockquote>
<ul>
<li><p>pickle</p>
<p>任意Python对象和字节串之间的序列化</p>
</li>
<li><p>dbm</p>
<p>实现一个可通过键访问的文件系统以存储字符串</p>
</li>
<li><p>shelve</p>
<p>使用另两个模块按照键把Python对象存储到一个文件中</p>
</li>
</ul>
</blockquote>
<p><code>pickle</code>模块是一种通用的对象格式化工具,对于内存中几乎任何的Python对象都能转换为字节串,这个字节串可以随后用来在内存中重新构建最初的对象</p>
<p>通过在文件中存储一个对象的<code>pickle</code>字符串可以有效地使其持久化,随后载入到程序并进行<code>unpickle</code>操作可以重新创建最初的对象</p>
<p><code>shelve</code>模块提供了一个额外的层结构,允许按照键来存储<code>pickle</code>处理后的对象</p>
<p><code>shelve</code>使用<code>pickle</code>把一个对象转换为其<code>pickle</code>化的字符串,并将其存储在一个<code>dbm</code>文件中的<strong>键</strong>之下,随后载入的时候,<code>shelve</code>通过<strong>键</strong>获取<code>pickle</code>化的字符串,并用<code>pickle</code>在内存中重新创建最初的对象</p>
<p><code>shelve</code>的<code>pickle</code>化的对象类似于字典,通过键索引来访问、指定键来存储,区别在于开始必须打开<code>shelve</code>兵器修改后必须关闭它</p>
<h3 id="在shelve数据库中存储对象"><a href="#在shelve数据库中存储对象" class="headerlink" title="在shelve数据库中存储对象"></a>在shelve数据库中存储对象</h3><p>编写脚本,把类的对象存储到<code>shelve</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> person					<span class="comment"># Load class with import</span></span><br><span class="line">bob = person.Person(...)		<span class="comment"># Go through module name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> person <span class="keyword">import</span> Person		<span class="comment"># Load class with from</span></span><br><span class="line">bob = Person(...)				<span class="comment"># Use name directly</span></span><br></pre></td></tr></table></figure>

<p>通过两种方式导入类以便创建一些实例来存储</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File makedb.py: store Person objects on  a shelve database</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> person <span class="keyword">import</span> Person, Manager		<span class="comment"># Load our classes</span></span><br><span class="line">bob = Person(<span class="string">'Bob Smith'</span>)				<span class="comment"># Re-create objects to be stored</span></span><br><span class="line">sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">tom = Manager(<span class="string">'Tom Jones'</span>, <span class="number">50000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">db = shelve.open(<span class="string">'persondb'</span>)			<span class="comment"># Filename where objects are stored</span></span><br><span class="line"><span class="keyword">for</span> object <span class="keyword">in</span> (bob, sue, tom):			<span class="comment"># Use object's name attr as key</span></span><br><span class="line">	db[object.name] = object			<span class="comment"># Store object on shelve by key</span></span><br><span class="line">db.close()								<span class="comment"># Close after making changes</span></span><br></pre></td></tr></table></figure>

<p>导入<code>shelve</code>模块,用一个外部文件名打开一个新的<code>shelve</code>对象,把对象赋给<code>shelve</code>中的键,操作完毕后关闭<code>shelve</code>对象</p>
<p>在<code>shelve</code>中,<code>键</code>是唯一的,可以是任何的<strong>字符串</strong>,针对每个键只存储一个值,这个值可以是几乎任何类型的Python对象,包括内置对象和用户定义的类实例,以及所有这些嵌套式的组合</p>
<h3 id="交互地探索shelve"><a href="#交互地探索shelve" class="headerlink" title="交互地探索shelve"></a>交互地探索shelve</h3><p>运行后当前目录下会出现一个或多个<code>persondb</code>开头的文件作为数据库,这是一个二进制散列文件,其中内容对于shelve模块以外的环境没有太大的意义</p>
<p>与内置<code>open</code>函数一样,<code>shelve.open()</code>中的文件名也是相对于当前工作目录的,除非它包含了一个目录路径</p>
<p>文件实现为一个通过键访问的文件,其中包含了Python对象的pickle化的表示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Directory listing module: verify files are present</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> glob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'person*'</span>)</span><br><span class="line">[<span class="string">'person.py'</span>, <span class="string">'persondb.db'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Type the file: text mode for string,binary mode for bytes</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(open(<span class="string">'persondb.db'</span>).read())</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/codecs.py"</span>, line <span class="number">321</span>, <span class="keyword">in</span> decode</span><br><span class="line">    (result, consumed) = self._buffer_decode(data, self.errors, final)</span><br><span class="line">UnicodeDecodeError: <span class="string">'utf-8'</span> codec can<span class="string">'t decode byte 0xd2 in position 11: invalid continuation byte</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print(open('</span>persondb.d<span class="string">b','</span>r<span class="string">b').read())</span></span><br><span class="line"><span class="string">b'</span>\x00\x06\x15a\x00\x00\x00\x02\x00\x00\x04\xd2\x00\x00\x10\x00\x00\x00\x00\x0c\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x00\x08\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00(\x00\x00\x00\x03\x00\x00\x00\x01\x95n&#125;\xe3<span class="string">'</span></span><br></pre></td></tr></table></figure>

<p>这些文件在不同的平台上有所不同,并且不是一个用户友好的数据库界面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shelve</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = shelve.open(<span class="string">'persondb'</span>)			<span class="comment"># Reopen the shelve</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(db)									<span class="comment"># Three 'records' stored</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(db.keys())							<span class="comment"># keys is the index</span></span><br><span class="line">[<span class="string">'Bob Smith'</span>, <span class="string">'Sue Jones'</span>, <span class="string">'Tom Jones'</span>]		<span class="comment"># list to make a list in 3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob = db[<span class="string">'Bob Smith'</span>]					<span class="comment"># Fetch bob by key</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(bob)								<span class="comment"># Runs __str__ from AttrDisplay</span></span><br><span class="line">[Person: job=<span class="literal">None</span>, name=Bob Smith, pay=<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob.lastName()							<span class="comment"># Runs lastName from Person</span></span><br><span class="line"><span class="string">'Smith'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> db:							<span class="comment"># Iterate, fetch, print</span></span><br><span class="line"><span class="meta">... </span>    print(key, <span class="string">'=&gt;'</span>, db[key])</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Bob Smith =&gt; [Person: job=None, name=Bob Smith, pay=0]</span><br><span class="line">Sue Jones =&gt; [Person: job=dev, name=Sue Jones, pay=100000]</span><br><span class="line">Tom Jones =&gt; [Manager: job=mgr, name=Tom Jones, pay=50000]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> sorted(db):					<span class="comment"># Iterate by sorted keys</span></span><br><span class="line"><span class="meta">... </span>    print(key, <span class="string">'=&gt;'</span>, db[key])</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Bob Smith =&gt; [Person: job=None, name=Bob Smith, pay=0]</span><br><span class="line">Sue Jones =&gt; [Person: job=dev, name=Sue Jones, pay=100000]</span><br><span class="line">Tom Jones =&gt; [Manager: job=mgr, name=Tom Jones, pay=50000]</span><br></pre></td></tr></table></figure>

<p>在这里交互提示模式有效地成为数据库客户端</p>
<p>由于<code>shelve</code>是包含了Python对象的对象,可以用常规的Python语法和开发模式来处理</p>
<p>载入或使用存储的对象时不一定必须导入所属的类,即使作用域中没有相关的类也可以调用对象相关的方法,这是因为Python对一个类实例进行了<code>pickle</code>操作时记录了<code>self</code>实例属性以及实例所属的类的名字和类的位置,当随后从<code>shelve</code>中获取实例并对其<code>unpickle</code>时,Python将自动地重新导入该类并将实例连接到它</p>
<p>这种方法的结果是导入类实例时会自动获取其所有的类行为,只有在创建新实例时才必须导入类</p>
<blockquote>
<ul>
<li><p>缺点</p>
<p>当随后载入一个实例的时候,类及其模块的文件都必须导入</p>
<p>更正式地说,可以pickle的类必须在一个模块文件的顶部编码,而这个模块文件可以通过<code>sys.path</code>模块的查找路径所列出的目录来访问</p>
<p>由于这一外部模块文件的需求,一些应用程序选择pickle更简单的对象</p>
</li>
<li><p>优点</p>
<p>该类的实例再次载入时,对类的源代码文件的修改会自动选取,并改变存储的对象的行为</p>
</li>
</ul>
</blockquote>
<h3 id="更新shelve中的对象"><a href="#更新shelve中的对象" class="headerlink" title="更新shelve中的对象"></a>更新shelve中的对象</h3><p>编写程序,在每次运行的时候更新一个实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File updatedb.py: update Person object on database</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">db = shelve.open(<span class="string">'persondb'</span>)			<span class="comment"># Reopen shelve with same filename</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> sorted(db):					<span class="comment"># Iterate to display database objects</span></span><br><span class="line">	print(key, <span class="string">'\t=&gt;'</span>, db[key])			<span class="comment"># Printes with custom format</span></span><br><span class="line"></span><br><span class="line">sue = db[<span class="string">'Sue Jones'</span>]					<span class="comment"># Index by key to fetch</span></span><br><span class="line">sue.giveRaise(<span class="number">.10</span>)						<span class="comment"># Updata in memory using class method</span></span><br><span class="line">db[<span class="string">'Sue Jones'</span>] = sue					<span class="comment"># Assign to key to updata in shelve</span></span><br><span class="line">db.close()								<span class="comment"># Close after making changes</span></span><br></pre></td></tr></table></figure>

<p>数据库中的实例可以直接使用<code>__str__</code>重载方法打印对象,调用<code>giveRaise</code>方法增加之前写入的值</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">% python updatedb.py</span><br><span class="line">Bob Smith 	=&gt; [Person: job=None, name=Bob Smith, pay=0]</span><br><span class="line">Sue Jones 	=&gt; [Person: job=dev, name=Sue Jones, pay=100000]</span><br><span class="line">Tom Jones 	=&gt; [Manager: job=mgr, name=Tom Jones, pay=50000]</span><br><span class="line"></span><br><span class="line">% python updatedb.py</span><br><span class="line">Bob Smith 	=&gt; [Person: job=None, name=Bob Smith, pay=0]</span><br><span class="line">Sue Jones 	=&gt; [Person: job=dev, name=Sue Jones, pay=110000]</span><br><span class="line">Tom Jones 	=&gt; [Manager: job=mgr, name=Tom Jones, pay=50000]</span><br><span class="line"></span><br><span class="line">% python updatedb.py</span><br><span class="line">Bob Smith 	=&gt; [Person: job=None, name=Bob Smith, pay=0]</span><br><span class="line">Sue Jones 	=&gt; [Person: job=dev, name=Sue Jones, pay=121000]</span><br><span class="line">Tom Jones 	=&gt; [Manager: job=mgr, name=Tom Jones, pay=50000]</span><br><span class="line"></span><br><span class="line">% python updatedb.py</span><br><span class="line">Bob Smith 	=&gt; [Person: job=None, name=Bob Smith, pay=0]</span><br><span class="line">Sue Jones 	=&gt; [Person: job=dev, name=Sue Jones, pay=133100]</span><br><span class="line">Tom Jones 	=&gt; [Manager: job=mgr, name=Tom Jones, pay=50000]</span><br></pre></td></tr></table></figure>

<p>运行几次后可以看到对象值的改变</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shelve</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = shelve.open(<span class="string">'persondb'</span>)		<span class="comment"># Reopen database</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec = db[<span class="string">'Sue Jones'</span>]				<span class="comment"># Fetch object by key</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(rec)</span><br><span class="line">[Person: job=dev, name=Sue Jones, pay=<span class="number">146410</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec.lastName()</span><br><span class="line"><span class="string">'Jones'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec.pay</span><br><span class="line"><span class="number">146410</span></span><br></pre></td></tr></table></figure>

<p>可以在交互模式中验证脚本的作用</p>
<hr>
<h2 id="未来方向"><a href="#未来方向" class="headerlink" title="未来方向"></a>未来方向</h2><p>本章看到了Python的OOP所有基本机制的实际运作,并且学习了在代码中避免冗余性及相关可维护性问题的方法,还构建了功能完备的类来完成实际的工作,还通过把对象存储到Python的<code>shelve</code>中创建正事的数据库记录使信息持久地存在</p>
<p>Python的工具</p>
<blockquote>
<ul>
<li><p>GUI</p>
<p>目前能够使用交互提示的基于命令行的界面来处理数据库和脚本,可以扩展对象数据库的易用性,添加一个图形化的用户界面来浏览和更新数据库记录</p>
<p>可以构建能够移植到Python的<code>tkinter</code>的GUI或者可以移植到<code>WxPython</code>和<code>PyQt</code>第三方工具的GUI</p>
<p><code>tkinter</code>是Python自带的,可以快速地构建简单的GUI,并且是学习GUI编程技巧的理想工具</p>
<p><code>WxPython</code>和<code>PyQt</code>使用起来更加复杂,但是往往能创建更高级的GUI</p>
</li>
<li><p>Web站点</p>
<p>可以实现一个Web站点来浏览和更新记录,而不是使用GUI和交互式提示</p>
<p>Web站点可以用Python自带的基本CGI脚本编程工具来构建,也可以用像<code>Django</code>、<code>TurboGears</code>、<code>Pylons</code>、<code>web2Py</code>、<code>Zope</code>或<code>Google&#39;s App Engine</code>这样的全功能的第三方Web开发框架来完成</p>
<p>在Web上,数据可以仍然存储在<code>shelve.pickle</code>文件或其他基于Python的媒介中,处理它的脚本直接自动在服务器上运行,以响应来自Web浏览器和其他客户端的请求,并且生成HTML来与一个用户交互,而不是直接或通过框架API与用户交互</p>
</li>
<li><p>Web服务</p>
<p>尽管Web客户端往往可以解析来自Web站点的回复中的信息,还可以用更直接的方式来从Web获取记录:通过像<br><code>SOAP</code>或<code>XML-RPC</code>这样的一个Web服务接口来调用Python自身或第三方开源域所支持的API</p>
<p>这样的API以一种更加直接的形式返回数据,而不是嵌入一个回应页面的HTML中</p>
</li>
<li><p>数据库</p>
<p>如果数据库变得更大或者更关键,可以将其从<code>shelve</code>转移到开源的<code>ZODB</code>面向对象数据库系统(OODB),或者是像<code>MySQL</code>、<code>Oracle</code>、<code>PostgreSQL</code>或<code>SQLite</code>这样的一个更传统的基于<code>SQL</code>的数据库系统中</p>
<p>Python自身带有一个内置的SQLite数据库,但是其他的开源选项也可以从Web上免费获得</p>
<p><code>ZODB</code>类似于Python的<code>shelve</code>,但是它解决了很多局限性,支持较大的数据库、并发更新、事务处理和内存中修改自动写人</p>
<p>像<code>MySQL</code>这样基于<code>SQL</code>的系统,为数据库存储提供了企业级的工具,并且可以在一个Python脚本中直接使用</p>
</li>
<li><p>ORM</p>
<p>如果需要迁移到关系数据库中进行存储,不一定要牺牲Python的OOP工具,像<code>SQLObject</code>和<code>SQLAlchemy</code>这样的对象关系映射器(ORM)可以自动实现关系表和行与Python的类和实例之间的映射,这样就可以使用常规的Python类语法来处理存储的数据</p>
<p>这种方法为<code>shelve</code>和<code>ZODB</code>提供了一个到<code>OODB</code>的替代,使得可以利用关系数据库和Python的类模型的双重威力</p>
</li>
</ul>
</blockquote>
<hr>
<h2 id="本章习题-2"><a href="#本章习题-2" class="headerlink" title="本章习题"></a>本章习题</h2><ol>
<li><p>当我们从<code>shelve</code>获取一个<code>Manager</code>对象并打印它的时候,显示格式逻辑来自何处</p>
<blockquote>
<p>在类的最终版本中,<code>Manager</code>最终从单独的<code>classtools</code>模块的<code>AttrDisplay</code>继承其<code>__str__</code>打印方法 <code>Manager</code>自己没有一个这样的方法,因此,继承查找爬升到其<code>Person</code>超类,由于那里也没有<code>__str__</code>,查找继续向上爬升,并在<code>AttrDisplay</code>中找到它</p>
<p>类语句的标题行中的圆括号中列出的类名,提供了到更高的超类的链接</p>
</blockquote>
</li>
<li><p>当从一个<code>shelve</code>获取一个<code>Person</code>对象而没有导入其模块的时候,该对象如何知道它有一个<code>giveRaise</code>方法可供调用</p>
<blockquote>
<p>当实例稍后载入内存中的时候,<code>shelve</code> 使用<code>pickle</code>自动地把该实例重新连接到创建它的类</p>
<p>Python从其模块内部重新导入该类,创建一个带有其存储的属性的实例,并且把实例的<code>__class__</code>连接设置到指向其最初的类<br>通过这种方式,载入实例自动获取所有其他最初方法(如<code>lastName</code>、<code>giveRaise</code>和<code>__str__</code>),即便没有把实例的类导入作用域</p>
</blockquote>
</li>
<li><p>为什么把处理放入方法中而不是在类之外硬编码如此重要</p>
<blockquote>
<p>把处理放入方法中很重要,这样一来,未来只有一个副本需要修改,并且方法可以在任何实例之上运行</p>
<p>这就是Python封装的概念,把逻辑封装到接口背后,更好地支持未来的代码维护</p>
<p>如果没有这么做,就会产生代码冗余性,将来代码修改的时候工作就会加倍</p>
</blockquote>
</li>
<li><p>为什么通过子类而不是复制并修改最初的代码来定制会更好</p>
<blockquote>
<p>用子类定制可以减少开发工作</p>
<p>我们可以通过编写新的子类利用已有的方法来很容易地扩展以前的工作</p>
<p>这比每次从头开始编写要好很多,也好过引入多个冗余的代码副本,它们未来可能全部都必须更新</p>
</blockquote>
</li>
<li><p>为什么回调一个超类的方法来运行默认操作而不是在子类中复制和修改其代码要更好</p>
<blockquote>
<p>不管是什么样的情况,复制和修改代码会使未来的潜在工作翻倍</p>
<p>复制代码会产生冗余性,当代码改进的时候这是一个主要的问题</p>
</blockquote>
</li>
<li><p>为什么使用<code>__dict__</code> 这样的工具来允许一般性地处理对象,而不是为类的每个类型编写更多定制代码要更好</p>
<blockquote>
<p>通用性工具可以避免硬编码解决方案,而后者必须随着时间推移和类的改进保持与类的其他部分同步</p>
<p>一个通用的打印方法只由所有出现的类继承,并且只需要在通用版本中修改,从通用类继承的所有类都会保持同步</p>
<p>删除代码冗余性会减少未来的开发工作,这是类带来的主要好处之一</p>
</blockquote>
</li>
<li><p>一般来说,何时可以选择使用对象嵌入和组合而不是继承</p>
<blockquote>
<p>与直接定制相比较,继承是最佳的代码扩展</p>
<p>对于多个对象聚合到一个完整的对象,并且由一个控制器层类主导的情况,组合非常实用<br>继承向上传递调用以实现复用,组合向下传递以实现委托</p>
<p>继承和组合不是互斥的,嵌入一个控制器中的对象,往往其本身是基于继承来定制的</p>
</blockquote>
</li>
<li><p>如何修改本章中的类,从而在Python中实现一个个人联络信息数据库</p>
<blockquote>
<p>本章中的类可以用作样本代码来实现各种类型的数据库</p>
<p>基本上,可以修改构造函数来记录不同的属性,并提供各种适用于目标应用程序的方法,从而改变用途<br>例如,可以使用诸如name、address、birthday、phone、email等属性来构建一个联系人数据库,并且可以采用适合这一用途的方法</p>
<p>这里的大多数<code>shelve</code>数据库代码都可以用来存储对象,只需要稍作修改即可</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="第二十八章-类代码编写细节"><a href="#第二十八章-类代码编写细节" class="headerlink" title="第二十八章 类代码编写细节"></a>第二十八章 类代码编写细节</h1><blockquote>
<ul>
<li>深入探索OOP机制</li>
<li>深入学习类、方法和继承</li>
<li>讲解抽象超类、类数据属性、命名空间和链接、超类方法和构造函数手动调试的概念,并进行扩展</li>
<li>总结Python中命名空间的概念</li>
</ul>
</blockquote>
<hr>
<h2 id="class语句"><a href="#class语句" class="headerlink" title="class语句"></a>class语句</h2><p><code>class</code>语句是对象的创建者并且是一个隐含的赋值运算,执行时它会产生类对象并把其引用值存储在变量名中</p>
<p><code>class</code>语句是真正的可执行代码,直到Python抵达并运行定义的<code>class</code>语句前类都不存在</p>
<h3 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h3><p><code>class</code>是复合语句,超类列在类名称之后的括号内,由逗号相隔,其缩进语句的主体出现在头一行下边</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;<span class="title">name</span>&gt;<span class="params">(superclass, ...)</span>:</span>	<span class="comment"># Assign to name</span></span><br><span class="line">    data = value				<span class="comment"># Shared class data</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self, ...)</span>:</span>		<span class="comment"># Methods</span></span><br><span class="line">        slef.member = value		<span class="comment"># Per-instance data</span></span><br></pre></td></tr></table></figure>

<p>在<code>class</code>语句内,任何赋值语句都会产生类属性,还有特殊名称方法重载运算符</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>类是命名空间,也是定义变量名的工具,把数据和逻辑导出给客户端</p>
<p>当Python执行<code>class</code>语句时,从头至尾执行其主体内的所有语句,进行的赋值运算会在类作用域中创建变量名,成为对应的类对象内的属性</p>
<blockquote>
<ul>
<li><code>class</code>语句是本地作用域,由内嵌的赋值语建立的变量名就存在于这个本地作用域内</li>
<li><code>class</code>语句内赋值的变量名会变成类对象的属性</li>
</ul>
</blockquote>
<p>类的命名空间也是Python继承的基础,类或实例对象找不到所引用的属性时呼从其他类中获取</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">SharedData</span>:</span></span><br><span class="line"><span class="meta">... </span>    spam = <span class="number">42</span>		<span class="comment"># Generates a class data attribute</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = ShareData()		<span class="comment"># Make two instances</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = ShareData()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.spam, y.spam		<span class="comment"># They inherit and share 'spam'</span></span><br><span class="line">(<span class="number">42</span>, <span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.spam, y.spam, ShareData.spam</span><br><span class="line">(<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.spam = <span class="number">88</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.spam, y.spam, ShareData.spam</span><br><span class="line">(<span class="number">88</span>, <span class="number">99</span>, <span class="number">99</span>)</span><br></pre></td></tr></table></figure>

<p>在<code>class</code>内赋值的变量名会创建类属性,内嵌的<code>def</code>语句会创建类方法,其他赋值语句也可制作属性</p>
<p>可通过类名称修改它或是通过实例或类引用它</p>
<p>对实例的属性进行赋值运算会在该实例内创建或修改变量名而不是在共享的类中,继承搜索只会在属性引用时发生,而不是在赋值运算时发生</p>
<p>继承搜索会查找变量名,也可以通过直接读取所需要的对象获得树中任何地方的属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MixedNames</span>:</span>								<span class="comment"># Define class</span></span><br><span class="line"><span class="meta">... </span>    data = <span class="string">'spam'</span>								<span class="comment"># Assign class attr</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span>					<span class="comment"># Assign method name</span></span><br><span class="line"><span class="meta">... </span>            self.data = value					<span class="comment"># Assign instance attr</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            print(self.data, MixedNames.data)	<span class="comment"># Instance attr, class attr</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = MixedNames(<span class="number">1</span>)								<span class="comment"># Make two instance</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = MixedNames(<span class="number">2</span>)								<span class="comment"># Each has its own data</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.display(); y.display()						<span class="comment"># self.data differs, MixedNames.data is the same</span></span><br><span class="line"><span class="number">1</span> spam</span><br><span class="line"><span class="number">2</span> spam</span><br></pre></td></tr></table></figure>

<p>类中的赋值语句创建了类作用域内的变量名,成为类对象的属性</p>
<p>类属性会被继承,从而被所有没有该属性的实例对象共享</p>
<p><code>data</code>变量名存在于实例对象内以及在实例继承的类中</p>
<p>把属性储存在不同对象内决定其可见范围,附加在类上时变量名是共享的,附加在实例上时变量名属于每个实例</p>
<hr>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法是由<code>def</code>语句建立的函数对象,位于<code>class</code>语句的主体内,替实例对象提供了要继承的行为</p>
<p>方法的工作方式与简单函数完全一致,但是方法的第一个参数总是接受方法调用的隐性主体</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance.method(args, ...)</span><br></pre></td></tr></table></figure>

<p>python会自动把实例对象的调用对应到类方法函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>.<span class="title">method</span><span class="params">(instance, args, ...)</span></span></span><br></pre></td></tr></table></figure>

<p><code>class</code>通过Python继承搜索流程找出方法名称所在之处</p>
<p>在类方法中,按惯例第一个参数通常称为<code>self</code>,这个参数给方法提供了一个钩子从而返回调用的主体,需要在程序代码中明确写出</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NextClass</span>:</span>				<span class="comment"># Define class</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">printer</span><span class="params">(self, text)</span>:</span>	<span class="comment"># Define method</span></span><br><span class="line">		self.message = text		<span class="comment"># Change instance</span></span><br><span class="line">		print(self.message)		<span class="comment"># Access instance</span></span><br></pre></td></tr></table></figure>

<p><code>printer</code>引用函数对象</p>
<p>由于<code>printer</code>是在<code>class</code>语句的作用域中赋值,所以附加为类对象的属性,由类创建的每个实例所继承</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = NextClass()				<span class="comment"># Make instance</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.printer(<span class="string">'instance call'</span>)	<span class="comment"># Call its method</span></span><br><span class="line">instance call</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.message					<span class="comment"># Instance changed</span></span><br><span class="line"><span class="string">'instance call'</span></span><br></pre></td></tr></table></figure>

<p>当通过实例进行点号运算调用它时,<code>printer</code>会先通过继承将其定位,然后它的<code>self</code>参数会自动赋值为实例对象,<code>text</code>参数获得调用时传入的字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>NextClass.printer(x, <span class="string">'class call'</span>)		<span class="comment"># Direct class call</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">call</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">x</span>.<span class="title">message</span>								# <span class="title">Instance</span> <span class="title">changed</span> <span class="title">again</span></span></span><br><span class="line"><span class="class">'<span class="title">class</span> <span class="title">call</span>'</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">NextClass</span>.<span class="title">printer</span><span class="params">(<span class="string">'bad call'</span>)</span></span></span><br><span class="line"><span class="class"><span class="title">Traceback</span> <span class="params">(most recent call last)</span>:</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: printer() missing <span class="number">1</span> required positional argument: <span class="string">'text'</span></span><br></pre></td></tr></table></figure>

<p>方法能通过实例或类本身两种方式其中的任意一种进行调用</p>
<p>如果尝试不带任何实例调用的方法,就会得到错误</p>
<h3 id="调用超类构造函数"><a href="#调用超类构造函数" class="headerlink" title="调用超类构造函数"></a>调用超类构造函数</h3><p>如果要保证子类的方法也会执行超类方法的逻辑,一般要通过子类明确地调用超类的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">		...default code...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span><span class="params">(Super)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">		Super.__init__(self, x)		<span class="comment"># Run superclass __init__</span></span><br><span class="line">		...custom code...			<span class="comment"># Do my init actions</span></span><br></pre></td></tr></table></figure>

<p>没有这样的调用子类会完全取代超类的构造函数</p>
<h3 id="其他方法调用的可能性"><a href="#其他方法调用的可能性" class="headerlink" title="其他方法调用的可能性"></a>其他方法调用的可能性</h3><p>通过类调用方法的模式是扩展继承方法行为的一般基础</p>
<p>通过<code>静态方法</code>可以编写第一参数可以不是实例对象的方法,方法名属于所在类的作用域,可以用来管理类数据</p>
<p><code>类方法</code>调用时接受一个类而不是一个实例,可以用来管理基于每个类的数据</p>
<hr>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><code>class</code>语句的重点是支持变量名继承,继承构成了专有化的基础</p>
<p>使用<code>object.attr</code>形式的表达式时,Python会搜索命名空间树,先从当前对象开始,寻找所能找到的第一个<code>attr</code></p>
<p>在方法中对<code>self</code>属性的引用通用会搜索以<code>self</code>所引用的对象开始的继承树</p>
<h3 id="属性树的构造"><a href="#属性树的构造" class="headerlink" title="属性树的构造"></a>属性树的构造</h3><p>命名空间树的构造以及填入变量名的方式</p>
<blockquote>
<ul>
<li>实例属性是由对方法内<code>self</code>属性进行赋值运算而生成的</li>
<li>类属性是通过<code>class</code>语句内的赋值语句生成的</li>
<li>超类的连接是通过class语句首行的括号内列出的类生成的</li>
</ul>
</blockquote>
<p>结果就是连接实例的属性命名空间到产生它的类,再到类首行中所列出的所有超类</p>
<p>每次以点号运算从实例对象取出属性名称时,Python会向上搜索树,从实例直到超类</p>
<h3 id="继承方法的专有化"><a href="#继承方法的专有化" class="headerlink" title="继承方法的专有化"></a>继承方法的专有化</h3><p>继承树搜索模式变成了将系统专有化的最好方式,因为继承会先在子类寻找变量名,然后才查找超类,子类就可以对超类的属性重新定义来取代默认的行为</p>
<p>子类可以完全<strong>取代</strong>继承的属性,<strong>提供</strong>超类可以找到的属性,并且通过已覆盖的方法回调超类来扩展超类的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Super</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'in Super.method'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Sub</span><span class="params">(Super)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span>						<span class="comment"># Overrrde method</span></span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'starting Sub.method'</span>)	<span class="comment"># Add actions here</span></span><br><span class="line"><span class="meta">... </span>            Super.method(self)				<span class="comment"># Run default action</span></span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'ending Sub.method'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Super()									<span class="comment"># Make a Super instance</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.method()									<span class="comment"># Runs Super.method</span></span><br><span class="line"><span class="keyword">in</span> Super.method</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Sub()									<span class="comment"># Make a Sub instance</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.method()									<span class="comment"># Runs Sub.method, calls Super.method</span></span><br><span class="line">starting Sub.method</span><br><span class="line"><span class="keyword">in</span> Super.method</span><br><span class="line">ending Sub.method</span><br></pre></td></tr></table></figure>

<p>子类可以以专有化的版本取代超类的方法函数,通过回调超类的版本可以实现默认的行为,这样实现了扩展超类的行为</p>
<h3 id="类接口技术"><a href="#类接口技术" class="headerlink" title="类接口技术"></a>类接口技术</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'in Super.method'</span>)			<span class="comment"># Default behavior</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">delegate</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.action()						<span class="comment"># Expected to be defined</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inheritor</span><span class="params">(Super)</span>:</span>						<span class="comment"># Inherit method verbatim</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Replacer</span><span class="params">(Super)</span>:</span>						<span class="comment"># Replace method completely</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'in Replacer.method'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extender</span><span class="params">(Super)</span>:</span>						<span class="comment"># Extend method behavior</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'starting Extender.method'</span>)</span><br><span class="line">		Super.method(self)</span><br><span class="line">		print(<span class="string">'ending Extender.method'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span><span class="params">(Super)</span>:</span>						<span class="comment"># Fill in a required method</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'in Provider.action'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	<span class="keyword">for</span> klass <span class="keyword">in</span> (Inheritor, Replacer, Extender):</span><br><span class="line">		print(<span class="string">'\n'</span> + klass.__name__ + <span class="string">'...'</span>)</span><br><span class="line">		klass().method()</span><br><span class="line">	print(<span class="string">'\nProvider...'</span>)</span><br><span class="line">	x = Provider()</span><br><span class="line">	x.delegate()</span><br></pre></td></tr></table></figure>

<p>类作为对象可以放在元组中,并通过通用方式创建实例</p>
<p>类有<code>__name__</code>属性,默认为类首行中的 类名称的字符串</p>
<p>这里示范了一些与超类接口方式的常用技巧</p>
<blockquote>
<ul>
<li><p>Super</p>
<p>定义一个<code>method</code>函数以及在子类中期待一个<code>action</code>的<code>delegate</code></p>
</li>
<li><p>Inheritor</p>
<p>没有提供任何新的变量名,因此会获得<code>Super</code>中定义的一切内容</p>
</li>
<li><p>Replacer</p>
<p>用自己的版本覆盖<code>Super</code>的<code>method</code></p>
</li>
<li><p>Extender</p>
<p>覆盖并回调默认<code>method</code>,从而定制<code>Super</code>的<code>method</code></p>
</li>
<li><p>Provider</p>
<p>实现<code>Super</code>的<code>delegate</code>方法预期的<code>action</code>方法</p>
</li>
</ul>
</blockquote>
<h3 id="抽象超类"><a href="#抽象超类" class="headerlink" title="抽象超类"></a>抽象超类</h3><p>当通过<code>Provider</code>实例调用<code>delegate</code>方法时有两个独立的继承搜索会发生</p>
<blockquote>
<ul>
<li>在最初的<code>x.delegate</code>的调用中Python会搜索<code>Provider</code>实例和它上层的对象,直到在Super中找到<code>delegate</code>方法,实例<code>x</code>会传递给<code>self</code>参数</li>
<li>在<code>Super.delegate</code>方法中,<code>self.action</code>会对<code>self</code>以及它上层的对象启动新的独立继承搜索</li>
</ul>
</blockquote>
<p>这个例子的超类也称作抽象超类,也就是类的部分行为默认是由其子类所提供的</p>
<p>若预期的方法没有在子类中定义,当继承搜索失败时Python会引发未定义变量名的异常,使用<code>assert</code>语句或引发内置的异常<code>NoImplementedError</code>可以使子类的需求更加明确</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">delegate</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.action()</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">assert</span> Flase, <span class="string">'action must be define!'</span>		<span class="comment"># If this version is called</span></span><br><span class="line"></span><br><span class="line">% python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = Super()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.delegate()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">AssertionError: action must be define!</span><br></pre></td></tr></table></figure>

<p><code>assert</code>语句在其表达式运算结果为假时引发带有出错信息的异常</p>
<p>子类没有定义时继承会找到这里的版本触发出错消息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">delegate</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.action()</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">raise</span> NotImplementedError(<span class="string">'action must be define!'</span>)</span><br><span class="line"></span><br><span class="line">% python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Super()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.delegate()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">NotImplementedError: action must be define!</span><br></pre></td></tr></table></figure>

<p>在类的方法中直接产生<code>NotImplemented</code>异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Sub</span><span class="params">(Super)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = Sub()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.delegate()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">NotImplementedError: action must be define!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Sub</span><span class="params">(Super)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(self)</span>:</span> print(<span class="string">'spam'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = Sub()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.delegate()</span><br><span class="line">spam</span><br></pre></td></tr></table></figure>

<p>除非子类提供了期待的方法来替代超类中的默认方法,否则会得到异常</p>
<h3 id="Python-2-6和Python-3-0的抽象超类"><a href="#Python-2-6和Python-3-0的抽象超类" class="headerlink" title="Python 2.6和Python 3.0的抽象超类"></a>Python 2.6和Python 3.0的抽象超类</h3><p>抽象超类可以以特殊的语法来实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span>:</span></span><br><span class="line">	__metaclass__ = ABCMeta</span><br><span class="line"><span class="meta">	@abstractmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self, ...)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>在Python 2.6中,使用一个类属性,以及特殊的@装饰器语法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">	@abstractmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self, ...)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>在Python 3.0中,在一个<code>class</code>头部使用一个关键字参数,以及特殊的@装饰器语法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Super</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">delegate</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            self.action()</span><br><span class="line"><span class="meta">... </span>    @abstractmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = Super()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: Can<span class="string">'t instantiate abstract class Super with abstract methods action</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; class Sub(Super): pass</span></span><br><span class="line"><span class="string">... </span></span><br><span class="line"><span class="string">&gt;&gt;&gt; X = Sub()</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">TypeError: Can'</span>t instantiate abstract <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="title">with</span> <span class="title">abstract</span> <span class="title">methods</span> <span class="title">action</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">class</span> <span class="title">Sub</span><span class="params">(Super)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(self)</span>:</span> print(<span class="string">'spam'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = Sub()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.delegate()</span><br><span class="line">spam</span><br></pre></td></tr></table></figure>

<p>带有一个抽象方法的类是不能继承的,除非其所有的抽象方法都已经在子类中定义了</p>
<p>这种方法可以在试图产生该类的一个实例的时候产生错误,可以用来定义一个期待的接口,在客户类中自动验证</p>
<hr>
<h2 id="命名空间-完整的内容"><a href="#命名空间-完整的内容" class="headerlink" title="命名空间:完整的内容"></a>命名空间:完整的内容</h2><blockquote>
<ul>
<li>无点号运算的变量名与作用域相对应</li>
<li>点号的属性名使用的是对象的命名空间</li>
<li>模块和类的作用域会对对象的命名空间进行初始化</li>
</ul>
</blockquote>
<h3 id="简单变量名-如果赋值就不是全局变量"><a href="#简单变量名-如果赋值就不是全局变量" class="headerlink" title="简单变量名:如果赋值就不是全局变量"></a>简单变量名:如果赋值就不是全局变量</h3><p>无点号的简单变量名遵循<code>LEGB</code>作用域法则</p>
<blockquote>
<ul>
<li><p>赋值语句<code>X = value</code></p>
<p>使变量名成为本地变量:在当前作用域内,创建或改变变量名,除非声明它为全局变量</p>
</li>
<li><p>引用<code>X</code></p>
<p>依次从当前作用域、所有的嵌套的函数中、当前的全局作用域、内置作用域中搜索</p>
</li>
</ul>
</blockquote>
<h3 id="属性名称-对象命名空间"><a href="#属性名称-对象命名空间" class="headerlink" title="属性名称:对象命名空间"></a>属性名称:对象命名空间</h3><p>点号的属性名指的是特定对象的属性,并且遵循模块和类的规则</p>
<p>就类和实例对象而言,引用规则增加了继承搜索这个流程</p>
<blockquote>
<ul>
<li><p>赋值语句<code>object.X = value</code></p>
<p>在进行点号运算的对象的命名空间内创建或修改属性名,继承树的搜索只发生在属性引用时而不是属性的赋值运算时</p>
</li>
<li><p>引用<code>object.X</code></p>
<p>就基于类的对象而言,会在对象内搜索属性名,然后是其上所有可读取的类</p>
<p>对于不是基于类的对象而言,是从对象中直接读取属性名</p>
</li>
</ul>
</blockquote>
<h3 id="Python命名空间的”禅”-赋值将变量名分类"><a href="#Python命名空间的”禅”-赋值将变量名分类" class="headerlink" title="Python命名空间的”禅”:赋值将变量名分类"></a>Python命名空间的”禅”:赋值将变量名分类</h3><p>在Python中,赋值变量名的场所决定了变量名所在的作用域或对象</p>
<p>通常在脚本内每个变量都不应该使用相同的变量名,但是即使这么做Python的命名空间还是会工作,防止在一个环境中所用的变量名无意中和另一个环境中所使用的变量名发生冲突</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># manynames.py</span></span><br><span class="line"></span><br><span class="line">X = <span class="number">11</span>					<span class="comment"># Global (module) name/attribute(X, or manynames.X)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">	print(X)			<span class="comment"># Access global X</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">	X = <span class="number">22</span>				<span class="comment"># Local (function) variable (X, hides module X)</span></span><br><span class="line">	print(X)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">	X = <span class="number">33</span>				<span class="comment"># Class attribute (C.X)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">m</span><span class="params">(self)</span>:</span></span><br><span class="line">		X = <span class="number">44</span>			<span class="comment"># Local variable in method (X)</span></span><br><span class="line">		self.X = <span class="number">55</span>		<span class="comment"># Instance attribute (instance.X)</span></span><br></pre></td></tr></table></figure>

<p>程序中的五个<code>X</code>在五个不同的位置进行赋值,是完全不同的变量,从上至下对<code>X</code>的赋值语句会产生:模块属性(11)、函数内的本地变量(22)、类属性(33)、方法中的本地变量(44)以及实例属性(55)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># manynames.py, continued</span></span><br><span class="line"></span><br><span class="line">X = <span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">	print(X)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">	X = <span class="number">22</span></span><br><span class="line">	print(X)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">	X = <span class="number">33</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">m</span><span class="params">(self)</span>:</span></span><br><span class="line">		X = <span class="number">44</span></span><br><span class="line">		self.X = <span class="number">55</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	print(X)			<span class="comment"># 11: module(a.k.a. manynames.X outside file)</span></span><br><span class="line">	f()					<span class="comment"># 11: global</span></span><br><span class="line">	g()					<span class="comment"># 22: local</span></span><br><span class="line">	print(X)			<span class="comment"># 11: module name unchanged</span></span><br><span class="line"></span><br><span class="line">	obj = C()			<span class="comment"># Make instance</span></span><br><span class="line">	print(obj.X)		<span class="comment"># 33: class name inherited by instance</span></span><br><span class="line"></span><br><span class="line">	obj.m()				<span class="comment"># Attach attribute name X to instance now</span></span><br><span class="line">	print(obj.X)		<span class="comment"># 55: instance</span></span><br><span class="line">	print(C.X)			<span class="comment"># 33 class(a.k.a. obj.X if no X in instance)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">#print(C.m.X)		# FAILS: only visible in method</span></span><br><span class="line">	<span class="comment">#print(g.X)			# FAILS: only visible in function</span></span><br></pre></td></tr></table></figure>

<p>可以通过类来读取其属性,但无法从<code>def</code>语句外读取函数或方法内的局部变量,局部变量只对于在<code>def</code>内的代码可见,也只有当函数调用或方法执行时才会存在于内存中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># otherfile.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> manynames</span><br><span class="line"></span><br><span class="line">X = <span class="number">66</span></span><br><span class="line">print(X)				<span class="comment"># 66: the global here</span></span><br><span class="line">print(manynames.X)		<span class="comment"># 11: globals bnecome attributes after imports</span></span><br><span class="line"></span><br><span class="line">manynames.f()			<span class="comment"># 11: manynames's X, not the one here!</span></span><br><span class="line">manynames.g()			<span class="comment"># 22: local in other file's function</span></span><br><span class="line"></span><br><span class="line">print(manynames.C.X)	<span class="comment"># 33: attribute of class in other module</span></span><br><span class="line">I = manynames.C()</span><br><span class="line">print(I.X)				<span class="comment"># 33: still from class here</span></span><br><span class="line">I.m()</span><br><span class="line">print(I.X)				<span class="comment"># 55: now from instance!</span></span><br></pre></td></tr></table></figure>

<p>可以通过导入文件看到其他模块内的变量名</p>
<p>作用域是由源代码中的赋值语句位置来决定的,不会受到导入关系的影响</p>
<p>实例的属性与变量一样,赋值后才会存在,通常实例属性在<code>__init__</code>构造函数内进行赋值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">X = <span class="number">11</span>				<span class="comment"># Global in module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g1</span><span class="params">()</span>:</span></span><br><span class="line">	print(X)		<span class="comment"># Reference global in module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g2</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> X</span><br><span class="line">	X = <span class="number">22</span>			<span class="comment"># Change global in module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h1</span><span class="params">()</span>:</span></span><br><span class="line">	X = <span class="number">33</span>			<span class="comment"># Local in function</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">()</span>:</span></span><br><span class="line">		print(X)	<span class="comment"># Reference local in enclosing scope</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h2</span><span class="params">()</span>:</span></span><br><span class="line">	X = <span class="number">33</span>			<span class="comment"># Local in function</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">()</span>:</span></span><br><span class="line">		<span class="keyword">nonlocal</span> X	<span class="comment"># Python 3.0 statement</span></span><br><span class="line">		X = <span class="number">44</span>		<span class="comment"># Change local in enclosing scope</span></span><br></pre></td></tr></table></figure>

<p>一个函数也可以在其外部修改名称</p>
<p>使用<code>global</code>和<code>nonlocal</code>语句提供了写入访问,但是也修改了赋值的命名空间绑定规则</p>
<h3 id="命名空间字典"><a href="#命名空间字典" class="headerlink" title="命名空间字典"></a>命名空间字典</h3><p>模块的命名空间是以字典的形式实现的,可以通过内置属性<code>__dict__</code>显示</p>
<p>类和实例对象就是带有连接的字典,属性点号运算内部就是字典的索引运算,属性继承就是搜索链接的字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">super</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            self.data1 = <span class="string">'spam'</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">sub</span><span class="params">(super)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">hola</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            self.data2 = <span class="string">'eggs'</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = sub()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.__dict__					<span class="comment"># Instance namespace dict</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.__class__					<span class="comment"># Class of instance</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">sub</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">sub</span>.<span class="title">__bases__</span>				# <span class="title">Superclasses</span> <span class="title">of</span> <span class="title">class</span></span></span><br><span class="line"><span class="class"><span class="params">(&lt;class <span class="string">'__main__.super'</span>&gt;,)</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">super</span>.<span class="title">__bases__</span>				# <span class="params">()</span> <span class="title">empty</span> <span class="title">tuple</span> <span class="title">in</span> <span class="title">Python</span> 2.6</span></span><br><span class="line"><span class="class"><span class="params">(&lt;class <span class="string">'object'</span>&gt;,)</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line">&gt;&gt;&gt; Y = sub()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.hello()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.__dict__</span><br><span class="line">&#123;<span class="string">'data1'</span>: <span class="string">'spam'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.hola()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.__dict__</span><br><span class="line">&#123;<span class="string">'data1'</span>: <span class="string">'spam'</span>, <span class="string">'data2'</span>: <span class="string">'eggs'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sub.__dict__.keys()</span><br><span class="line">dict_keys([<span class="string">'__module__'</span>, <span class="string">'hola'</span>, <span class="string">'__doc__'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>super.__dict__.keys()</span><br><span class="line">dict_keys([<span class="string">'__module__'</span>, <span class="string">'hello'</span>, <span class="string">'__dict__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'__doc__'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Y.__dict__</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.data1, X.__dict__[<span class="string">'data1'</span>]</span><br><span class="line">(<span class="string">'spam'</span>, <span class="string">'spam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.data3 = <span class="string">'toast'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.__dict__</span><br><span class="line">&#123;<span class="string">'data1'</span>: <span class="string">'spam'</span>, <span class="string">'data2'</span>: <span class="string">'eggs'</span>, <span class="string">'data3'</span>: <span class="string">'toast'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.__dict__[<span class="string">'data3'</span>] = <span class="string">'ham'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.data3</span><br><span class="line"><span class="string">'ham'</span></span><br></pre></td></tr></table></figure>

<p>定义一个超类和一个带方法的子类</p>
<p>创建子类的实例时得到一个空的命名空间字典,但是会有连接指向它的类,让继承搜索能顺着寻找</p>
<p>实例中的<code>__class__</code>属性链接到它的类,类中的<code>__base__</code>属性是一个元组,包含了通往更高的超类的链接</p>
<p>类为<code>self</code>赋值会填入实例对象的属性命名空间内,每个实例都有独立的命名空间字典,可以记录与同一个类的其他势力命名空间字典中的属性完全不同的属性</p>
<p>属性可以通过点号运算或者通过键索引运算,但是键索引运算无法读取<strong>继承的属性</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.__dict__, Y.__dict__</span><br><span class="line">(&#123;<span class="string">'data1'</span>: <span class="string">'spam'</span>, <span class="string">'data2'</span>: <span class="string">'eggs'</span>, <span class="string">'data3'</span>: <span class="string">'ham'</span>&#125;, &#123;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(X.__dict__.keys())</span><br><span class="line">[<span class="string">'data1'</span>, <span class="string">'data2'</span>, <span class="string">'data3'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(X)</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'data1'</span>, <span class="string">'data2'</span>, <span class="string">'data3'</span>, <span class="string">'hello'</span>, <span class="string">'hola'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(sub)</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'hello'</span>, <span class="string">'hola'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(super)</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'hello'</span>]</span><br></pre></td></tr></table></figure>

<p><code>dir</code>函数能用在任何带有属性的对象上,<code>dir(object)</code>类似于<code>object.__dict__.keys()</code>调用</p>
<p><code>dir</code>会排序属性列表,并引入一些系统属性,还包含了从所有类的隐含超类object类继承的名称</p>
<h3 id="命名空间链接"><a href="#命名空间链接" class="headerlink" title="命名空间链接"></a>命名空间链接</h3><p><code>__class__</code>和<code>__bases__</code>属性可以在程序代码内查看继承层次</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># classtree.py</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Climb inheritance trees using namespace links,</span></span><br><span class="line"><span class="string">displaying higher superclasses with indentation</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classtree</span><span class="params">(cls, indent)</span>:</span></span><br><span class="line">	print(<span class="string">'.'</span> * indent + cls.__name__)		<span class="comment"># Print class name here</span></span><br><span class="line">	<span class="keyword">for</span> supercls <span class="keyword">in</span> cls.__bases__:			<span class="comment"># Recur to all superclasses</span></span><br><span class="line">		classtree(supercls, indent+<span class="number">3</span>)		<span class="comment"># May visit super &gt; once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instancetree</span><span class="params">(inst)</span>:</span></span><br><span class="line">	print(<span class="string">'Tree of %s'</span> % inst)				<span class="comment"># Show instance</span></span><br><span class="line">	classtree(inst.__class__, <span class="number">3</span>)			<span class="comment"># Climb to its class</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selftest</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">pass</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span> <span class="keyword">pass</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span> <span class="keyword">pass</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span> <span class="keyword">pass</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">E</span>:</span> <span class="keyword">pass</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">F</span><span class="params">(D, E)</span>:</span> <span class="keyword">pass</span></span><br><span class="line">	instancetree(B())</span><br><span class="line">	instancetree(F())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: selftest()</span><br></pre></td></tr></table></figure>

<p><code>classtree</code>函数是递归的,通过调用自身运行到超类,直到空的<code>__bases__</code>属性组时停止</p>
<p>递归时一个函数的每个活动层级都获取自己的本地作用域副本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">% python classtree.py</span><br><span class="line">Tree of &lt;__main__.selftest.&lt;locals&gt;.B object at <span class="number">0x101fa7160</span>&gt;</span><br><span class="line">...B</span><br><span class="line">......A</span><br><span class="line">.........object</span><br><span class="line">Tree of &lt;__main__.selftest.&lt;locals&gt;.F object at <span class="number">0x101fa7160</span>&gt;</span><br><span class="line">...F</span><br><span class="line">......D</span><br><span class="line">.........B</span><br><span class="line">............A</span><br><span class="line">...............object</span><br><span class="line">.........C</span><br><span class="line">............A</span><br><span class="line">...............object</span><br><span class="line">......E</span><br><span class="line">.........object</span><br></pre></td></tr></table></figure>

<p>在Python 3.0下运行时包含了隐含的<code>object</code>超类的树会自动添加到独立的类上</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Emp</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(Emp)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob = Person()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> classtree</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classtree.instancetree(bob)</span><br><span class="line">Tree of &lt;__main__.Person object at <span class="number">0x104210320</span>&gt;</span><br><span class="line">...Person</span><br><span class="line">......Emp</span><br><span class="line">.........object</span><br></pre></td></tr></table></figure>

<p>可以在任何想很快得到类树显示的的地方导入模块</p>
<hr>
<h2 id="回顾文档字符串"><a href="#回顾文档字符串" class="headerlink" title="回顾文档字符串"></a>回顾文档字符串</h2><p>文档字符串是出现在各种结构的顶部的字符串场了,由对象的<code>__doc__</code>属性自动保存,适用于模块文件、函数定义、类和方法</p>
<p>文档字符串在运行时可用,但是比<code>#注释</code>缺乏灵活性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"I am: docstr.__doc__"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(args)</span>:</span></span><br><span class="line">	<span class="string">"I am: docstr.func.__doc__"</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">spam</span>:</span></span><br><span class="line">	<span class="string">"I am: spam.__doc__ or docstr.spam.__doc__"</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">		<span class="string">"I am: spam.method.__doc__ or self.method.__doc__"</span></span><br><span class="line">		<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>这里概括文档字符串可以在代码中出现的位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> docstr</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>docstr.__doc__</span><br><span class="line"><span class="string">'I am: docstr.__doc__'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>docstr.func.__doc__</span><br><span class="line"><span class="string">'I am: docstr.func.__doc__'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>docstr.spam.__doc__</span><br><span class="line"><span class="string">'I am: spam.__doc__ or docstr.spam.__doc__'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>docstr.spam.method.__doc__</span><br><span class="line"><span class="string">'I am: spam.method.__doc__ or self.method.__doc__'</span></span><br></pre></td></tr></table></figure>

<p>文档字符串可以在运行时保持,通过<code>__doc__</code>属性获取文档</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(makedb)</span><br><span class="line"></span><br><span class="line">Help on module docstr:</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">    docstr - I am: docstr.__doc__</span><br><span class="line"></span><br><span class="line">CLASSES</span><br><span class="line">    builtins.object</span><br><span class="line">        spam</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">spam</span><span class="params">(builtins.object)</span></span></span><br><span class="line"><span class="class">     |  <span class="title">I</span> <span class="title">am</span>:</span> spam.__doc__ <span class="keyword">or</span> docstr.spam.__doc__</span><br><span class="line">     |  </span><br><span class="line">     |  Methods defined here:</span><br><span class="line">     |  </span><br><span class="line">     |  method(self, arg)</span><br><span class="line">     |      I am: spam.method.__doc__ <span class="keyword">or</span> self.method.__doc__</span><br><span class="line">     |  </span><br><span class="line">     |  ----------------------------------------------------------------------</span><br><span class="line">     |  Data descriptors defined here:</span><br><span class="line">     |  </span><br><span class="line">     |  __dict__</span><br><span class="line">     |      dictionary <span class="keyword">for</span> instance variables (<span class="keyword">if</span> defined)</span><br><span class="line">     |  </span><br><span class="line">     |  __weakref__</span><br><span class="line">     |      list of weak references to the object (<span class="keyword">if</span> defined)</span><br><span class="line"></span><br><span class="line">FUNCTIONS</span><br><span class="line">    func(args)</span><br><span class="line">        I am: docstr.func.__doc__</span><br><span class="line"></span><br><span class="line">FILE</span><br><span class="line">    /docstr.py</span><br><span class="line"></span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<p>可以使用<code>PyDoc</code>工具查看格式化报表的字符串</p>
<p>在Python 3.0中还显示隐含<code>object</code>超类继承来的额外属性</p>
<hr>
<h2 id="类与模块的关系"><a href="#类与模块的关系" class="headerlink" title="类与模块的关系"></a>类与模块的关系</h2><p>模块与类都与命名空间有关</p>
<blockquote>
<ul>
<li>模块<ul>
<li>是数据/逻辑包</li>
<li>通过编写Python文件或C扩展来创建</li>
<li>通过导入来使用</li>
</ul>
</li>
<li>类<ul>
<li>实现新的对象</li>
<li>由class语句创建</li>
<li>通过调用来使用</li>
<li>总是位于一个模块中</li>
<li>支持运算符重载、多实例生成和继承</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h2 id="本章习题-3"><a href="#本章习题-3" class="headerlink" title="本章习题"></a>本章习题</h2><ol>
<li><p>什么是抽象超类</p>
<blockquote>
<p>抽象类是会调用方法的类,但没有继承或定义该方法,而是期待该方法由子类填补</p>
<p>当行为无法预测,非得等到更为具体的子类编写才知道时,通常可用这种方式把类通用化</p>
<p>OOP软件框架也使用这种方式作为客户端定义、可定制的运算的实现方法</p>
</blockquote>
</li>
<li><p>当简单赋值语句出现在<code>class</code>语句顶层时,会发生什么</p>
<blockquote>
<p>当简单赋值语句出现在类语句的顶层时,就会把数据属性附加在这个类上,由所有的实例共享</p>
<p>数据属性并不是可调用的方法函数</p>
</blockquote>
</li>
<li><p>类为什么可能会需要手动调用超类中的<code>__init__</code>方 法</p>
<blockquote>
<p>如果类定义自身的<code>__init__</code>构造函数,但是也必须启用超类的构建其代码,就必须手动调用超类的<code>__init__</code>方法</p>
<p> Python本身只会自动执行树中最低的构造函数</p>
<p>超类的构造函数通过类名称来调用,手动传入<code>self</code>实例</p>
</blockquote>
</li>
<li><p>怎样增强(而不是完全取代)继承的方法</p>
<blockquote>
<p>要增强继承的方法而不是完全替代,还得在子类中进行重新定义,但是要从子类的新版方法中手动回调超类版本的这个方法</p>
<p>就是把<code>self</code>实例手动传给超类的版本的这个方法: <code>Superclass .method(self, ...)</code></p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="第二十九章-运算符重载"><a href="#第二十九章-运算符重载" class="headerlink" title="第二十九章 运算符重载"></a>第二十九章 运算符重载</h1><blockquote>
<ul>
<li>深入介绍类机制</li>
<li>关注运算符重载</li>
</ul>
</blockquote>
<hr>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>运算符重载会拦截内置的操作,调用定义的特殊方法,将方法的返回值作为相应操作的结果</p>
<p>重载的关键概念</p>
<blockquote>
<ul>
<li>运算符重载让类拦截常规的Python运算</li>
<li>类可重载所有Python表达式运算符</li>
<li>类也可重载打印、函数调用、属性点号运算等内置运算</li>
<li>重载使类实例的行为像内置类型</li>
<li>重载是通过提供特殊名称的类方法来实现的</li>
</ul>
</blockquote>
<p>运算符重载方法不是必须的,也不是默认的,如果没有编写或继承一个运算符重载方法只是不支持相应的操作</p>
<h3 id="构造函数和表达式-init-和-sub"><a href="#构造函数和表达式-init-和-sub" class="headerlink" title="构造函数和表达式:__init__和__sub__"></a>构造函数和表达式:<code>__init__</code>和<code>__sub__</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Number:                               # On Number(start)</span><br><span class="line">    def __init__(self, start):</span><br><span class="line">        self.data = start                   # On instance - other</span><br><span class="line">    def __sub__(self, other):               # Result is a new instance</span><br><span class="line">        return Number(self.data - other)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; from number import Number               # Fetch class from module</span><br><span class="line">&gt;&gt;&gt; X = Number(5)                           # Number.__init__(X, 5)</span><br><span class="line">&gt;&gt;&gt; Y = X - 2                               # Number.__sub__(X, 2)</span><br><span class="line">&gt;&gt;&gt; Y.data                                  # Y is new Number instance</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p><code>__init__</code>方法拦截实例的构造函数</p>
<p><code>__sub__</code>方法捕捉减法表达式</p>
<h3 id="常见的运算符重载方法"><a href="#常见的运算符重载方法" class="headerlink" title="常见的运算符重载方法"></a>常见的运算符重载方法</h3><p>在类中,对内置对象所能做的事几乎都有相应的特殊名称的重载方法</p>
<p>所有重载方法的名称前后都有两个下划线字符,便于把同一类中定义的变量名区别开来</p>
<p>特殊方法名称和表达式或运算的映射关系是Python语言预先定义好的</p>
<p>没有定义运算符重载方法时可以继承自超类</p>
<p>运算符重载方法是可选的,如果没有编写或继承一个方法,类不支持相关运算,在试图使用相关运算时引发异常</p>
<p>多数重载方法用在需要对象行为表现得像是内置类型一样的程序中,大多数类中使用<code>__init__</code>构造函数</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>重载</th>
<th>调用</th>
</tr>
</thead>
<tbody><tr>
<td><code>__init__</code></td>
<td>构造函数</td>
<td>对象建立:<code>X = Class(Args)</code></td>
</tr>
<tr>
<td><code>__del__</code></td>
<td>析构函数</td>
<td><code>X</code>对象收回</td>
</tr>
<tr>
<td><code>__add__</code></td>
<td>运算符<code>+</code></td>
<td>如果没有<code>_iadd_</code>,<code>X + Y, X += Y</code></td>
</tr>
<tr>
<td><code>__or__</code></td>
<td>运算符`</td>
<td><code>,位</code>OR`</td>
</tr>
<tr>
<td><code>__repr__</code>,<code>__str__</code></td>
<td>打印、切换</td>
<td><code>print(X)</code>, <code>repr(X)</code>, <code>str(X)</code></td>
</tr>
<tr>
<td><code>__call__</code></td>
<td>函数调用</td>
<td><code>X(*args, **kargs)</code></td>
</tr>
<tr>
<td><code>__getattr__</code></td>
<td>点号运算</td>
<td><code>X.undefined</code></td>
</tr>
<tr>
<td><code>__setattr__</code></td>
<td>属性赋值语句</td>
<td><code>X.any = value</code></td>
</tr>
<tr>
<td><code>__delattr__</code></td>
<td>属性删除</td>
<td><code>del X.any</code></td>
</tr>
<tr>
<td><code>__getattribute__</code></td>
<td>属性获取</td>
<td><code>X.any</code></td>
</tr>
<tr>
<td><code>__getitem__</code></td>
<td>索引运算</td>
<td><code>X[key], X[i:j]</code>,没<code>__iter__</code>时的<code>for</code>循环和其他迭代器</td>
</tr>
<tr>
<td><code>__setitem__</code></td>
<td>索引赋值语句</td>
<td><code>X[key] = value</code>, <code>X[i:j] = sequence</code></td>
</tr>
<tr>
<td><code>__delitem__</code></td>
<td>索引和分片删除</td>
<td><code>del X[key]</code>, <code>X[i:j]</code></td>
</tr>
<tr>
<td><code>__len__</code></td>
<td>长度</td>
<td><code>len(X)</code>, 如果没有<code>__bool__</code>,真值测试</td>
</tr>
<tr>
<td><code>__bool__</code></td>
<td>布尔测试</td>
<td><code>bool(X)</code>, 真测试</td>
</tr>
<tr>
<td><code>__lt__</code>,<code>__gt__</code></td>
<td>特定的比较</td>
<td><code>X &lt; Y</code>, <code>X &gt; Y</code>, <code>X &lt;= Y</code>, <code>X &gt;= Y</code></td>
</tr>
<tr>
<td><code>__le__</code>, <code>__ge__</code></td>
<td></td>
<td><code>X == Y</code></td>
</tr>
<tr>
<td><code>__eq__</code>,<code>__ne__</code></td>
<td></td>
<td><code>X != Y</code></td>
</tr>
<tr>
<td><code>__radd__</code></td>
<td>右侧加法</td>
<td><code>Other + X</code></td>
</tr>
<tr>
<td><code>__iadd__</code></td>
<td>实地加法</td>
<td><code>X += Y</code></td>
</tr>
<tr>
<td><code>__iter__</code>, <code>__next__</code></td>
<td>迭代环境</td>
<td><code>I=iter(X)</code>, <code>next(I)</code>, <code>for loops</code>, <code>in if no __contains__</code>,<code>all comprehensions</code>,<code>map(E, X)</code></td>
</tr>
<tr>
<td><code>__contains__</code></td>
<td>成员关系测试</td>
<td><code>item in X</code></td>
</tr>
<tr>
<td><code>__index__</code></td>
<td>整数值</td>
<td><code>hex(X)</code>, <code>bin(X)</code>, <code>oct(X)</code>, <code>O[X]</code>, <code>O[X:]</code></td>
</tr>
<tr>
<td><code>__enter__</code>, <code>__exit__</code></td>
<td>环境管理器</td>
<td><code>with obj as var:</code></td>
</tr>
<tr>
<td><code>__get__</code>, <code>__set__</code>,  <code>__delete__</code></td>
<td>描述符属性</td>
<td><code>X.attr</code>, <code>X.attr = value</code>, <code>del X.attr</code></td>
</tr>
<tr>
<td><code>__new__</code></td>
<td>创建</td>
<td>在<code>__init__</code>之前创建对象</td>
</tr>
</tbody></table>
<hr>
<h2 id="索引和分片-getitem-和-setitem"><a href="#索引和分片-getitem-和-setitem" class="headerlink" title="索引和分片:__getitem__和__setitem__"></a>索引和分片:<code>__getitem__</code>和<code>__setitem__</code></h2><p>如果在类中定义或继承了<code>__getitem__</code>方法会在对实例的<strong>索引运算</strong>自动调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Indexer:</span><br><span class="line">...     def __getitem__(self, index):</span><br><span class="line">...             return index ** 2</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; X = Indexer()</span><br><span class="line">&gt;&gt;&gt; X[2]                            # X[i] calls X.__getitem__(i)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; for i in range(5):</span><br><span class="line">...     print(X[i], end=&apos; &apos;)        # Runs __getitem__(X, i) each time</span><br><span class="line">... </span><br><span class="line">0 1 4 9 16</span><br></pre></td></tr></table></figure>

<p>方法的第一个参数为实例对象,第二个参数为索引值</p>
<h3 id="拦截分片"><a href="#拦截分片" class="headerlink" title="拦截分片"></a>拦截分片</h3><p><code>__getitem__</code>方法既针对基本索引调用,又针对分片调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [5, 6, 7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; L[2:4]          # Slice with slice syntax</span><br><span class="line">[7, 8]</span><br><span class="line">&gt;&gt;&gt; L[1:]</span><br><span class="line">[6, 7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; L[:-1]</span><br><span class="line">[5, 6, 7, 8]</span><br><span class="line">&gt;&gt;&gt; L[::2]</span><br><span class="line">[5, 7, 9]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; L[slice(2, 4)]          # Slice with  slice object</span><br><span class="line">[7, 8]</span><br><span class="line">&gt;&gt;&gt; L[slice(1, None)]</span><br><span class="line">[6, 7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; L[slice(None, -1)]</span><br><span class="line">[5, 6, 7, 8]</span><br><span class="line">&gt;&gt;&gt; L[slice(None, None, 2)]</span><br><span class="line">[5, 7, 9]</span><br></pre></td></tr></table></figure>

<p>内置类型以同样的方式处理索引和分片</p>
<p>可以手动地传递一个分片对象,分片语法主要是用一个分片对象<code>slice</code>进行索引的语法,分片边界绑定到了一个分片对象中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Indexer:</span><br><span class="line">...     data = [5, 6, 7, 8, 9]</span><br><span class="line">...     def __getitem__(self, index):       # Called for index or slice</span><br><span class="line">...             print(&apos;getitem:&apos;, index)</span><br><span class="line">...             return self.data[index]     # Perform index or slice</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; X = Indexer()</span><br><span class="line">&gt;&gt;&gt; X[0]                                    # Indexing sends __getitem__ an integer</span><br><span class="line">getitem: 0</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; X[1]</span><br><span class="line">getitem: 1</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; X[-1]</span><br><span class="line">getitem: -1</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; X[2:4]                                  # Slicing sends __getitem__ a slice object</span><br><span class="line">getitem: slice(2, 4, None)</span><br><span class="line">[7, 8]</span><br><span class="line">&gt;&gt;&gt; X[1:]</span><br><span class="line">getitem: slice(1, None, None)</span><br><span class="line">[6, 7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; X[:-1]</span><br><span class="line">getitem: slice(None, -1, None)</span><br><span class="line">[5, 6, 7, 8]</span><br><span class="line">&gt;&gt;&gt; X[::2]</span><br><span class="line">getitem: slice(None, None, 2)</span><br><span class="line">[5, 7, 9]</span><br></pre></td></tr></table></figure>

<p>当针对索引调用时参数是一个整数</p>
<p>当针对分片调用时方法接收一个分片对象,它在一个新的索引表达式中直接传递给嵌套的列表索引</p>
<p>分片表达式用包含边界的一个<strong>分片对象</strong>来触发<code>__getitem__</code>,既针对内置类型,也针对用户定义的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def __setitem__(self, index, value):        # Intercept index or slice assignment</span><br><span class="line">    ...</span><br><span class="line">    self.data[index] = value                # Assign index or slice</span><br></pre></td></tr></table></figure>

<p><code>__setitem__</code>索引赋值方法类似地拦截索引和分片<strong>赋值</strong>,为后者接收一个<strong>分片对象</strong>,以同样的方式传递到另一个索引赋值中</p>
<h3 id="Python-2-6中的分片和索引"><a href="#Python-2-6中的分片和索引" class="headerlink" title="Python 2.6中的分片和索引"></a>Python 2.6中的分片和索引</h3><p>在Python 3.0之前,类可以定义<code>__getslice__</code>和<code>__setslice__</code>方法来专门拦截分片获取和赋值</p>
<hr>
<h2 id="索引迭代-getitem"><a href="#索引迭代-getitem" class="headerlink" title="索引迭代:__getitem__"></a>索引迭代:<code>__getitem__</code></h2><p><code>for</code>语句不断迭代索引值,对序列重复索引运算,直到检测到超出边界的异常</p>
<p><code>__getitem__</code>可以是Python中重载迭代的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class stepper:</span><br><span class="line">...     def __getitem__(self, i):</span><br><span class="line">...             return self.data[i]</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; X = stepper()                   # X is stepper object</span><br><span class="line">&gt;&gt;&gt; X.data = &quot;Spam&quot;</span><br><span class="line">&gt;&gt;&gt; X[1]                            # Indexing calls __getitem__</span><br><span class="line">&apos;p&apos;</span><br><span class="line">&gt;&gt;&gt; for item in X:                  # for loops call __getitem__</span><br><span class="line">...     print(item, end=&apos; &apos;)        # for indexes item 0..N</span><br><span class="line">... </span><br><span class="line">S p a m</span><br><span class="line">&gt;&gt;&gt; &apos;p&apos; in X                        # Al call __getitem__ too</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; [c for c in X]                  # List comprehension</span><br><span class="line">[&apos;S&apos;, &apos;p&apos;, &apos;a&apos;, &apos;m&apos;]</span><br><span class="line">&gt;&gt;&gt; list(map(str.upper, X))         # map calls</span><br><span class="line">[&apos;S&apos;, &apos;P&apos;, &apos;A&apos;, &apos;M&apos;]</span><br><span class="line">&gt;&gt;&gt; (a, b, c, d) = X                # Sequence assignments</span><br><span class="line">&gt;&gt;&gt; a, c, d</span><br><span class="line">(&apos;S&apos;, &apos;a&apos;, &apos;m&apos;)</span><br><span class="line">&gt;&gt;&gt; list(X), tuple(X), &apos;&apos;.join(X)</span><br><span class="line">([&apos;S&apos;, &apos;p&apos;, &apos;a&apos;, &apos;m&apos;], (&apos;S&apos;, &apos;p&apos;, &apos;a&apos;, &apos;m&apos;), &apos;Spam&apos;)</span><br><span class="line">&gt;&gt;&gt; X</span><br><span class="line">&lt;__main__.stepper object at 0x103f1dd68&gt;</span><br></pre></td></tr></table></figure>

<p>任何响应索引运算的内置或用户定义的对象,同样会响应所有迭代环境</p>
<hr>
<h2 id="迭代器对象-iter-和-next"><a href="#迭代器对象-iter-和-next" class="headerlink" title="迭代器对象:__iter__和__next__"></a>迭代器对象:<code>__iter__</code>和<code>__next__</code></h2><p>Python中所有的迭代环境都先尝试<code>__iter__</code>方法,再尝试<code>__getitem__</code>,只有在对象不支持迭代协议的时候才会尝试索引运算</p>
<p>迭代环境是通过调用内置函数<code>iter</code>去尝试寻找<code>__iter__</code>方法来实现,Python重复调用这个方法返回的迭代器对象的<code>next</code>方法,直到发生<code>StopIteration</code>异常</p>
<p>如果没有找到<code>__iter__</code>方法,Python会改用<code>__getitem__</code>机制,通过偏移量重复索引,直到引发<code>IndexError</code>异常</p>
<h3 id="用户定义的迭代器"><a href="#用户定义的迭代器" class="headerlink" title="用户定义的迭代器"></a>用户定义的迭代器</h3><p>在<code>__iter__</code>机制中,类通过实现迭代器协议来实现用户定义的迭代器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Squares:</span><br><span class="line">    def __init__(self, start, stop):    # Save state when created</span><br><span class="line">        self.value = start - 1</span><br><span class="line">        self.stop = stop</span><br><span class="line">    def __iter__(self):                 # Get iterator object on iter</span><br><span class="line">        return self</span><br><span class="line">    def __next__(self):                 # Return a square on each iteration</span><br><span class="line">        if self.value == self.stop:     # Also called by next built-in</span><br><span class="line">            raise StopIteration</span><br><span class="line">        self.value += 1</span><br><span class="line">        return self.value ** 2</span><br><span class="line"></span><br><span class="line">% python</span><br><span class="line">&gt;&gt;&gt; from iters import Squares</span><br><span class="line">&gt;&gt;&gt; for i in Squares(1, 5):             # for calls iter,which calls __iter__</span><br><span class="line">...     print(i, end=&apos; &apos;)               # Each iteration calls __next__</span><br><span class="line">... </span><br><span class="line">1 4 9 16 25</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; X = Squares(1, 5)                   # Iterate manually:what loops do</span><br><span class="line">&gt;&gt;&gt; I = iter(X)                         # iter calls __iter__</span><br><span class="line">&gt;&gt;&gt; next(I)                             # next calls __next__</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(I)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; next(I)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; next(I)</span><br><span class="line">16</span><br><span class="line">&gt;&gt;&gt; next(I)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; next(I)                             # Can catch this in try statement</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    raise StopIteration</span><br><span class="line">StopIteration</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; X = Squares(1, 5)</span><br><span class="line">&gt;&gt;&gt; X[1]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">TypeError: &apos;Squares&apos; object does not support indexing</span><br></pre></td></tr></table></figure>

<p>迭代器对象就是实例<code>self</code>,以<code>raise</code>语句发出信号表示迭代结束</p>
<p>手动迭代对内置类型也有效</p>
<p><code>__iter__</code>对象会在调用过程中明确地保留状态信息,所以<code>__getitem__</code>具有更好的通用性</p>
<p>迭代器没有重载索引表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X = Squares(1, 5)</span><br><span class="line">&gt;&gt;&gt; [n for n in X]                  # Exhausts items</span><br><span class="line">[1, 4, 9, 16, 25]</span><br><span class="line">&gt;&gt;&gt; [n for n in X]                  # Now it&apos;s empty</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; [n for n  in Squares(1, 5)]     # Make a new iterator object</span><br><span class="line">[1, 4, 9, 16, 25]</span><br><span class="line">&gt;&gt;&gt; list(Squares(1, 3))</span><br><span class="line">[1, 4, 9]</span><br></pre></td></tr></table></figure>

<p>与<code>__getitem__</code>不同,<code>__iter__</code>只循环一次,循环之后变为空,每次新的循环需要创建一个新的迭代器对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def gsquares(start, stop):</span><br><span class="line">...     for i in range(start, stop+1):</span><br><span class="line">...             yield i ** 2</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; for i in gsquares(1, 5):        # or: (x * 2 for x in range(1, 5))</span><br><span class="line">...     print(i, end=&apos; &apos;)</span><br><span class="line">... </span><br><span class="line">1 4 9 16 25</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [x ** 2 for x in range(1, 6)]</span><br><span class="line">[1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure>

<p>使用函数生成器编写更为简单,和类不同的是生成器函数会自动在迭代中存储其状态</p>
<p>可以通过<code>for</code>循环、<code>map</code>或是列表解析一次性创建列表</p>
<h3 id="有多个迭代器的对象"><a href="#有多个迭代器的对象" class="headerlink" title="有多个迭代器的对象"></a>有多个迭代器的对象</h3><p>迭代器对象可以定义为一个独立的类,有其自己的状态信息,从而能够支持相同数据的多个迭代</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; S = &apos;abc&apos;</span><br><span class="line">&gt;&gt;&gt; for x in S:</span><br><span class="line">...     for y in S:</span><br><span class="line">...             print(x + y, end=&apos; &apos;)</span><br><span class="line">... </span><br><span class="line">aa ab ac ba bb bc ca cb cc</span><br></pre></td></tr></table></figure>

<p>外层循环调用<code>iter</code>从字符串中取得迭代器,嵌套的循环也同样获得独立的迭代器,每个激活状态下的迭代器都有自己的状态信息,而不管其他激活状态下的循环是什么样子</p>
<p>生成器函数和表达式以及<code>map</code>和<code>zip</code>这样的内置函数,都证明是单迭代对象,<code>range</code>内置函数和其他的内置类型支持独立位置的多个活跃迭代器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class SkipIterator:</span><br><span class="line">    def __init__(self, wrapped):</span><br><span class="line">        self.wrapped = wrapped                  # Iterator state information</span><br><span class="line">        self.offset = 0</span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.offset &gt;= len(self.wrapped):    # Terminate iterations</span><br><span class="line">            raise StopIteration</span><br><span class="line">        else:</span><br><span class="line">            item = self.wrapped[self.offset]    # else return and skip</span><br><span class="line">            self.offset += 2</span><br><span class="line">            return item</span><br><span class="line"></span><br><span class="line">class SkipObject:</span><br><span class="line">    def __init__(self, wrapped):                # Save item to be used</span><br><span class="line">        self.wrapped = wrapped</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return SkipIterator(self.wrapped)       # New iterator each time</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    alpha = &apos;abcdef&apos;</span><br><span class="line">    skipper = SkipObject(alpha)                 # Make container object</span><br><span class="line">    I = iter(skipper)                           # Make an iterator on it</span><br><span class="line">    print(next(I), next(I), next(I))            # Visit offsets 0, 2, 4</span><br><span class="line"></span><br><span class="line">    for x in skipper:                           # for calls __iter__ automatically</span><br><span class="line">        for y in skipper:                       # Nested fors call __iter__ again each time</span><br><span class="line">            print(x + y, end=&apos; &apos;)               # Each iterator has its own state, offset</span><br></pre></td></tr></table></figure>

<p>用类编写用户定义的迭代器时,要达到多个迭代器的效果,只需<code>__iter__</code>替迭代器定义新的状态对象,而不是返回<code>self</code></p>
<p>因为每个循环都会获得独立的迭代器对象来记录自己的状态信息,所以每个激活状态下的循环都有自己在字符串中的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; S = &apos;abcdef&apos;</span><br><span class="line">&gt;&gt;&gt; for x in S[::2]:</span><br><span class="line">...     for y in S[::2]:                # New objects on each iteration</span><br><span class="line">...             print(x + y, end=&apos; &apos;)</span><br><span class="line">... </span><br><span class="line">aa ac ae ca cc ce ea ec ee</span><br></pre></td></tr></table></figure>

<p>使用内置工具可以达到类似的的效果</p>
<p>迭代器与内置工具并不完全相同,首先分片表达式把结果列表存储在内存中,而迭代器一次产生一个值,其次分片产生新对象而没有对同一个对象进行多处的循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; S = &apos;abcdef&apos;</span><br><span class="line">&gt;&gt;&gt; S = S[::2]</span><br><span class="line">&gt;&gt;&gt; S</span><br><span class="line">&apos;ace&apos;</span><br><span class="line">&gt;&gt;&gt; for x in S:</span><br><span class="line">...     for y in S:                         # Same object, new iterators</span><br><span class="line">...             print(x + y, end=&apos; &apos;)</span><br><span class="line">... </span><br><span class="line">aa ac ae ca cc ce ea ec ee</span><br></pre></td></tr></table></figure>

<p>这里对一个对象进行了多处循环,但仍是一次性把分片结果存储在内存中</p>
<hr>
<h2 id="成员关系-contains-、-iter-和-getitem"><a href="#成员关系-contains-、-iter-和-getitem" class="headerlink" title="成员关系:__contains__、__iter__和__getitem__"></a>成员关系:<code>__contains__</code>、<code>__iter__</code>和<code>__getitem__</code></h2><p>运算符重载往往是多个层级的,类可以提供特定的方法或通用的方案</p>
<blockquote>
<ul>
<li>比较先尝试一个特定的<code>__lt__</code>,没有则使用通用的<code>__cmp__</code></li>
<li>布尔测试先尝试一个特定的<code>__bool__</code>,没有则使用通用的<code>__len__</code></li>
</ul>
</blockquote>
<p>类实现<code>in</code>成员关系运算符使用特定的成员关系<code>__contains__</code>优先于迭代<code>__iter__</code>方法优先于索引<code>__getitem__</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Iters:</span><br><span class="line">    def __init__(self, value):</span><br><span class="line">        self.data = value</span><br><span class="line">    def __getitem__(self, i):               # Fallback for iteration</span><br><span class="line">        print(&apos;get[%s]:&apos; % i, end=&apos;&apos;)       # Also for index, slice</span><br><span class="line">        return self.data[i]</span><br><span class="line">    def __iter__(self):                     # Preferred for iteration</span><br><span class="line">        print(&apos;iter=&gt; &apos;, end=&apos;&apos;)            # Allows only 1 active iterator</span><br><span class="line">        self.ix = 0</span><br><span class="line">        return self</span><br><span class="line">    def __next__(self):</span><br><span class="line">        print(&apos;next:&apos;, end=&apos;&apos;)</span><br><span class="line">        if self.ix == len(self.data): raise StopIteration</span><br><span class="line">        item = self.data[self.ix]</span><br><span class="line">        self.ix += 1</span><br><span class="line">        return item</span><br><span class="line">    def __contains__(self, x):              # Preferred for &apos;in&apos;</span><br><span class="line">        print(&apos;contains: &apos;,  end=&apos;&apos;)</span><br><span class="line">        return x in self.data</span><br><span class="line"></span><br><span class="line">X = Iters([1, 2, 3, 4, 5])                  # Make instance</span><br><span class="line">print(3 in X)                               # Membership</span><br><span class="line">for i in X:                                 # For loops</span><br><span class="line">    print(i, end=&apos; | &apos;)</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line">print([i ** 2 for i in X])                  # Other iteration contexts</span><br><span class="line">print(list(map(bin, X)))</span><br><span class="line"></span><br><span class="line">I = iter(X)                                 # Manual iteration(what other contexts do)</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        print(next(I), end=&apos; @ &apos;)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<p><code>__contains__</code>方法把成员关系定义为一个<code>映射应用键</code>以及用于序列的搜索</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contains: True</span><br><span class="line">iter=&gt; next:1 | next:2 | next:3 | next:4 | next:5 | next:</span><br><span class="line">iter=&gt; next:next:next:next:next:next:[1, 4, 9, 16, 25]</span><br><span class="line">iter=&gt; next:next:next:next:next:next:[&apos;0b1&apos;, &apos;0b10&apos;, &apos;0b11&apos;, &apos;0b100&apos;, &apos;0b101&apos;]</span><br><span class="line">iter=&gt; next:1 @ next:2 @ next:3 @ next:4 @ next:5 @ next:[Finished in 0.1s]</span><br></pre></td></tr></table></figure>

<p>这段代码输出特定的<code>__contains__</code>拦截成员关系,通用的<code>__iter__</code>捕获其他的迭代环境以至<code>__next__</code>重复地被调用,而<code>__getitem</code>不会被调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iter=&gt; next:next:next:True</span><br><span class="line">iter=&gt; next:1 | next:2 | next:3 | next:4 | next:5 | next:</span><br><span class="line">iter=&gt; next:next:next:next:next:next:[1, 4, 9, 16, 25]</span><br><span class="line">iter=&gt; next:next:next:next:next:next:[&apos;0b1&apos;, &apos;0b10&apos;, &apos;0b11&apos;, &apos;0b100&apos;, &apos;0b101&apos;]</span><br><span class="line">iter=&gt; next:1 @ next:2 @ next:3 @ next:4 @ next:5 @ next:[Finished in 0.2s]</span><br></pre></td></tr></table></figure>

<p>如果去掉<code>__contains__</code>方法后成员关系路由到了通用的<code>__iter__</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get[0]:get[1]:get[2]:True</span><br><span class="line">get[0]:1 | get[1]:2 | get[2]:3 | get[3]:4 | get[4]:5 | get[5]:</span><br><span class="line">get[0]:get[1]:get[2]:get[3]:get[4]:get[5]:[1, 4, 9, 16, 25]</span><br><span class="line">get[0]:get[1]:get[2]:get[3]:get[4]:get[5]:[&apos;0b1&apos;, &apos;0b10&apos;, &apos;0b11&apos;, &apos;0b100&apos;, &apos;0b101&apos;]</span><br><span class="line">get[0]:1 @ get[1]:2 @ get[2]:3 @ get[3]:4 @ get[4]:5 @ get[5]:[Finished in 0.2s]</span><br></pre></td></tr></table></figure>

<p>如果去掉<code>__contains__</code>和<code>__iter__</code>方法后调用索引<code>__getitem__</code>方法,针对成员关系和其他迭代环境使用连续较高的索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from iters import Iters</span><br><span class="line">&gt;&gt;&gt; X = Iters(&apos;spam&apos;)               # Indexing</span><br><span class="line">&gt;&gt;&gt; X[0]                            # __getitem__(0)</span><br><span class="line">get[0]:&apos;s&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;spam&apos;[1:]                      # Slice syntax</span><br><span class="line">&apos;pam&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;spam&apos;[slice(1, None)]          # Slice object</span><br><span class="line">&apos;pam&apos;</span><br><span class="line">&gt;&gt;&gt; X[1:]                           # __getitem__(slcie(..))</span><br><span class="line">get[slice(1, None, None)]:&apos;pam&apos;</span><br><span class="line">&gt;&gt;&gt; X[:-1]</span><br><span class="line">get[slice(None, -1, None)]:&apos;spa&apos;</span><br></pre></td></tr></table></figure>

<p><code>__getitem__</code>方法更加通用,除了迭代还呼拦截显示索引和分片</p>
<p>但是在并非序列的、迭代的用例中<code>__iter__</code>方法更容易编写,因为它不必管理一个整数索引</p>
<p><code>__contains__</code>可以考虑到作为一种特殊情况优化成员关系</p>
<hr>
<h2 id="属性引用-getattr-和-setattr"><a href="#属性引用-getattr-和-setattr" class="headerlink" title="属性引用:__getattr__和__setattr__"></a>属性引用:<code>__getattr__</code>和<code>__setattr__</code></h2><p><code>__getattr__</code>方法拦截<strong>未定义</strong>的属性点号运算,可以作为钩子来通过通用的方式响应属性请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class empty:</span><br><span class="line">...     def __getattr__(self, attrname):</span><br><span class="line">...             if attrname == &quot;age&quot;:</span><br><span class="line">...                     return 40</span><br><span class="line">...             else:</span><br><span class="line">...                     raise AttributeError(attrname)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; X = empty()</span><br><span class="line">&gt;&gt;&gt; X.age</span><br><span class="line">40</span><br><span class="line">&gt;&gt;&gt; X.name</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">AttributeError: name</span><br></pre></td></tr></table></figure>

<p><strong>未定义</strong>的属性名称和实例进行点号运算时,若通过继承树搜索流程没有找到该属性时,调用<code>__getattr__</code>方法</p>
<p>调用<code>__getattr__</code>方法后,<code>self</code>赋值为实例类,<code>attrname</code>赋值为未定义的属性名称字符串,返回值作为点号表达式的结果,得到一个动态计算的属性</p>
<p>对于类不知道如何处理的属性,可以引发内置的<code>AttributeError</code>异常告诉Python一个未定义属性名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  &gt;&gt;&gt; class accesscontrol:</span><br><span class="line">  ...     def __setattr__(self, attr, value):</span><br><span class="line">  ...             if attr == &apos;age&apos;:</span><br><span class="line">  ...                     self.__dict__[attr] = value</span><br><span class="line">  ...             else:</span><br><span class="line">  ...                     raise AttributeError(attr + &apos; not allowed&apos;)</span><br><span class="line">  ... </span><br><span class="line">  &gt;&gt;&gt; X = accesscontrol()</span><br><span class="line">  &gt;&gt;&gt; X.age = 40          # Calls __setattr__</span><br><span class="line">  &gt;&gt;&gt; X.age</span><br><span class="line">  40</span><br><span class="line">  &gt;&gt;&gt; X.name = &apos;mel&apos;</span><br><span class="line">  Traceback (most recent call last):</span><br><span class="line">  AttributeError: name not allowed</span><br><span class="line">__setattr__`会拦截所有属性的**赋值语句**,点号表达式`self.attr = value`变成`self__setattr__(&apos;attr&apos;, value)</span><br></pre></td></tr></table></figure>

<p>在<code>__setattr__</code>中对任何<code>self</code>属性赋都会再次调用<code>__setattr__</code>,导致无穷递归循环,需要通过属性字典<code>__dict__</code>做索引运算来赋值实例的属性</p>
<h3 id="其他属性管理工具"><a href="#其他属性管理工具" class="headerlink" title="其他属性管理工具"></a>其他属性管理工具</h3><blockquote>
<ul>
<li><code>__getattribute__</code>方法了拦截所有的属性,需要小心地避免循环</li>
<li><code>Property</code>内置函数允许将方法和特定类属性上的获取和设置操作关联起来</li>
<li><code>描述符</code>提供了一个协议把一个类的<code>__get__</code>和<code>__set__</code>方法与对特定类属性的访问关联起来</li>
</ul>
</blockquote>
<h3 id="模拟实例属性的私有性-第一部分"><a href="#模拟实例属性的私有性-第一部分" class="headerlink" title="模拟实例属性的私有性:第一部分"></a>模拟实例属性的私有性:第一部分</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class PrivateExc(Exception): pass               # More on exceptions later</span><br><span class="line"></span><br><span class="line">class Privacy:</span><br><span class="line">    def __setattr__(self, attrname, value):     # On self.attrname = value</span><br><span class="line">        if attrname in self.privates:</span><br><span class="line">            raise PrivateExc(attrname, self)</span><br><span class="line">        else:</span><br><span class="line">            self.__dict__[attrname] = value     # slef.attrname = value loops!</span><br><span class="line"></span><br><span class="line">class Test1(Privacy):</span><br><span class="line">    privates = [&apos;age&apos;]</span><br><span class="line"></span><br><span class="line">class Test2(Privacy):</span><br><span class="line">    privates = [&apos;name&apos;, &apos;pay&apos;]</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__dict__[&apos;name&apos;] = &apos;Tom&apos;</span><br><span class="line"></span><br><span class="line">x = Test1()</span><br><span class="line">y = Test2()</span><br><span class="line"></span><br><span class="line">x.name = &apos;Bob&apos;</span><br><span class="line">y.name = &apos;Sue&apos;                                  # Fails</span><br><span class="line"></span><br><span class="line">Y.age = 30</span><br><span class="line">x.age = 40                                      # Fails</span><br></pre></td></tr></table></figure>

<p>通过通用化拦截属性,让每个拥有自己的私有变量名列表的子类无法通过其实例进行赋值</p>
<p>这是Python中实现属性私有性的首选方法</p>
<p>可以让子类也能够设置私有属性,并且使用<code>__getattr__</code>和包装来检测对私有属性的读取</p>
<p>使用<code>类装饰器</code>可以更加通用地拦截和验证属性</p>
<hr>
<h2 id="repr-和-str-会返回字符串表达式形式"><a href="#repr-和-str-会返回字符串表达式形式" class="headerlink" title="__repr__和__str__会返回字符串表达式形式"></a><code>__repr__</code>和<code>__str__</code>会返回字符串表达式形式</h2><p>如果定义了的话,当类的实例打印或转换成字符串时<code>__repr__</code>与<code>__str__</code>就会自动调用,这些方法可替对象定义更好的显示,而不是使用默认的实例显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class adder:</span><br><span class="line">...     def __init__(self, value=0):</span><br><span class="line">...             self.data = value                   # Initialize data</span><br><span class="line">...     def __add__(self, other):</span><br><span class="line">...             self.data += other                  # Add other in-place (bad!)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; x = adder()                                     # Default displays</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">&lt;__main__.adder object at 0x1048d9f60&gt;</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">&lt;__main__.adder object at 0x1048d9f60&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; class addrepr(adder):                           # Inherit __init__,__add__</span><br><span class="line">...     def __repr__(self):                         # Add string representation</span><br><span class="line">...             return &apos;addrepr(%s)&apos; % self.data    # Convert to as-code string</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; x = addrepr(2)                                  # Runs __init__</span><br><span class="line">&gt;&gt;&gt; x + 1                                           # Runs __add__</span><br><span class="line">&gt;&gt;&gt; x                                               # Runs __repr__</span><br><span class="line">addrepr(3)</span><br><span class="line">&gt;&gt;&gt; print(x)                                        # Runs __repr__</span><br><span class="line">addrepr(3)</span><br><span class="line">&gt;&gt;&gt; str(x), repr(x)                                 # Runs __repr__ for both</span><br><span class="line">(&apos;addrepr(3)&apos;, &apos;addrepr(3)&apos;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; class addstr(adder):</span><br><span class="line">...     def __str__(self):                          # __str__ but no __repr</span><br><span class="line">...             return &apos;[Value: %s]&apos; % self.data    # Convert to nice string</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; x = addstr(3)</span><br><span class="line">&gt;&gt;&gt; x + 1</span><br><span class="line">&gt;&gt;&gt; x                                               # Default __repr__</span><br><span class="line">&lt;__main__.addstr object at 0x1048c5cf8&gt;</span><br><span class="line">&gt;&gt;&gt; print(x)                                        # Runs __str__</span><br><span class="line">[Value: 4]</span><br><span class="line">&gt;&gt;&gt; str(x), repr(x)</span><br><span class="line">(&apos;[Value: 4]&apos;, &apos;&lt;__main__.addstr object at 0x1048c5cf8&gt;&apos;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; class addboth(adder):</span><br><span class="line">...     def __str__(self):</span><br><span class="line">...             return &apos;[Value: %s]&apos; % self.data    # User-friendly string</span><br><span class="line">...     def __repr__(self):</span><br><span class="line">...             return &apos;addboth(%s)&apos; % self.data    # As-code string</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; x = addboth(4)</span><br><span class="line">&gt;&gt;&gt; x + 1</span><br><span class="line">&gt;&gt;&gt; x                                               # Runs __repr__</span><br><span class="line">addboth(5)</span><br><span class="line">&gt;&gt;&gt; print(x)                                        # Runs __str__</span><br><span class="line">[Value: 5]</span><br><span class="line">&gt;&gt;&gt; str(x), repr(x)</span><br><span class="line">(&apos;[Value: 5]&apos;, &apos;addboth(5)&apos;)</span><br></pre></td></tr></table></figure>

<p>实例对象的默认显示既无用也不好看</p>
<p>两种显示方法可以进行用户友好的显示</p>
<blockquote>
<ul>
<li>打印操作会首先尝试<code>__str__</code>和<code>str</code>内置函数,通常返回一个用户友好的显示</li>
<li><code>__repr__</code>用于交互提示模式以及<code>repr</code>函数等其他没有<code>__str__</code>时的任何环境,通常返回一个编码字符串,可以用来重新创建对象或给开发者一个详细的显示</li>
<li><code>print</code>和<code>str</code>在定义<code>__str__</code>时调用<code>__str__</code>,否则调用<code>__repr__</code></li>
</ul>
</blockquote>
<p>如果想让所有环境都有统一的显示,<code>__repr__</code>是最佳选择,通过分别定义两个方法可以在不同环境内支持不同显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Printer:</span><br><span class="line">...     def __init__(self, val):</span><br><span class="line">...             self.val = val</span><br><span class="line">...     def __str__(self):              # Used for instance itself</span><br><span class="line">...             return str(self.val)    # COnvert to a string result</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; objs = [Printer(2), Printer(3)]</span><br><span class="line">&gt;&gt;&gt; for x in objs: print(x)             # __str__ run when instance printed</span><br><span class="line">...                                     # But not when instance in a list!</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; print(objs)</span><br><span class="line">[&lt;__main__.Printer object at 0x1048c57b8&gt;, &lt;__main__.Printer object at 0x1048c57f0&gt;]</span><br><span class="line">&gt;&gt;&gt; objs</span><br><span class="line">[&lt;__main__.Printer object at 0x1048c57b8&gt;, &lt;__main__.Printer object at 0x1048c57f0&gt;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; class Printer:</span><br><span class="line">...     def __init__(self, val):</span><br><span class="line">...             self.val = val</span><br><span class="line">...     def __repr__(self):             # __repr__ used by print if no __str__</span><br><span class="line">...             return str(self.val)    # __repr__ used if echoed or nested</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; objs = [Printer(2), Printer(3)]</span><br><span class="line">&gt;&gt;&gt; for x in objs: print(x)             # No __str__: runs __repr__</span><br><span class="line">... </span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; print(objs)                         # Runs __repr__, not __str__</span><br><span class="line">[2, 3]</span><br><span class="line">&gt;&gt;&gt; objs</span><br><span class="line">[2, 3]</span><br></pre></td></tr></table></figure>

<p><code>__str__</code>和<code>__ repr__</code>都必须返回字符串, 其他的结果类型不会转换并会引发错误</p>
<p>根据一个容器的字符串转换逻辑,<code>__str__</code>的用户友好的显示是当对象出现在一个打印操作顶层的时候才应用,嵌套到其他对象中的对象用其<code>__repr__</code>或默认方法打印</p>
<hr>
<h2 id="右侧加法和原处加法-radd-和-iadd"><a href="#右侧加法和原处加法-radd-和-iadd" class="headerlink" title="右侧加法和原处加法:__radd__和__iadd__"></a>右侧加法和原处加法:<code>__radd__</code>和<code>__iadd__</code></h2><p><code>__add__</code>方法只支持<code>+</code>运算符左侧使用实例对象</p>
<p><code>__radd__</code>放在只支持<code>+</code>运算符右侧使用实例对象,而左侧不是实例对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Commuter:</span><br><span class="line">...     def __init__(self, val):</span><br><span class="line">...             self.val = val</span><br><span class="line">...     def __add__(self, other):</span><br><span class="line">...             print(&apos;add&apos;, self.val, other)</span><br><span class="line">...             return self.val + other</span><br><span class="line">...     def __radd__(self, other):</span><br><span class="line">...             print(&apos;radd&apos;, self.val, other)</span><br><span class="line">...             return other + self.val</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; x = Commuter(88)</span><br><span class="line">&gt;&gt;&gt; y = Commuter(99)</span><br><span class="line">&gt;&gt;&gt; x + 1               # __add__:instance + noninstance</span><br><span class="line">add 88 1</span><br><span class="line">89</span><br><span class="line">&gt;&gt;&gt; 1 + y               # __radd__:noninstance + instance</span><br><span class="line">radd 99 1</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; x + y               # __add__:instance + instance, triggers __radd__</span><br><span class="line">add 88 &lt;__main__.Commuter object at 0x1048c5908&gt;</span><br><span class="line">radd 99 88</span><br><span class="line">187</span><br></pre></td></tr></table></figure>

<p>当不同类的实例混合出现在表达式时,Python优先选择左侧的类</p>
<p>当把两个实例相加的时候,Python会运行<code>__add__</code>,通过简化左边的运算数来触发<code>__radd__</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Commuter:</span><br><span class="line">...     def __init__(self, val):</span><br><span class="line">...             self.val = val</span><br><span class="line">...     def __add__(self, other):</span><br><span class="line">...             if isinstance(other, Commuter): other = other.val</span><br><span class="line">...             return Commuter(self.val + other)</span><br><span class="line">...     def __radd__(self, other):</span><br><span class="line">...             return Commuter(other + self.val)</span><br><span class="line">...     def __str__(self):</span><br><span class="line">...             return &apos;&lt;Commuter: %s&gt;&apos; % self.val</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; x = Commuter(88)</span><br><span class="line">&gt;&gt;&gt; y = Commuter(99)</span><br><span class="line">&gt;&gt;&gt; print(x + 10)               # Result is another Commuter instance</span><br><span class="line">&lt;Commuter: 98&gt;</span><br><span class="line">&gt;&gt;&gt; print(10 + y)</span><br><span class="line">&lt;Commuter: 109&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; z = x + y                   # Not nested: doesn&apos;t recur to __radd__</span><br><span class="line">&gt;&gt;&gt; print(z)</span><br><span class="line">&lt;Commuter: 187&gt;</span><br><span class="line">&gt;&gt;&gt; print(z + 10)</span><br><span class="line">&lt;Commuter: 197&gt;</span><br><span class="line">&gt;&gt;&gt; print(z + z)</span><br><span class="line">&lt;Commuter: 374&gt;</span><br></pre></td></tr></table></figure>

<p> 若需要返回类的类型,需要类型测试来辨别是否能够安全地转换并由此避免嵌套</p>
<h3 id="原处加法"><a href="#原处加法" class="headerlink" title="原处加法"></a>原处加法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+=`原处扩展相加会优先调用更加高效的`iadd`,空缺时调用`__add__</span><br><span class="line">  &gt;&gt;&gt; class Number:</span><br><span class="line">  ...     def __init__(self, val):</span><br><span class="line">  ...             self.val = val</span><br><span class="line">  ...     def __iadd__(self, other):                  # __iadd__ explicit: x += y</span><br><span class="line">  ...             self.val += other                   # Usually returns self</span><br><span class="line">  ...             return self</span><br><span class="line">  ... </span><br><span class="line">  &gt;&gt;&gt; x = Number(5)</span><br><span class="line">  &gt;&gt;&gt; x += 1</span><br><span class="line">  &gt;&gt;&gt; x += 1</span><br><span class="line">  &gt;&gt;&gt; x.val</span><br><span class="line">  7</span><br><span class="line">  </span><br><span class="line">  &gt;&gt;&gt; class Number:</span><br><span class="line">  ...     def __init__(self, val):</span><br><span class="line">  ...             self.val = val</span><br><span class="line">  ...     def __add__(self, other):                   # __add__ fallback: x = (x + y)</span><br><span class="line">  ...             return Number(self.val + other)     # Propagates class type</span><br><span class="line">  ... </span><br><span class="line">  &gt;&gt;&gt; x = Number(5)</span><br><span class="line">  &gt;&gt;&gt; x += 1</span><br><span class="line">  &gt;&gt;&gt; x += 1</span><br><span class="line">  &gt;&gt;&gt; x.val</span><br><span class="line">  7</span><br></pre></td></tr></table></figure>

<p>每一个二元运算符都有类似的右侧和原处重载方法,以相同的方式工作</p>
<hr>
<h2 id="Call表达式-call"><a href="#Call表达式-call" class="headerlink" title="Call表达式:__call__"></a>Call表达式:<code>__call__</code></h2><p>定义Python后会为实例应用函数调用表达式,调用时实例时运行<code>__call__</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Callee:</span><br><span class="line">...     def __call__(self, *pargs, **kargs):    # Intercept instance calls</span><br><span class="line">...             print(&apos;Called:&apos;, pargs, kargs)  # Accept arbitrary arguments</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; C = Callee()</span><br><span class="line">&gt;&gt;&gt; C(1, 2, 3)                                  # C is a callable object</span><br><span class="line">Called: (1, 2, 3) &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; C(1, 2, 3, x=4, y=5)</span><br><span class="line">Called: (1, 2, 3) &#123;&apos;x&apos;: 4, &apos;y&apos;: 5&#125;</span><br></pre></td></tr></table></figure>

<p><code>__call__</code>支持所有函数参数传递方式,传递实例的任何内容都会传递给该方法,包括隐式的实例参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Prod:</span><br><span class="line">...     def __init__(self, value):          # Accept just one argument</span><br><span class="line">...             self.value = value</span><br><span class="line">...     def __call__(self, other):</span><br><span class="line">...             return self.value * other</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; x = Prod(2)                             # &quot;Remembers&quot; 2 in state</span><br><span class="line">&gt;&gt;&gt; x(3)                                    # 3 (passed) * 2 (state)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; x(4)</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<p>拦截调用表达式允许类实例模拟类似函数的外观,也在调用中保持了状态信息以供使用</p>
<h3 id="函数接口和回调代码"><a href="#函数接口和回调代码" class="headerlink" title="函数接口和回调代码"></a>函数接口和回调代码</h3><p>如果想让事件处理器保存事件之间的状态,可以注册类的绑定方法或者遵循所需接口的实例(<code>__call__</code>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Callback:</span><br><span class="line">    def __init__(self, color):      # Function + state information</span><br><span class="line">        self.color = color</span><br><span class="line">    def __call__(self):             # Support calls with no arguments</span><br><span class="line">        print(&apos;turn&apos;, self.color)</span><br><span class="line"></span><br><span class="line">cb1 = Callback(&apos;blue&apos;)</span><br><span class="line">cb2 = Callback(&apos;green&apos;)</span><br><span class="line"></span><br><span class="line">B1 = Button(command=cb1)</span><br><span class="line">B2 = Button(command=cb2)</span><br><span class="line"></span><br><span class="line">cb1()   # On events: prints &apos;bule&apos;</span><br><span class="line">cb2()   # Prints &apos;green&apos;</span><br></pre></td></tr></table></figure>

<p>类对象支持函数调用接口,也有状态信息</p>
<p>即使GUI期待的事件处理器是无参数的简单函数,还是可以为按钮把这个类的实例注册成事件处理器</p>
<p>当按钮按下时,将实例对象作为简单的函数调用,但是这个调用保存了以前的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cb3 = (lambda color=&apos;red&apos;: &apos;turn&apos; + color)  # Or:defaults</span><br></pre></td></tr></table></figure>

<p>还可以使用<code>lambda</code>函数的默认参数把信息和回调函数联系起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Callback:</span><br><span class="line">    def __init__(self, color):          # Class with state information</span><br><span class="line">        self.color = color</span><br><span class="line">    def changeColor(self):              # A normal named method</span><br><span class="line">        print(&apos;turn&apos;, self.color)</span><br><span class="line"></span><br><span class="line">cb1 = Callback(&apos;blue&apos;)</span><br><span class="line">cb2 = Callback(&apos;yellow&apos;)</span><br><span class="line">        </span><br><span class="line">B1 = Button(command=cb1.changeColor)    # Reference, but don&apos;t</span><br><span class="line">B2 = Button(command=cb2.changeColor)    # Remembers function + self</span><br><span class="line"></span><br><span class="line">object = Callback(&apos;blue&apos;)               # Registered event handler</span><br><span class="line">cb = object.changeColor                 # On event prints &apos;blue&apos;</span><br><span class="line">cb()</span><br></pre></td></tr></table></figure>

<p>使用类的绑定方法,可以保存<code>self</code>实例以及所引用的函数,通过函数调用来实现</p>
<hr>
<h2 id="比较-lt-、-gt-和其他方法"><a href="#比较-lt-、-gt-和其他方法" class="headerlink" title="比较:__lt__、__gt__和其他方法"></a>比较:<code>__lt__</code>、<code>__gt__</code>和其他方法</h2><p>类调用的方法可以捕获六种比较运算符:<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>==</code>、<code>!=</code></p>
<p>相关限制:</p>
<blockquote>
<ul>
<li><p>与前面讨论的<code>__add__</code> /<code>__radd__</code>对不同,比较方法没有右端形式相反 当只有一个运算数支持比较的时候,使用其对应方法(例如,<code>__lt__</code>和<code>__gt__</code>互为对应)</p>
</li>
<li><p>比较运算符没有隐式关系</p>
<p>==并不意味着!=是假的,因此,<code>__eq_</code>和<code>__ne__</code>应该定义为确保两个运算符都正确地作用</p>
</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class C:</span><br><span class="line">    data = &apos;spam&apos;</span><br><span class="line">    def __gt__(self, other):</span><br><span class="line">        return self.data &gt; other</span><br><span class="line">    def __lt__(self, other):</span><br><span class="line">        return self.data &lt; other</span><br><span class="line"></span><br><span class="line">X = C()</span><br><span class="line">print(X &gt; &apos;ham&apos;)        # True(rusn __gt__)</span><br><span class="line">print(X &lt; &apos;ham&apos;)        # False(rusn __lt__)</span><br></pre></td></tr></table></figure>

<p>拦截并实现了比较表达式</p>
<h3 id="Python-2-6的-cmp-方法-已经从Python-3-0中移除了"><a href="#Python-2-6的-cmp-方法-已经从Python-3-0中移除了" class="headerlink" title="Python 2.6的__cmp__方法(已经从Python 3.0中移除了)"></a>Python 2.6的<code>__cmp__</code>方法(已经从Python 3.0中移除了)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class C:</span><br><span class="line">    data = &apos;spam&apos;                       # 2.6 only</span><br><span class="line">    def __cmp__(self, other):           # __cmp__not used in 3.0</span><br><span class="line">        return cmp(self.data, other)    # cmp not defined in 3.0</span><br><span class="line"></span><br><span class="line">X = C()</span><br><span class="line">print(X &gt; &apos;ham&apos;)                        # True (runs __cmp__)</span><br><span class="line">print(X &lt; &apos;ham&apos;)                        # False (runs __cmp__)</span><br></pre></td></tr></table></figure>

<p><code>__cmp__</code>用来计算正在运行的运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class C:</span><br><span class="line">    data = &apos;spam&apos;</span><br><span class="line">    def __cmp__(self, other):</span><br><span class="line">        return (self.data &gt; other) - (self.data &lt; other)</span><br></pre></td></tr></table></figure>

<p>模拟<code>cmp</code>调用</p>
<hr>
<h2 id="布尔测试-bool-和-len"><a href="#布尔测试-bool-和-len" class="headerlink" title="布尔测试:__bool__和__len__"></a>布尔测试:<code>__bool__</code>和<code>__len__</code></h2><p>在布尔环境中,Python首先尝试<code>__bool__</code>来获取一个直接的布尔值,如果没有该方法,就尝试<code>__len__</code>类根据对象的长度确定一个真值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Truth:</span><br><span class="line">...     def __bool__(self): return True</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; X = Truth()</span><br><span class="line">&gt;&gt;&gt; if X: print(&apos;yes!&apos;)</span><br><span class="line">... </span><br><span class="line">yes!</span><br><span class="line">&gt;&gt;&gt; class Truth:</span><br><span class="line">...     def __bool__(self): return False</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; X = Truth()</span><br><span class="line">&gt;&gt;&gt; bool(X)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>通常使用对象状态或其他信息来生成一个布尔结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Truth:</span><br><span class="line">...     def __len__(self): return 0</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; X = Truth()</span><br><span class="line">&gt;&gt;&gt; if not X: print(&apos;no!&apos;)</span><br><span class="line">... </span><br><span class="line">no!</span><br></pre></td></tr></table></figure>

<p>当没有<code>__bool__</code>方法时Python会调用<code>__len__</code>方法,非空对象看作是真</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Truth:</span><br><span class="line">...     def __bool__(self): return True # 3.0 tries __bool__ first</span><br><span class="line">...     def __len__(self): return 0     # 2.6 tries __len__first</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; X = Truth()</span><br><span class="line">&gt;&gt;&gt; if X: print(&apos;yes!&apos;)</span><br><span class="line">... </span><br><span class="line">yes!</span><br></pre></td></tr></table></figure>

<p>当两个方法都有时优先调用<code>__bool__</code>,因为它更具体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Truth:</span><br><span class="line">...     pass</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; X = Truth()</span><br><span class="line">&gt;&gt;&gt; bool(X)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>当没有定义两个方法时,将对象看作是真</p>
<h3 id="Python-2-6中的布尔"><a href="#Python-2-6中的布尔" class="headerlink" title="Python 2.6中的布尔"></a>Python 2.6中的布尔</h3><p>Python 2.6中的<code>__bool__</code>为<code>__nonzero__</code>,以相同的方式工作</p>
<p>在Python 2.6中<code>__bool__</code>为普通的自定义方法</p>
<hr>
<h2 id="对象析构函数-del"><a href="#对象析构函数-del" class="headerlink" title="对象析构函数:__del__"></a>对象析构函数:<code>__del__</code></h2><p>当实例产生时调用<code>__init__</code>构造函数,当实例空间被收回时,调用<code>__del__</code>析构函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Life:</span><br><span class="line">...     def __init__(self, name=&apos;unknown&apos;):</span><br><span class="line">...             print(&apos;Hello&apos;, name)</span><br><span class="line">...             self.name = name</span><br><span class="line">...     def __del__(self):</span><br><span class="line">...             print(&apos;Goodbye&apos;, self.name)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; brian = Life(&apos;Brian&apos;)</span><br><span class="line">Hello Brian</span><br><span class="line">&gt;&gt;&gt; brian = &apos;loretta&apos;</span><br><span class="line">Goodbye Brian</span><br></pre></td></tr></table></figure>

<p>当类实例的最后一个引用失去时会触发其析构函数</p>
<p>通常在Python中析构函数不像使用其他OOP语言那么常用</p>
<blockquote>
<ul>
<li>Python在实例收回时,会自动收回该实例所拥有的所有空间,对于空间管理来说,是不需要析构函数的</li>
<li>无法轻易地预测实例何时收回,通常最好是在有意调用的方法中(或者<code>try</code>/<code>finally</code>)编写代码去终止活动,在某种情况下,系统表中可能还在引用该对象使析构函数无法执行</li>
</ul>
</blockquote>
<hr>
<h2 id="本章习题-4"><a href="#本章习题-4" class="headerlink" title="本章习题"></a>本章习题</h2><ol>
<li><p>哪两种运算符重载方法可以用来支持类中的迭代</p>
<blockquote>
<p>类可以通过定义(或继承)<code>__getitem__</code>或<code>__iter__</code>来支持迭代</p>
<p>在所有的迭代环境中,Python首先尝试使用<code>__iter__</code> ,它返回支持迭代协议的一个对象,该对象带有一个<code>__next__</code>方法)</p>
<p>如果在继承搜索中没有找到<code>__iter__</code>,Python调用<code>__getitem__</code>索引方法,它可以重复地调用,使用连续较高的索引</p>
</blockquote>
</li>
<li><p>哪两种运算符重载方法处理打印,并且在何种环境下处理</p>
<blockquote>
<p><code>__str__</code>和<code>__ repr__</code>方法实现对象打印显示</p>
<p>前者由<code>print</code>和<code>str</code>内置函数调用 后者总是由<code>repr</code>内置函数、交互式响应和嵌套的出现,如果没有<code>__str__</code>方法也可以由<code>print</code>和<code>str</code>调用</p>
<p><code>__str__</code>通常用于用户友好的显示,<code>__ repr__</code> 给出额外的细节,或者对象的编码形式</p>
</blockquote>
</li>
<li><p>如何在类中拦截分片操作</p>
<blockquote>
<p>分片由<code>__getitem__</code>索引方法捕获:它用一个分片对象调用,而不是一个简单的索引</p>
<p>在Python 2.6中,<code>__getslice__</code> 也可以使用</p>
</blockquote>
</li>
<li><p>如何在类中捕获原处加法</p>
<blockquote>
<p>原处加法首先尝试<code>__iadd__</code>,其次用<code>__add__</code>赋值</p>
<p>同样的模式对于所有的二进制运算也是如此</p>
<p><code>__radd__</code>方法可用于右端相加</p>
</blockquote>
</li>
<li><p>何时应该提供运算符重载</p>
<blockquote>
<p>当一个类自然地匹配的或者需要模拟一个内置类型接口的时候,例如,集合可能模拟序列或映射接口</p>
<p>如果表达式运算符没有自然地映射对象的时候,我们通常不应该实现表达式运算符,而应该使用常规命名的方法</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="第三十章-类的设计"><a href="#第三十章-类的设计" class="headerlink" title="第三十章 类的设计"></a>第三十章 类的设计</h1><blockquote>
<ul>
<li>介绍一些核心的OOP概念,以及一些比目前展示过的例子更实际的额外例子</li>
<li>编写常用的OOP设计模式:继承(从其他类中获取行为)、组合(控制嵌入的对象)、委托(把对象包装在代理类内)和工厂</li>
<li>介绍一些类设计的概念：伪私有属性、多继承和边界方法</li>
</ul>
</blockquote>
<hr>
<h2 id="Python和OOP"><a href="#Python和OOP" class="headerlink" title="Python和OOP"></a>Python和OOP</h2><h3 id="通过调用标记进行重载-或不要"><a href="#通过调用标记进行重载-或不要" class="headerlink" title="通过调用标记进行重载(或不要)"></a>通过调用标记进行重载(或不要)</h3><hr>
<h2 id="OOP和继承-”是一个”关系"><a href="#OOP和继承-”是一个”关系" class="headerlink" title="OOP和继承:”是一个”关系"></a>OOP和继承:”是一个”关系</h2><hr>
<h2 id="OOP和组合-”有一个”关系"><a href="#OOP和组合-”有一个”关系" class="headerlink" title="OOP和组合:”有一个”关系"></a>OOP和组合:”有一个”关系</h2><h3 id="重访流处理器"><a href="#重访流处理器" class="headerlink" title="重访流处理器"></a>重访流处理器</h3><h3 id="为什么要在意-类和持续性"><a href="#为什么要在意-类和持续性" class="headerlink" title="为什么要在意:类和持续性"></a>为什么要在意:类和持续性</h3><hr>
<h2 id="OOP和委托-”包装”对象"><a href="#OOP和委托-”包装”对象" class="headerlink" title="OOP和委托:”包装”对象"></a>OOP和委托:”包装”对象</h2><hr>
<h2 id="类的为私有属性"><a href="#类的为私有属性" class="headerlink" title="类的为私有属性"></a>类的为私有属性</h2><h3 id="变量名压缩概览"><a href="#变量名压缩概览" class="headerlink" title="变量名压缩概览"></a>变量名压缩概览</h3><h3 id="为什么使用伪私有属性"><a href="#为什么使用伪私有属性" class="headerlink" title="为什么使用伪私有属性"></a>为什么使用伪私有属性</h3><hr>
<h2 id="方法是对象-绑定或无绑定"><a href="#方法是对象-绑定或无绑定" class="headerlink" title="方法是对象:绑定或无绑定"></a>方法是对象:绑定或无绑定</h2><h3 id="在Python-3-0中-无绑定方法是函数"><a href="#在Python-3-0中-无绑定方法是函数" class="headerlink" title="在Python 3.0中,无绑定方法是函数"></a>在Python 3.0中,无绑定方法是函数</h3><h3 id="绑定方法和其他可调用对象"><a href="#绑定方法和其他可调用对象" class="headerlink" title="绑定方法和其他可调用对象"></a>绑定方法和其他可调用对象</h3><h3 id="为什么要在意-绑定方法和回调函数"><a href="#为什么要在意-绑定方法和回调函数" class="headerlink" title="为什么要在意:绑定方法和回调函数"></a>为什么要在意:绑定方法和回调函数</h3><hr>
<h2 id="多重继承-”混合”类"><a href="#多重继承-”混合”类" class="headerlink" title="多重继承:”混合”类"></a>多重继承:”混合”类</h2><h3 id="编写混合显示类"><a href="#编写混合显示类" class="headerlink" title="编写混合显示类"></a>编写混合显示类</h3><hr>
<h2 id="类是对象-通用对象的工厂"><a href="#类是对象-通用对象的工厂" class="headerlink" title="类是对象:通用对象的工厂"></a>类是对象:通用对象的工厂</h2><h3 id="为什么有工厂"><a href="#为什么有工厂" class="headerlink" title="为什么有工厂"></a>为什么有工厂</h3><hr>
<h2 id="与设计相关的其他话题"><a href="#与设计相关的其他话题" class="headerlink" title="与设计相关的其他话题"></a>与设计相关的其他话题</h2><hr>
<h2 id="本章习题-5"><a href="#本章习题-5" class="headerlink" title="本章习题"></a>本章习题</h2><ol>
<li><p>什么是多重继承</p>
<blockquote>
<p>当类从一个以上超类继承时,就发生了多重继承</p>
</blockquote>
</li>
<li><p>什么是委托</p>
<blockquote>
<p>委托涉及把对象包装在代理类中,这样代理类会增加额外的行为,而把其他运算传给被包装的对象</p>
<p>代理类包含了被包装的对象的接口</p>
</blockquote>
</li>
<li><p>什么是组合</p>
<blockquote>
<p>组合是一种技术,让控制器类嵌入和引导一群对象,并自行提供接口</p>
<p>是利用类创建较大结构的方式</p>
</blockquote>
</li>
<li><p>什么是绑定方法</p>
<blockquote>
<p>绑定方法结合实例和方法函数</p>
<p>调用时,不用刻意传入实例对象,因为原始的实例依然可用</p>
</blockquote>
</li>
<li><p>为什么使用伪私有属性</p>
<blockquote>
<p>伪私有属性<code>__X</code>用来把名称本地化到类中,包括像定义在类中的方法以及在类中赋值的<code>self</code>实例属性</p>
<p>这样的名称扩展来包含类名称,类名称使得它们独特</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="第三十一章-类的高级主题"><a href="#第三十一章-类的高级主题" class="headerlink" title="第三十一章 类的高级主题"></a>第三十一章 类的高级主题</h1><blockquote>
<ul>
<li>研究如何加了你内置类型的子类、新式类的变化和拓展、静态方法和类方法、函数装饰器等</li>
<li>介绍类的相关陷阱</li>
</ul>
</blockquote>
<hr>
<h2 id="拓展内置类型"><a href="#拓展内置类型" class="headerlink" title="拓展内置类型"></a>拓展内置类型</h2><h3 id="通过嵌入扩展类型"><a href="#通过嵌入扩展类型" class="headerlink" title="通过嵌入扩展类型"></a>通过嵌入扩展类型</h3><h3 id="通过子类扩展类型"><a href="#通过子类扩展类型" class="headerlink" title="通过子类扩展类型"></a>通过子类扩展类型</h3><hr>
<h2 id="新式类"><a href="#新式类" class="headerlink" title="新式类"></a>新式类</h2><hr>
<h2 id="新式类变化"><a href="#新式类变化" class="headerlink" title="新式类变化"></a>新式类变化</h2><h3 id="类型模式变化"><a href="#类型模式变化" class="headerlink" title="类型模式变化"></a>类型模式变化</h3><h3 id="钻石继承变动"><a href="#钻石继承变动" class="headerlink" title="钻石继承变动"></a>钻石继承变动</h3><hr>
<h2 id="新式类的扩展"><a href="#新式类的扩展" class="headerlink" title="新式类的扩展"></a>新式类的扩展</h2><h3 id="slots实例"><a href="#slots实例" class="headerlink" title="slots实例"></a>slots实例</h3><h3 id="类特性"><a href="#类特性" class="headerlink" title="类特性"></a>类特性</h3><h3 id="getattrbute-和描述符"><a href="#getattrbute-和描述符" class="headerlink" title="__getattrbute__和描述符"></a><code>__getattrbute__</code>和描述符</h3><h3 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h3><hr>
<h2 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h2><h3 id="为什么使用特殊方法"><a href="#为什么使用特殊方法" class="headerlink" title="为什么使用特殊方法"></a>为什么使用特殊方法</h3><h3 id="Python-2-6和Python-3-0中的静态方法"><a href="#Python-2-6和Python-3-0中的静态方法" class="headerlink" title="Python 2.6和Python 3.0中的静态方法"></a>Python 2.6和Python 3.0中的静态方法</h3><h3 id="静态方法替代方案"><a href="#静态方法替代方案" class="headerlink" title="静态方法替代方案"></a>静态方法替代方案</h3><h3 id="使用静态和类方法"><a href="#使用静态和类方法" class="headerlink" title="使用静态和类方法"></a>使用静态和类方法</h3><h3 id="使用静态方法统计实例"><a href="#使用静态方法统计实例" class="headerlink" title="使用静态方法统计实例"></a>使用静态方法统计实例</h3><h3 id="用类方法统计实例"><a href="#用类方法统计实例" class="headerlink" title="用类方法统计实例"></a>用类方法统计实例</h3><hr>
<h2 id="装饰器和元类-第一部分"><a href="#装饰器和元类-第一部分" class="headerlink" title="装饰器和元类:第一部分"></a>装饰器和元类:第一部分</h2><h3 id="函数装饰器基础"><a href="#函数装饰器基础" class="headerlink" title="函数装饰器基础"></a>函数装饰器基础</h3><h3 id="装饰器例子"><a href="#装饰器例子" class="headerlink" title="装饰器例子"></a>装饰器例子</h3><h3 id="类装饰器和元类"><a href="#类装饰器和元类" class="headerlink" title="类装饰器和元类"></a>类装饰器和元类</h3><h3 id="更多详细信息"><a href="#更多详细信息" class="headerlink" title="更多详细信息"></a>更多详细信息</h3><hr>
<h2 id="类陷阱"><a href="#类陷阱" class="headerlink" title="类陷阱"></a>类陷阱</h2><h3 id="修改类属性的副作用"><a href="#修改类属性的副作用" class="headerlink" title="修改类属性的副作用"></a>修改类属性的副作用</h3><h3 id="修改可变的类属性也可能产生副作用"><a href="#修改可变的类属性也可能产生副作用" class="headerlink" title="修改可变的类属性也可能产生副作用"></a>修改可变的类属性也可能产生副作用</h3><h3 id="多重继承-顺序很重要"><a href="#多重继承-顺序很重要" class="headerlink" title="多重继承:顺序很重要"></a>多重继承:顺序很重要</h3><h3 id="类、方法以及嵌套作用域"><a href="#类、方法以及嵌套作用域" class="headerlink" title="类、方法以及嵌套作用域"></a>类、方法以及嵌套作用域</h3><h3 id="Python中基于委托的类-getattr-和内置函数"><a href="#Python中基于委托的类-getattr-和内置函数" class="headerlink" title="Python中基于委托的类:__getattr__和内置函数"></a>Python中基于委托的类:<code>__getattr__</code>和内置函数</h3><h3 id="“过度包装”"><a href="#“过度包装”" class="headerlink" title="“过度包装”"></a>“过度包装”</h3><hr>
<h2 id="本章习题-6"><a href="#本章习题-6" class="headerlink" title="本章习题"></a>本章习题</h2><ol>
<li><p>列举出两种能够扩展内置对象类型的方法</p>
<blockquote>
<p>你可以在包装类中内嵌内置对象,或者直接做内置类型的子类</p>
<p>后者显得更简单,因为大多数原始的行为都被自动继承了</p>
</blockquote>
</li>
<li><p>函数修饰器是用来做什么的</p>
<blockquote>
<p>函数修饰器通常是用来给现存的函数增加函数每次被调用时都会运行的一层逻辑<br>它们可以用来记录函数的日志或调用次数、检查参数的类型等</p>
<p>它们同样可以用做”静态方法”(一个在类中的函数,不需要传人实例)</p>
</blockquote>
</li>
<li><p>怎样编写新式类</p>
<blockquote>
<p>可以通过对对象的内置类(或者其他的内置类型)继承来编写新式类</p>
<p>在Python 3.0中,所有的类都将会自动成为新式类,因此不需要这么派生</p>
<p>在Python 2.6中,这样派生出来的类是新式类,那些没有派生的类是”经典类”</p>
</blockquote>
</li>
<li><p>新式类与经典类有何不同</p>
<blockquote>
<p>新式类与多重继承树中的钻石搜索模式有所不同,它们实际上是以广度优先(横向)进行搜索的,而不是深度优先(向上)</p>
<p>新式类还针对实例和类修改了type内置函数的结果,针对内置操作方法,没有运行<code>__getattr__</code>这样的通用属性获取方法,并且支持包括特性、描述符和<code>__slots__</code>实例属性列表这样的一组高级额外工具</p>
</blockquote>
</li>
<li><p>正常方法和静态方法有何不同</p>
<blockquote>
<p>正常(实例)方法会接受第一个<code>self</code>参数(隐含的实例),但是静态方法不是这样</p>
<p>静态方祛只是嵌套在类对象中的简单函数</p>
<p>为了使一个方法成为静态方法,它必须可以通过特殊的内置函数运行,或者使用装饰器进行装饰</p>
<p>Python 3.0允许通过类而没有这个步骤就调用类中的简单函数,但是,通过实例调用仍然需要静态方法声明</p>
</blockquote>
</li>
</ol>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="http://abcdefghijklmnopqrst.xyz">骑麦兜看落日</a>
            <p>原文链接：<a href="http://abcdefghijklmnopqrst.xyz/2018/08/14/Code_Python学习手册_6/">http://abcdefghijklmnopqrst.xyz/2018/08/14/Code_Python学习手册_6/</a>
            <p>发表日期：<a href="http://abcdefghijklmnopqrst.xyz/2018/08/14/Code_Python学习手册_6/">August 14th 2018, 10:00:00 pm</a>
            <p>更新日期：<a href="http://abcdefghijklmnopqrst.xyz/2018/08/14/Code_Python学习手册_6/">August 14th 2018, 10:00:00 pm</a>
            <p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2018/08/21/WP_网鼎杯/" title= "[WriteUp]网鼎杯">
                    <div class="nextTitle">[WriteUp]网鼎杯</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2018/08/13/WP_JarvisOJ/" title= "[WriteUp]JarvisOJ">
                    <div class="prevTitle">[WriteUp]JarvisOJ</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

    <div id="lv-container" data-id="city" data-uid= MTAyMC8zNzY1OS8xNDE5MA==>
        <script type="text/javascript">
            (function (d, s) {
                var j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') { return; }
                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:qimaidoukanluori@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/qimaidoukanluori" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">到访的小伙伴: <span id="busuanzi_value_site_pv"></span>只 </span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:30vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第二十五章-OOP-宏伟蓝图"><span class="toc-number">1.</span> <span class="toc-text">第二十五章 OOP:宏伟蓝图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#为何使用类"><span class="toc-number">1.1.</span> <span class="toc-text">为何使用类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#概览OOP"><span class="toc-number">1.2.</span> <span class="toc-text">概览OOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性继承搜索"><span class="toc-number">1.2.1.</span> <span class="toc-text">属性继承搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类和实例"><span class="toc-number">1.2.2.</span> <span class="toc-text">类和实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类方法调用"><span class="toc-number">1.2.3.</span> <span class="toc-text">类方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编写类树"><span class="toc-number">1.2.4.</span> <span class="toc-text">编写类树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OOP是为了代码重用"><span class="toc-number">1.2.5.</span> <span class="toc-text">OOP是为了代码重用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章习题"><span class="toc-number">1.3.</span> <span class="toc-text">本章习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二十六章-类代码编写基础"><span class="toc-number">2.</span> <span class="toc-text">第二十六章 类代码编写基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#类产生多个实例对象"><span class="toc-number">2.1.</span> <span class="toc-text">类产生多个实例对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类对象提供默认行为"><span class="toc-number">2.1.1.</span> <span class="toc-text">类对象提供默认行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例对象是具体的元素"><span class="toc-number">2.1.2.</span> <span class="toc-text">实例对象是具体的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第一个例子"><span class="toc-number">2.1.3.</span> <span class="toc-text">第一个例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类通过继承进行定制"><span class="toc-number">2.2.</span> <span class="toc-text">类通过继承进行定制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第二个例子"><span class="toc-number">2.2.1.</span> <span class="toc-text">第二个例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类是模块内的属性"><span class="toc-number">2.2.2.</span> <span class="toc-text">类是模块内的属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类可以截获Python运算符"><span class="toc-number">2.3.</span> <span class="toc-text">类可以截获Python运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第三个例子"><span class="toc-number">2.3.1.</span> <span class="toc-text">第三个例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要使用运算符重载"><span class="toc-number">2.3.2.</span> <span class="toc-text">为什么要使用运算符重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#世界上最简单的Python类"><span class="toc-number">2.4.</span> <span class="toc-text">世界上最简单的Python类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类与字典的关系"><span class="toc-number">2.4.1.</span> <span class="toc-text">类与字典的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章习题-1"><span class="toc-number">2.5.</span> <span class="toc-text">本章习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二十七章-更多实例"><span class="toc-number">3.</span> <span class="toc-text">第二十七章 更多实例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤1-创建实例"><span class="toc-number">3.1.</span> <span class="toc-text">步骤1:创建实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编写构造函数"><span class="toc-number">3.1.1.</span> <span class="toc-text">编写构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在进行中测试"><span class="toc-number">3.1.2.</span> <span class="toc-text">在进行中测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#以两种方式使用代码"><span class="toc-number">3.1.3.</span> <span class="toc-text">以两种方式使用代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤2-添加行为方法"><span class="toc-number">3.2.</span> <span class="toc-text">步骤2:添加行为方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编写方法"><span class="toc-number">3.2.1.</span> <span class="toc-text">编写方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤3-运算符重载"><span class="toc-number">3.3.</span> <span class="toc-text">步骤3:运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#提供打印显示"><span class="toc-number">3.3.1.</span> <span class="toc-text">提供打印显示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤4-通过子类定制行为"><span class="toc-number">3.4.</span> <span class="toc-text">步骤4:通过子类定制行为</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编写子类"><span class="toc-number">3.4.1.</span> <span class="toc-text">编写子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓展方法-不好的方式"><span class="toc-number">3.4.2.</span> <span class="toc-text">拓展方法:不好的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓展方法-好的方式"><span class="toc-number">3.4.3.</span> <span class="toc-text">拓展方法:好的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态的作用"><span class="toc-number">3.4.4.</span> <span class="toc-text">多态的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承、定制和扩展"><span class="toc-number">3.4.5.</span> <span class="toc-text">继承、定制和扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OOP-大思路"><span class="toc-number">3.4.6.</span> <span class="toc-text">OOP:大思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤5-定制构造函数"><span class="toc-number">3.5.</span> <span class="toc-text">步骤5:定制构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OOP比我们认为的要简单"><span class="toc-number">3.5.1.</span> <span class="toc-text">OOP比我们认为的要简单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组合类的其他方法"><span class="toc-number">3.5.2.</span> <span class="toc-text">组合类的其他方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在Python-3-0中捕获内置属性"><span class="toc-number">3.5.3.</span> <span class="toc-text">在Python 3.0中捕获内置属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤6-使用内省工具"><span class="toc-number">3.6.</span> <span class="toc-text">步骤6:使用内省工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特殊类属性"><span class="toc-number">3.6.1.</span> <span class="toc-text">特殊类属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一种通用显示工具"><span class="toc-number">3.6.2.</span> <span class="toc-text">一种通用显示工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例与类属性的关系"><span class="toc-number">3.6.3.</span> <span class="toc-text">实例与类属性的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工具类的命名考虑"><span class="toc-number">3.6.4.</span> <span class="toc-text">工具类的命名考虑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的最终形式"><span class="toc-number">3.6.5.</span> <span class="toc-text">类的最终形式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤7-最后一步-把对象存储到数据库中"><span class="toc-number">3.7.</span> <span class="toc-text">步骤7(最后一步):把对象存储到数据库中</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PIckle和Shelve"><span class="toc-number">3.7.1.</span> <span class="toc-text">PIckle和Shelve</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在shelve数据库中存储对象"><span class="toc-number">3.7.2.</span> <span class="toc-text">在shelve数据库中存储对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#交互地探索shelve"><span class="toc-number">3.7.3.</span> <span class="toc-text">交互地探索shelve</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新shelve中的对象"><span class="toc-number">3.7.4.</span> <span class="toc-text">更新shelve中的对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#未来方向"><span class="toc-number">3.8.</span> <span class="toc-text">未来方向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章习题-2"><span class="toc-number">3.9.</span> <span class="toc-text">本章习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二十八章-类代码编写细节"><span class="toc-number">4.</span> <span class="toc-text">第二十八章 类代码编写细节</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#class语句"><span class="toc-number">4.1.</span> <span class="toc-text">class语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一般形式"><span class="toc-number">4.1.1.</span> <span class="toc-text">一般形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例子"><span class="toc-number">4.1.2.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法"><span class="toc-number">4.2.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例子-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用超类构造函数"><span class="toc-number">4.2.2.</span> <span class="toc-text">调用超类构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他方法调用的可能性"><span class="toc-number">4.2.3.</span> <span class="toc-text">其他方法调用的可能性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-number">4.3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性树的构造"><span class="toc-number">4.3.1.</span> <span class="toc-text">属性树的构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承方法的专有化"><span class="toc-number">4.3.2.</span> <span class="toc-text">继承方法的专有化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类接口技术"><span class="toc-number">4.3.3.</span> <span class="toc-text">类接口技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象超类"><span class="toc-number">4.3.4.</span> <span class="toc-text">抽象超类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-2-6和Python-3-0的抽象超类"><span class="toc-number">4.3.5.</span> <span class="toc-text">Python 2.6和Python 3.0的抽象超类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#命名空间-完整的内容"><span class="toc-number">4.4.</span> <span class="toc-text">命名空间:完整的内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简单变量名-如果赋值就不是全局变量"><span class="toc-number">4.4.1.</span> <span class="toc-text">简单变量名:如果赋值就不是全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性名称-对象命名空间"><span class="toc-number">4.4.2.</span> <span class="toc-text">属性名称:对象命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python命名空间的”禅”-赋值将变量名分类"><span class="toc-number">4.4.3.</span> <span class="toc-text">Python命名空间的”禅”:赋值将变量名分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命名空间字典"><span class="toc-number">4.4.4.</span> <span class="toc-text">命名空间字典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命名空间链接"><span class="toc-number">4.4.5.</span> <span class="toc-text">命名空间链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回顾文档字符串"><span class="toc-number">4.5.</span> <span class="toc-text">回顾文档字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类与模块的关系"><span class="toc-number">4.6.</span> <span class="toc-text">类与模块的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章习题-3"><span class="toc-number">4.7.</span> <span class="toc-text">本章习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二十九章-运算符重载"><span class="toc-number">5.</span> <span class="toc-text">第二十九章 运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础知识"><span class="toc-number">5.1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数和表达式-init-和-sub"><span class="toc-number">5.1.1.</span> <span class="toc-text">构造函数和表达式:__init__和__sub__</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见的运算符重载方法"><span class="toc-number">5.1.2.</span> <span class="toc-text">常见的运算符重载方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引和分片-getitem-和-setitem"><span class="toc-number">5.2.</span> <span class="toc-text">索引和分片:__getitem__和__setitem__</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#拦截分片"><span class="toc-number">5.2.1.</span> <span class="toc-text">拦截分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-2-6中的分片和索引"><span class="toc-number">5.2.2.</span> <span class="toc-text">Python 2.6中的分片和索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引迭代-getitem"><span class="toc-number">5.3.</span> <span class="toc-text">索引迭代:__getitem__</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代器对象-iter-和-next"><span class="toc-number">5.4.</span> <span class="toc-text">迭代器对象:__iter__和__next__</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用户定义的迭代器"><span class="toc-number">5.4.1.</span> <span class="toc-text">用户定义的迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有多个迭代器的对象"><span class="toc-number">5.4.2.</span> <span class="toc-text">有多个迭代器的对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#成员关系-contains-、-iter-和-getitem"><span class="toc-number">5.5.</span> <span class="toc-text">成员关系:__contains__、__iter__和__getitem__</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#属性引用-getattr-和-setattr"><span class="toc-number">5.6.</span> <span class="toc-text">属性引用:__getattr__和__setattr__</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#其他属性管理工具"><span class="toc-number">5.6.1.</span> <span class="toc-text">其他属性管理工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模拟实例属性的私有性-第一部分"><span class="toc-number">5.6.2.</span> <span class="toc-text">模拟实例属性的私有性:第一部分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#repr-和-str-会返回字符串表达式形式"><span class="toc-number">5.7.</span> <span class="toc-text">__repr__和__str__会返回字符串表达式形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#右侧加法和原处加法-radd-和-iadd"><span class="toc-number">5.8.</span> <span class="toc-text">右侧加法和原处加法:__radd__和__iadd__</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原处加法"><span class="toc-number">5.8.1.</span> <span class="toc-text">原处加法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Call表达式-call"><span class="toc-number">5.9.</span> <span class="toc-text">Call表达式:__call__</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数接口和回调代码"><span class="toc-number">5.9.1.</span> <span class="toc-text">函数接口和回调代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#比较-lt-、-gt-和其他方法"><span class="toc-number">5.10.</span> <span class="toc-text">比较:__lt__、__gt__和其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-2-6的-cmp-方法-已经从Python-3-0中移除了"><span class="toc-number">5.10.1.</span> <span class="toc-text">Python 2.6的__cmp__方法(已经从Python 3.0中移除了)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#布尔测试-bool-和-len"><span class="toc-number">5.11.</span> <span class="toc-text">布尔测试:__bool__和__len__</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-2-6中的布尔"><span class="toc-number">5.11.1.</span> <span class="toc-text">Python 2.6中的布尔</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象析构函数-del"><span class="toc-number">5.12.</span> <span class="toc-text">对象析构函数:__del__</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章习题-4"><span class="toc-number">5.13.</span> <span class="toc-text">本章习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三十章-类的设计"><span class="toc-number">6.</span> <span class="toc-text">第三十章 类的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python和OOP"><span class="toc-number">6.1.</span> <span class="toc-text">Python和OOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通过调用标记进行重载-或不要"><span class="toc-number">6.1.1.</span> <span class="toc-text">通过调用标记进行重载(或不要)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OOP和继承-”是一个”关系"><span class="toc-number">6.2.</span> <span class="toc-text">OOP和继承:”是一个”关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OOP和组合-”有一个”关系"><span class="toc-number">6.3.</span> <span class="toc-text">OOP和组合:”有一个”关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#重访流处理器"><span class="toc-number">6.3.1.</span> <span class="toc-text">重访流处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要在意-类和持续性"><span class="toc-number">6.3.2.</span> <span class="toc-text">为什么要在意:类和持续性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OOP和委托-”包装”对象"><span class="toc-number">6.4.</span> <span class="toc-text">OOP和委托:”包装”对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类的为私有属性"><span class="toc-number">6.5.</span> <span class="toc-text">类的为私有属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#变量名压缩概览"><span class="toc-number">6.5.1.</span> <span class="toc-text">变量名压缩概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么使用伪私有属性"><span class="toc-number">6.5.2.</span> <span class="toc-text">为什么使用伪私有属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法是对象-绑定或无绑定"><span class="toc-number">6.6.</span> <span class="toc-text">方法是对象:绑定或无绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在Python-3-0中-无绑定方法是函数"><span class="toc-number">6.6.1.</span> <span class="toc-text">在Python 3.0中,无绑定方法是函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绑定方法和其他可调用对象"><span class="toc-number">6.6.2.</span> <span class="toc-text">绑定方法和其他可调用对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要在意-绑定方法和回调函数"><span class="toc-number">6.6.3.</span> <span class="toc-text">为什么要在意:绑定方法和回调函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多重继承-”混合”类"><span class="toc-number">6.7.</span> <span class="toc-text">多重继承:”混合”类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编写混合显示类"><span class="toc-number">6.7.1.</span> <span class="toc-text">编写混合显示类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类是对象-通用对象的工厂"><span class="toc-number">6.8.</span> <span class="toc-text">类是对象:通用对象的工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么有工厂"><span class="toc-number">6.8.1.</span> <span class="toc-text">为什么有工厂</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#与设计相关的其他话题"><span class="toc-number">6.9.</span> <span class="toc-text">与设计相关的其他话题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章习题-5"><span class="toc-number">6.10.</span> <span class="toc-text">本章习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三十一章-类的高级主题"><span class="toc-number">7.</span> <span class="toc-text">第三十一章 类的高级主题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#拓展内置类型"><span class="toc-number">7.1.</span> <span class="toc-text">拓展内置类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通过嵌入扩展类型"><span class="toc-number">7.1.1.</span> <span class="toc-text">通过嵌入扩展类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过子类扩展类型"><span class="toc-number">7.1.2.</span> <span class="toc-text">通过子类扩展类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新式类"><span class="toc-number">7.2.</span> <span class="toc-text">新式类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新式类变化"><span class="toc-number">7.3.</span> <span class="toc-text">新式类变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类型模式变化"><span class="toc-number">7.3.1.</span> <span class="toc-text">类型模式变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#钻石继承变动"><span class="toc-number">7.3.2.</span> <span class="toc-text">钻石继承变动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新式类的扩展"><span class="toc-number">7.4.</span> <span class="toc-text">新式类的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#slots实例"><span class="toc-number">7.4.1.</span> <span class="toc-text">slots实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类特性"><span class="toc-number">7.4.2.</span> <span class="toc-text">类特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getattrbute-和描述符"><span class="toc-number">7.4.3.</span> <span class="toc-text">__getattrbute__和描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元类"><span class="toc-number">7.4.4.</span> <span class="toc-text">元类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态方法和类方法"><span class="toc-number">7.5.</span> <span class="toc-text">静态方法和类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么使用特殊方法"><span class="toc-number">7.5.1.</span> <span class="toc-text">为什么使用特殊方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-2-6和Python-3-0中的静态方法"><span class="toc-number">7.5.2.</span> <span class="toc-text">Python 2.6和Python 3.0中的静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态方法替代方案"><span class="toc-number">7.5.3.</span> <span class="toc-text">静态方法替代方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用静态和类方法"><span class="toc-number">7.5.4.</span> <span class="toc-text">使用静态和类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用静态方法统计实例"><span class="toc-number">7.5.5.</span> <span class="toc-text">使用静态方法统计实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用类方法统计实例"><span class="toc-number">7.5.6.</span> <span class="toc-text">用类方法统计实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#装饰器和元类-第一部分"><span class="toc-number">7.6.</span> <span class="toc-text">装饰器和元类:第一部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数装饰器基础"><span class="toc-number">7.6.1.</span> <span class="toc-text">函数装饰器基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#装饰器例子"><span class="toc-number">7.6.2.</span> <span class="toc-text">装饰器例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类装饰器和元类"><span class="toc-number">7.6.3.</span> <span class="toc-text">类装饰器和元类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更多详细信息"><span class="toc-number">7.6.4.</span> <span class="toc-text">更多详细信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类陷阱"><span class="toc-number">7.7.</span> <span class="toc-text">类陷阱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#修改类属性的副作用"><span class="toc-number">7.7.1.</span> <span class="toc-text">修改类属性的副作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修改可变的类属性也可能产生副作用"><span class="toc-number">7.7.2.</span> <span class="toc-text">修改可变的类属性也可能产生副作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多重继承-顺序很重要"><span class="toc-number">7.7.3.</span> <span class="toc-text">多重继承:顺序很重要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类、方法以及嵌套作用域"><span class="toc-number">7.7.4.</span> <span class="toc-text">类、方法以及嵌套作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python中基于委托的类-getattr-和内置函数"><span class="toc-number">7.7.5.</span> <span class="toc-text">Python中基于委托的类:__getattr__和内置函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#“过度包装”"><span class="toc-number">7.7.6.</span> <span class="toc-text">“过度包装”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章习题-6"><span class="toc-number">7.8.</span> <span class="toc-text">本章习题</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 50
        </div>
        <!-- search  -->
        
            <div class="site-search popup-trigger">
                <span class="iconfont-archer search-icon">&#xe627;</span>
            </div>
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/09</span><a class="archive-post-title" href= "/2019/12/09/Binary_Iot设备如何拿到调试shell/" >[Binary]Iot设备如何拿到调试shell</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/30</span><a class="archive-post-title" href= "/2019/10/30/Binary_Unicorn学习/" >[Binary]Unicorn学习</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2019/09/10/WP_2019ByteCTF/" >[WriteUp]2019ByteCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/26</span><a class="archive-post-title" href= "/2019/08/26/WP_2019OGeek/" >[WriteUp]2019OGeek</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/31</span><a class="archive-post-title" href= "/2019/07/31/WP_2019CISCN final/" >[WriteUp]2019CISCN final</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/07</span><a class="archive-post-title" href= "/2019/07/07/WP_2019WCTF/" >[WriteUp]2019WCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/02</span><a class="archive-post-title" href= "/2019/07/02/Asm_WASM格式化字符串攻击尝试/" >[Asm]WASM格式化字符串攻击尝试</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/22</span><a class="archive-post-title" href= "/2019/01/22/Code_Python可变类型的一些问题/" >[Code]Python可变类型的一些问题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/13</span><a class="archive-post-title" href= "/2019/01/13/Asm_WASM初步/" >[Asm]WASM初步</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/20</span><a class="archive-post-title" href= "/2018/12/20/Binary_通过a的leak/" >[Binary]通过%a的leak</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/07</span><a class="archive-post-title" href= "/2018/12/07/WP_hxpCTF/" >[WriteUp]hxpCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/27</span><a class="archive-post-title" href= "/2018/11/27/WP_2018BCTF/" >[WriteUp]2018BCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/14</span><a class="archive-post-title" href= "/2018/11/14/Binary_IO_FILE源码分析/" >[Binary]IO_FILE</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/05</span><a class="archive-post-title" href= "/2018/11/05/Binary_ArmPwn/" >[Asm]ARMPwn</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/04</span><a class="archive-post-title" href= "/2018/11/04/WP_上海杯/" >[WriteUp]上海杯</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/27</span><a class="archive-post-title" href= "/2018/10/27/WP_HCTF/" >[WriteUp]HCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/27</span><a class="archive-post-title" href= "/2018/10/27/WP_SECCONCTF/" >[WriteUp]SECCONCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/27</span><a class="archive-post-title" href= "/2018/10/27/WP_湖湘杯/" >[WriteUp]湖湘杯</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href= "/2018/10/24/Binary_Tcache/" >[Binary]Tcache</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/17</span><a class="archive-post-title" href= "/2018/10/17/Asm_RealmodeAsm/" >[Asm]RealmodeAsm</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/13</span><a class="archive-post-title" href= "/2018/10/13/WP_2018护网杯/" >[WriteUp]护网杯</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/06</span><a class="archive-post-title" href= "/2018/10/06/Binary_IDADynamic/" >[Binary]IDADynamic</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2018/10/05/Linux_pwn环境搭建/" >[Linux]pwn环境搭建</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2018/10/05/WP_DragonCTF/" >[WriteUp]DefCampCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2018/10/05/WP_InCTF/" >[WriteUp]InCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span><a class="archive-post-title" href= "/2018/09/28/Binary_PDF/" >[Binary]PDF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/27</span><a class="archive-post-title" href= "/2018/09/27/Linux_GDB的python调试/" >[Linux]GDB的Python调试</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/27</span><a class="archive-post-title" href= "/2018/09/27/Linux_GDB/" >[Linux]GDB</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/25</span><a class="archive-post-title" href= "/2018/09/25/WP_DefCampCTF/" >[WriteUp]DefCampCTF</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/18</span><a class="archive-post-title" href= "/2018/09/18/Android_JNI/" >[Android]JNI</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/18</span><a class="archive-post-title" href= "/2018/09/18/BInary_HeapExploit/" >[Binary]HeapExploit</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/13</span><a class="archive-post-title" href= "/2018/09/13/Binary_IO_FILE/" >[Binary]IO_FILE</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2018/09/10/Linux_GDB的源码调试/" >[Linux]GDB源码调试</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/01</span><a class="archive-post-title" href= "/2018/09/01/Binary_ptmalloc源码分析/" >[Binary]ptmalloc源码分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/25</span><a class="archive-post-title" href= "/2018/08/25/WP_pwnable.tw/" >[WriteUp]pwnable.tw</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/21</span><a class="archive-post-title" href= "/2018/08/21/Code_Python学习手册_7/" >[Code]Python学习手册_第七部分_异常和工具</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/21</span><a class="archive-post-title" href= "/2018/08/21/WP_网鼎杯/" >[WriteUp]网鼎杯</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/14</span><a class="archive-post-title" href= "/2018/08/14/Code_Python学习手册_6/" >[Code]Python学习手册_第六部分_类和OOP</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/13</span><a class="archive-post-title" href= "/2018/08/13/WP_JarvisOJ/" >[WriteUp]JarvisOJ</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/10</span><a class="archive-post-title" href= "/2018/08/10/Code_Python学习手册_5/" >[Code]Python学习手册_第五部分_模块</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/05</span><a class="archive-post-title" href= "/2018/08/05/Code_Python学习手册_4/" >[Code]Python学习手册_第四部分_函数</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/05</span><a class="archive-post-title" href= "/2018/08/05/Binary_Heap/" >[Binary]Heap</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/30</span><a class="archive-post-title" href= "/2018/07/30/Linux_INT80/" >[Linux]int 80</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/30</span><a class="archive-post-title" href= "/2018/07/30/Code_Python学习手册_3/" >[Code]Python学习手册_第三部分_语句和语法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/25</span><a class="archive-post-title" href= "/2018/07/25/Binary_Canary/" >[Binary]Canary</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/24</span><a class="archive-post-title" href= "/2018/07/24/Code_Python学习手册_2/" >[Code]Python学习手册_第二部分_类型和运算</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/22</span><a class="archive-post-title" href= "/2018/07/22/Binary_fmt/" >[Binary]FormatString</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/21</span><a class="archive-post-title" href= "/2018/07/21/Code_Python学习手册_1/" >[Code]Python学习手册_第一部分_使用入门</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/21</span><a class="archive-post-title" href= "/2018/07/21/WP_巅峰极客/" >[WriteUp]巅峰极客</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/22</span><a class="archive-post-title" href= "/2018/01/22/Code_Python的C拓展/" >[Code]Python的C拓展</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="Note"><span class="iconfont-archer">&#xe606;</span>Note</span>
    
        <span class="sidebar-tag-name" data-tags="Assembly"><span class="iconfont-archer">&#xe606;</span>Assembly</span>
    
        <span class="sidebar-tag-name" data-tags="Android"><span class="iconfont-archer">&#xe606;</span>Android</span>
    
        <span class="sidebar-tag-name" data-tags="Java"><span class="iconfont-archer">&#xe606;</span>Java</span>
    
        <span class="sidebar-tag-name" data-tags="JNI"><span class="iconfont-archer">&#xe606;</span>JNI</span>
    
        <span class="sidebar-tag-name" data-tags="WASM"><span class="iconfont-archer">&#xe606;</span>WASM</span>
    
        <span class="sidebar-tag-name" data-tags="Binary"><span class="iconfont-archer">&#xe606;</span>Binary</span>
    
        <span class="sidebar-tag-name" data-tags="Pwn"><span class="iconfont-archer">&#xe606;</span>Pwn</span>
    
        <span class="sidebar-tag-name" data-tags="Heap"><span class="iconfont-archer">&#xe606;</span>Heap</span>
    
        <span class="sidebar-tag-name" data-tags="Asm"><span class="iconfont-archer">&#xe606;</span>Asm</span>
    
        <span class="sidebar-tag-name" data-tags="Canary"><span class="iconfont-archer">&#xe606;</span>Canary</span>
    
        <span class="sidebar-tag-name" data-tags="Iot"><span class="iconfont-archer">&#xe606;</span>Iot</span>
    
        <span class="sidebar-tag-name" data-tags="IDA"><span class="iconfont-archer">&#xe606;</span>IDA</span>
    
        <span class="sidebar-tag-name" data-tags="Linux"><span class="iconfont-archer">&#xe606;</span>Linux</span>
    
        <span class="sidebar-tag-name" data-tags="Tcache"><span class="iconfont-archer">&#xe606;</span>Tcache</span>
    
        <span class="sidebar-tag-name" data-tags="IO_FILE"><span class="iconfont-archer">&#xe606;</span>IO_FILE</span>
    
        <span class="sidebar-tag-name" data-tags="Fmt"><span class="iconfont-archer">&#xe606;</span>Fmt</span>
    
        <span class="sidebar-tag-name" data-tags="PDF"><span class="iconfont-archer">&#xe606;</span>PDF</span>
    
        <span class="sidebar-tag-name" data-tags="Code"><span class="iconfont-archer">&#xe606;</span>Code</span>
    
        <span class="sidebar-tag-name" data-tags="Python"><span class="iconfont-archer">&#xe606;</span>Python</span>
    
        <span class="sidebar-tag-name" data-tags="Unicorn"><span class="iconfont-archer">&#xe606;</span>Unicorn</span>
    
        <span class="sidebar-tag-name" data-tags="GDB"><span class="iconfont-archer">&#xe606;</span>GDB</span>
    
        <span class="sidebar-tag-name" data-tags="Pwntools"><span class="iconfont-archer">&#xe606;</span>Pwntools</span>
    
        <span class="sidebar-tag-name" data-tags="Qemu"><span class="iconfont-archer">&#xe606;</span>Qemu</span>
    
        <span class="sidebar-tag-name" data-tags="Gdb"><span class="iconfont-archer">&#xe606;</span>Gdb</span>
    
        <span class="sidebar-tag-name" data-tags="CTF"><span class="iconfont-archer">&#xe606;</span>CTF</span>
    
        <span class="sidebar-tag-name" data-tags="WriteUp"><span class="iconfont-archer">&#xe606;</span>WriteUp</span>
    
        <span class="sidebar-tag-name" data-tags="IntegerOverflow"><span class="iconfont-archer">&#xe606;</span>IntegerOverflow</span>
    
        <span class="sidebar-tag-name" data-tags="Cfunc"><span class="iconfont-archer">&#xe606;</span>Cfunc</span>
    
        <span class="sidebar-tag-name" data-tags="HouseOfRoman"><span class="iconfont-archer">&#xe606;</span>HouseOfRoman</span>
    
        <span class="sidebar-tag-name" data-tags="ShellCode"><span class="iconfont-archer">&#xe606;</span>ShellCode</span>
    
        <span class="sidebar-tag-name" data-tags="CTFtime"><span class="iconfont-archer">&#xe606;</span>CTFtime</span>
    
        <span class="sidebar-tag-name" data-tags="XCTF"><span class="iconfont-archer">&#xe606;</span>XCTF</span>
    
        <span class="sidebar-tag-name" data-tags="Fastbin"><span class="iconfont-archer">&#xe606;</span>Fastbin</span>
    
        <span class="sidebar-tag-name" data-tags="FormatString"><span class="iconfont-archer">&#xe606;</span>FormatString</span>
    
        <span class="sidebar-tag-name" data-tags="StackOvrtflow"><span class="iconfont-archer">&#xe606;</span>StackOvrtflow</span>
    
        <span class="sidebar-tag-name" data-tags="prctl"><span class="iconfont-archer">&#xe606;</span>prctl</span>
    
        <span class="sidebar-tag-name" data-tags="global_max_fast"><span class="iconfont-archer">&#xe606;</span>global_max_fast</span>
    
        <span class="sidebar-tag-name" data-tags="read"><span class="iconfont-archer">&#xe606;</span>read</span>
    
        <span class="sidebar-tag-name" data-tags="UAF"><span class="iconfont-archer">&#xe606;</span>UAF</span>
    
        <span class="sidebar-tag-name" data-tags="Re"><span class="iconfont-archer">&#xe606;</span>Re</span>
    
        <span class="sidebar-tag-name" data-tags="FastbinAttack"><span class="iconfont-archer">&#xe606;</span>FastbinAttack</span>
    
        <span class="sidebar-tag-name" data-tags="HeapOverflow"><span class="iconfont-archer">&#xe606;</span>HeapOverflow</span>
    
        <span class="sidebar-tag-name" data-tags="wargame"><span class="iconfont-archer">&#xe606;</span>wargame</span>
    
        <span class="sidebar-tag-name" data-tags="Cpp"><span class="iconfont-archer">&#xe606;</span>Cpp</span>
    
        <span class="sidebar-tag-name" data-tags="Arm"><span class="iconfont-archer">&#xe606;</span>Arm</span>
    
        <span class="sidebar-tag-name" data-tags="SystemCall"><span class="iconfont-archer">&#xe606;</span>SystemCall</span>
    
        <span class="sidebar-tag-name" data-tags="StackOverflow"><span class="iconfont-archer">&#xe606;</span>StackOverflow</span>
    
        <span class="sidebar-tag-name" data-tags="OJ"><span class="iconfont-archer">&#xe606;</span>OJ</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="Assembly"><span class="iconfont-archer">&#xe60a;</span>Assembly</span>
    
        <span class="sidebar-category-name" data-categories="Code"><span class="iconfont-archer">&#xe60a;</span>Code</span>
    
        <span class="sidebar-category-name" data-categories="Binary"><span class="iconfont-archer">&#xe60a;</span>Binary</span>
    
        <span class="sidebar-category-name" data-categories="Linux"><span class="iconfont-archer">&#xe60a;</span>Linux</span>
    
        <span class="sidebar-category-name" data-categories="WriteUp"><span class="iconfont-archer">&#xe60a;</span>WriteUp</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "骑麦兜看落日"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
        <div class="site-search">
  <div class="algolia-popup popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="iconfont-archer">&#xe609;</i>
    </span>
  </div>
</div>
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.8.0/dist/instantsearch.min.js" defer></script>
        <script src="/scripts/search.js" defer></script>
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


